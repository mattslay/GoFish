*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.20" SourceFile="my.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS mybase AS custom 		&& The base class for My namespace classes
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: addmembers		&& Adds the member objects specified in the My table
		*m: calledfromthisclass		&& Determines if a method was called from another method in this class or not
		*m: openmytable		&& Opens the My table
		*m: warning		&& Gives a warning message
		*p: builder		&& The builder to use
		*p: ccaption		&& The title for any MESSAGEBOX dialogs
		*p: cnamespace		&& The name space for this object
		*p: errormessage		&& The text of any error that occurred
		*p: quietmode		&& .T. if we should not display any error messages
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	PROTECTED addobject,addproperty,baseclass,class,classlibrary,cloneobject,comment,controlcount,controls,destroy,error,height,helpcontextid,Init,newobject,objects,parentclass,picture,removeobject,resettodefault,saveasclass,showwhatsthis,tag,whatsthishelpid,width,writeexpression,writemethod
	*<PropValue>
		builder = My.vcx,MyBuilderForm
		ccaption = My Framework
		cnamespace = 
		errormessage = 
		Name = "mybase"
		quietmode = .F.
		Width = 17
		_memberdata = <VFPData>
			<memberdata name="openmytable" type="method" display="OpenMyTable"/>
			<memberdata name="addmembers" type="method" display="AddMembers"/>
			<memberdata name="cnamespace" type="property" display="cNameSpace"/>
			<memberdata name="builder" type="property" display="Builder"/>
			<memberdata name="warning" type="method" display="Warning"/>
			<memberdata name="ccaption" type="property" display="cCaption"/>
			<memberdata name="errormessage" type="property" display="ErrorMessage"/>
			<memberdata name="quietmode" type="property" display="QuietMode"/>
			<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
		</VFPData>
	*</PropValue>
	
	PROTECTED PROCEDURE addmembers		&& Adds the member objects specified in the My table
		* Add all member objects registered in the My table.
		
		local lnSelect, ;
			lcNameSpace, ;
			lnLen, ;
			lcCursor, ;
			lcMember, ;
			lcLibrary
		
		* Create a cursor of all objects in this namespace.
		
		lnSelect    = select()
		lcNameSpace = upper(This.cNameSpace) + '.'
		lnLen       = len(lcNameSpace) + 1
		lcCursor    = sys(2015)
		select * from __MY where upper(MEMBER) like (lcNameSpace + '%') and ;
			not empty(CLASS) and not deleted() into cursor (lcCursor)
		
		* Go through the members, adding any that are directly within this namespace
		* (for example, if this is "My", we'll add "My.Computers" but not
		* "My.Computers.Audio").
		
		scan
			lcMember  = alltrim(substr(MEMBER, lnLen))
			lcLibrary = fullpath(alltrim(LIBRARY), This.ClassLibrary)
			if at('.', lcMember) = 0 and file(lcLibrary)
				This.NewObject(lcMember, alltrim(CLASS), lcLibrary)
			endif at('.', lcMember) = 0 ...
		endscan
		use
		select (lnSelect)
		
	ENDPROC

	PROTECTED PROCEDURE calledfromthisclass		&& Determines if a method was called from another method in this class or not
		*==============================================================================
		* Method:			CalledFromThisClass
		* Status:			Protected
		* Purpose:			Determines if the method that called this method was called
		*						from a method of this class or an ancestor
		* Parameters:		none
		* Returns:			.T. if the method that called this method was called from a
		*						method of this class or an ancestor
		* Environment in:	none
		* Environment out:	none
		* Notes:			The reason we want to know if the method that called this
		*						method was called from a method of this class or not is
		*						to permit "read-only" properties to be changed only by
		*						methods of this class. This would typically be called
		*						from an Assign method, such as:
		*
		*					lparameters tuNewValue
		*					if This.CalledFromThisClass()
		*						This.<property> = tuNewValue
		*					else
		*						error 1743, '<property>'   && property is read-only
		*					endif This.CalledFromThisClass()
		*==============================================================================
		
		local lnLevel, ;
			lcProgram, ;
			lcObject, ;
			loParent, ;
			laClasses[1], ;
			lnClasses, ;
			lnI, ;
			llReturn, ;
			lcThisName
		
		* Get the name of the program that called us, and get the object name from it.
		* Set loParent to our parent if there is one.
		
		lnLevel   = program(-1)
		lcProgram = iif(lnLevel > 2, upper(program(lnLevel - 2)), '')
		lcObject  = left(lcProgram, rat('.', lcProgram) - 1)
		loParent  = iif(type('This.Parent') = 'O', This.Parent, .NULL.)
		
		* Check our class hierarchy to see if we were called from ourselves or an
		* ancester method.
		
		lnClasses = aclass(laClasses, This)
		for lnI = 1 to lnClasses
			if lcObject == upper(laClasses[lnI])
				llReturn = .T.
				exit
			endif lcObject == upper(laClasses[lnI])
		next lnI
		
		* If we didn't come from ourselves or an ancestor and we have a parent, our
		* name may not match our class, so check the containership hierarchy.
		
		if not llReturn and not isnull(loParent)
			lcThisName = This.Name
			do while vartype(loParent) = 'O'
				lcThisName = loParent.Name + '.' + lcThisName
				loParent   = iif(type('loParent.Parent') = 'O', loParent.Parent, ;
					.NULL.)
			enddo while vartype(loParent) = 'O'
			llReturn = upper(lcObject) == upper(lcThisName)
		endif not llReturn ...
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE Destroy
		* Close the My table.
		
		use in select('__MY')
		
	ENDPROC

	PROTECTED PROCEDURE Init
		local llReturn
		with This
		
		* Set our QuietMode flag based on whether we're in development mode or not.
		
			.QuietMode = version(2) = 0
		
		* Open the My table. If we succeeded, add all members registered in it.
		
			llReturn = .OpenMyTable()
			if llReturn
				.AddMembers()
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE openmytable		&& Opens the My table
		* Open the My table and return whether we succeeded or not.
		
		local lcDir, ;
			lcTable, ;
			llReturn, ;
			loException as Exception
		lcDir   = sys(16)
		lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
		lcTable = lcDir + 'My.DBF'
		if used('__MY')
			llReturn = .T.
		else
			try
				use (lcTable) again shared order MEMBER alias __MY in 0
				llReturn = .T.
			catch to loException
				This.Warning('Cannot open ' + lcTable + '. The error message is:' + ;
					ccCR + ccCR + loException.Message)
				llReturn = .F.
			endtry
		endif used('__MY')
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE warning		&& Gives a warning message
		* Display a warning message.
		
		lparameters tcMessage
		if not This.QuietMode
			messagebox(tcMessage, MB_ICONEXCLAMATION, This.cCaption)
		endif not This.QuietMode
		This.ErrorMessage = tcMessage
		
	ENDPROC

ENDDEFINE
