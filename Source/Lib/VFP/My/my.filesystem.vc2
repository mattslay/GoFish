*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="my.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS filesystem AS mybase OF "my.vcx" 		&& Provides access to file system attributes and methods
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: copydirectory		&& Copies the contents of the specified folder(s)
		*m: copyfile		&& Copies the specified file(s)
		*m: drives_access
		*m: drives_assign
		*m: getdirectoryinfo		&& Returns a Folder object for the specified folder
		*m: getdriveinfo		&& Returns a drive object for the specified drive letter
		*m: getfileinfo		&& Returns a File object for the specified file name
		*m: getlongfilename		&& Returns the long file name for a short (8.3) file name
		*m: getshortfilename		&& Returns the short (8.3) file name for a long file name
		*m: movedirectory		&& Moves the contents of the specified folder(s)
		*m: movefile		&& Moves the specified file(s)
		*p: drives		&& A collection of Drive objects
		*p: ofso		&& A reference to a FileSystemObject object
		*p: owsh		&& A reference to a Windows Script Host object
	*</DefinedPropArrayMethod>

	PROTECTED ofso,owsh
	*<PropValue>
		cnamespace = My.Computer.FileSystem
		drives = .NULL.
		Name = "filesystem"
		ofso = .NULL.
		owsh = .NULL.
		_memberdata = <VFPData>
			<memberdata name="openmytable" type="method" display="OpenMyTable"/>
			<memberdata name="addmembers" type="method" display="AddMembers"/>
			<memberdata name="cnamespace" type="property" display="cNameSpace"/>
			<memberdata name="copyfile" type="method" display="CopyFile"/>
			<memberdata name="copydirectory" type="method" display="CopyDirectory"/>
			<memberdata name="getdriveinfo" type="method" display="GetDriveInfo"/>
			<memberdata name="getfileinfo" type="method" display="GetFileInfo"/>
			<memberdata name="getdirectoryinfo" type="method" display="GetDirectoryInfo"/>
			<memberdata name="ofso" type="method" display="oFSO"/>
			<memberdata name="owsh" type="method" display="oWSH"/>
			<memberdata name="getlongfilename" type="method" display="GetLongFileName"/>
			<memberdata name="getshortfilename" type="method" display="GetShortFileName"/>
			<memberdata name="movefile" type="method" display="MoveFile"/>
			<memberdata name="movedirectory" type="method" display="MoveDirectory"/>
			<memberdata name="drives" type="property" display="Drives"/>
			<memberdata name="drives_access" type="method" display="Drives_Access"/>
			<memberdata name="drives_assign" type="method" display="Drives_Assign"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE copydirectory		&& Copies the contents of the specified folder(s)
		* Copy the contents of the specified folder.
		
		lparameters SourceFolder as String, ;
			DestinationFolder as String, ;
			Overwrite as Logical
		local llReturn
		do case
			case vartype(SourceFolder) <> 'C' or empty(SourceFolder) or ;
				vartype(DestinationFolder) <> 'C' or empty(DestinationFolder)
				error cnERR_ARGUMENT_INVALID
			case not directory(SourceFolder)
				error cnERR_FILE_NOT_FOUND
			otherwise
				This.oFSO.CopyFolder(SourceFolder, DestinationFolder, Overwrite)
				llReturn = directory(DestinationFolder)
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE copyfile		&& Copies the specified file(s)
		* Copy the specified file.
		
		lparameters SourceFile as String, ;
			DestinationFile as String, ;
			Overwrite as Logical
		local llReturn
		do case
			case vartype(SourceFile) <> 'C' or empty(SourceFile) or ;
				vartype(DestinationFile) <> 'C' or empty(DestinationFile)
				error cnERR_ARGUMENT_INVALID
			case not file(SourceFile)
				error cnERR_FILE_NOT_FOUND
			otherwise
				This.oFSO.CopyFile(SourceFile, DestinationFile, Overwrite)
				llReturn = file(DestinationFile)
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE Destroy
		* Nuke member objects.
		
		This.oWSH = .NULL.
		This.oFSO = .NULL.
		dodefault()
		
	ENDPROC

	PROCEDURE drives_access
		return This.oFSO.Drives
		
	ENDPROC

	PROCEDURE drives_assign
		* Trow a "property is read-only" error.
		
		lparameters tuValue
		error cnERR_PROPERTY_READ_ONLY, 'Drives'
		
	ENDPROC

	PROCEDURE getdirectoryinfo		&& Returns a Folder object for the specified folder
		* Return a Folder object for the specified folder.
		
		lparameters FolderName as String
		local luReturn
		luReturn = .NULL.
		do case
			case vartype(FolderName) <> 'C' or empty(FolderName)
				error cnERR_ARGUMENT_INVALID
			case not directory(FolderName)
				error cnERR_FILE_NOT_FOUND
			otherwise
				luReturn = This.oFSO.GetFolder(FolderName)
		endcase
		return luReturn
		
	ENDPROC

	PROCEDURE getdriveinfo		&& Returns a drive object for the specified drive letter
		* Return a Drive object for the specified drive.
		
		lparameters DriveLetter as String
		local luReturn, ;
			lcDrive, ;
			loException, ;
			llError
		luReturn = .NULL.
		if vartype(DriveLetter) = 'C' and not empty(DriveLetter)
			if right(DriveLetter, 1) = ':'
				lcDrive = left(DriveLetter, 1)
			else
				lcDrive = DriveLetter
			endif right(DriveLetter, 1) = ':'
			try
				luReturn = This.oFSO.GetDrive(lcDrive)
			catch to loException
				llError = .T.
			endtry
			if llError
				error cnERR_INVALID_PATH_OR_FILE
			endif llError
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(DriveLetter) = 'C' ...
		return luReturn
		
	ENDPROC

	PROCEDURE getfileinfo		&& Returns a File object for the specified file name
		* Return a File object for the specified file.
		
		lparameters FileName as String
		local luReturn
		luReturn = .NULL.
		do case
			case vartype(FileName) <> 'C' or empty(FileName)
				error cnERR_ARGUMENT_INVALID
			case not file(FileName)
				error cnERR_FILE_NOT_FOUND
			otherwise
				luReturn = This.oFSO.GetFile(FileName)
		endcase
		return luReturn
		
	ENDPROC

	PROCEDURE getlongfilename		&& Returns the long file name for a short (8.3) file name
		lparameters FileName as String
		local lcFile, ;
			lnLength, ;
			lcBuffer
		if vartype(FileName) = 'C' and not empty(FileName)
			declare integer GetLongPathName in Win32API ;
				string @lpszShortPath, string @lpszLongPath, integer cchBuffer
			lcFile   = FileName + ccNULL
			lnLength = 260
			lcBuffer = space(lnLength)
			GetLongPathName(@lcFile, @lcBuffer, lnLength)
			lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(FileName) = 'C' ...
		return lcFile
		
	ENDPROC

	PROCEDURE getshortfilename		&& Returns the short (8.3) file name for a long file name
		lparameters FileName as String
		local lcFile, ;
			lnLength, ;
			lcBuffer
		if vartype(FileName) = 'C' and not empty(FileName)
			declare integer GetShortPathName in Win32API ;
				string @lpszLongPath, string @lpszShortPath, integer cchBuffer
			lcFile   = FileName + ccNULL
			lnLength = 260
			lcBuffer = space(lnLength)
			GetShortPathName(@lcFile, @lcBuffer, lnLength)
			lcFile = left(lcBuffer, at(ccNULL, lcBuffer) - 1)
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(FileName) = 'C' ...
		return lcFile
		
	ENDPROC

	PROCEDURE Init
		* Create instances of the Windows Script Host and File System Object.
		
		This.oWSH = createobject('WScript.Shell')
		This.oFSO = createobject('Scripting.FileSystemObject')
		dodefault()
		
	ENDPROC

	PROCEDURE movedirectory		&& Moves the contents of the specified folder(s)
		* Move the contents of the specified folder.
		
		lparameters SourceFolder as String, ;
			DestinationFolder as String
		local llReturn
		do case
			case vartype(SourceFolder) <> 'C' or empty(SourceFolder) or ;
				vartype(DestinationFolder) <> 'C' or empty(DestinationFolder)
				error cnERR_ARGUMENT_INVALID
			case not directory(SourceFolder)
				error cnERR_FILE_NOT_FOUND
			otherwise
				try
					This.oFSO.MoveFolder(SourceFolder, DestinationFolder)
					llReturn = directory(DestinationFolder)
				catch to loException
				endtry
		endcase
		return llReturn
		
	ENDPROC

	PROCEDURE movefile		&& Moves the specified file(s)
		* Move the specified file.
		
		lparameters SourceFile as String, ;
			DestinationFile as String
		local llReturn
		do case
			case vartype(SourceFile) <> 'C' or empty(SourceFile) or ;
				vartype(DestinationFile) <> 'C' or empty(DestinationFile)
				error cnERR_ARGUMENT_INVALID
			case not file(SourceFile)
				error cnERR_FILE_NOT_FOUND
			otherwise
				This.oFSO.MoveFile(SourceFile, DestinationFile)
				llReturn = file(DestinationFile)
		endcase
		return llReturn
		
	ENDPROC

ENDDEFINE
