*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.20" SourceFile="my.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS data AS mybase OF "my.vcx" 		&& Provides data-handling features
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: closeallinstances		&& Closes all open copies of a given table in all datasessions
		*m: closeallinstancesindatasession		&& Closes all open copies of a given table in the specified datasession
		*m: closeopenedcursors		&& Closes any cursors opened since OpenCursorSnapshot was called
		*m: goto		&& Performs a "safe" GOTO
		*m: opencursorsnapshot		&& Takes a snapshot of all open cursors so CloseOpenedCursors knows what to close
		*a: acursors[1,0]		&& An array of open cursors
	*</DefinedPropArrayMethod>

	PROTECTED acursors
	*<PropValue>
		cnamespace = My.Data
		Name = "data"
		_memberdata = <VFPData>
			<memberdata name="openmytable" type="method" display="OpenMyTable"/>
			<memberdata name="addmembers" type="method" display="AddMembers"/>
			<memberdata name="cnamespace" type="property" display="cNameSpace"/>
			<memberdata name="builder" type="property" display="Builder"/>
			<memberdata name="warning" type="method" display="Warning"/>
			<memberdata name="ccaption" type="property" display="cCaption"/>
			<memberdata name="errormessage" type="property" display="ErrorMessage"/>
			<memberdata name="quietmode" type="property" display="QuietMode"/>
			<memberdata name="calledfromthisclass" type="method" display="CalledFromThisClass"/>
			<memberdata name="opencursorsnapshot" type="method" display="OpenCursorSnapshot"/>
			<memberdata name="acursors" type="property" display="aCursors"/>
			<memberdata name="closeopenedcursors" type="method" display="CloseOpenedCursors"/>
			<memberdata name="goto" type="method" display="GoTo"/>
			<memberdata name="closeallinstances" type="method" display="CloseAllInstances"/>
			<memberdata name="closeallinstancesindatasession" type="method" display="CloseAllInstancesInDataSession"/>
		</VFPData>
	*</PropValue>
	
	PROCEDURE closeallinstances		&& Closes all open copies of a given table in all datasessions
		lparameters TableName as String
		local lcFile, ;
			laSessions[1], ;
			lnSessions, ;
			lnI
		if vartype(TableName) = 'C' and not empty(TableName)
			with This
				lcFile     = upper(TableName)
				lnSessions = asessions(laSessions)
				for lnI = lnSessions to 1 step -1
					.CloseAllInstancesInDataSession(lcFile, laSessions[lnI])
				next lnI
			endwith
		else
			error cnERR_ARGUMENT_INVALID
		endif vartype(TableName) = 'C' ...
		return
		
	ENDPROC

	PROTECTED PROCEDURE closeallinstancesindatasession		&& Closes all open copies of a given table in the specified datasession
		lparameters tcFile, ;
			tnDataSession
		local lnDataSession, ;
			lcFullPath, ;
			laTables[1], ;
			lnTables, ;
			lcAlias, ;
			lnI, ;
			lcTable
		lnDataSession = set('DATASESSION')
		set datasession to tnDataSession
		lcFullPath = set('FULLPATH')
		set fullpath on
		lnTables = aused(laTables)
		lcAlias  = strtran(juststem(tcFile), ' ', '_')
		for lnI = 1 to lnTables
			lcTable = laTables[lnI, 1]
			if dbf(lcTable) == tcFile or lcTable == tcFile or lcTable == lcAlias
				use in (lcTable)
			endif dbf(lcTable) == tcFile ...
		next lnI
		if lcFullPath = 'OFF'
			set fullpath off
		endif lcFullPath = 'OFF'
		set datasession to lnDataSession
		return
		
	ENDPROC

	PROCEDURE closeopenedcursors		&& Closes any cursors opened since OpenCursorSnapshot was called
		lparameters DataSessionID as Integer
		local lnSessions, ;
			laSessions[1], ;
			lnDataSession, ;
			llError, ;
			llDataSession, ;
			laCursors[1], ;
			lnCursors, ;
			lnI, ;
			lcCursor
		
		* If the datasession was passed, save the current one and set the datasession
		* to it.
		
		lnSessions    = asessions(laSessions)
		lnDataSession = set('DATASESSION')
		do case
			case alen(This.aCursors, 2) = 0
				error 'You must call OpenCursorSnapshot before calling CloseOpenedCursors.'
			case pcount() = 1 and (vartype(DataSessionID) <> 'N' or ;
				not between(DataSessionID, 1, lnSessions))
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 1 and DataSessionID <> lnDataSession
				set datasession to DataSessionID
				llDataSession = .T.
		endcase
		if not llError
		
		* Get an array of currently open tables and go through them one at a time. If
		* the table wasn't open before, close it.
		
			lnCursors = aused(laCursors)
			for lnI = 1 to lnCursors
				lcCursor = laCursors[lnI, 1]
				if not empty(lcCursor) and ;
					ascan(This.aCursors, lcCursor, -1, -1, 1, 7) = 0
					use in (lcCursor)
				endif not empty(lcCursor) ...
			next lnI
		
		* Restore the former datasession if necessary.
		
			if llDataSession
				set datasession to DataSessionID
			endif llDataSession
		endif not llError
		return
		
	ENDPROC

	PROCEDURE goto		&& Performs a "safe" GOTO
		lparameters RecordNumber as Integer, ;
			Alias as String, ;
			DataSessionID as Integer
		local lnSessions, ;
			laSessions[1], ;
			lnDataSession, ;
			llError, ;
			llDataSession, ;
			lcAlias
		lnSessions    = asessions(laSessions)
		lnDataSession = set('DATASESSION')
		do case
			case vartype(RecordNumber) <> 'N'
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 3 and (vartype(DataSessionID) <> 'N' or ;
				not between(DataSessionID, 1, lnSessions))
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 3 and DataSessionID <> lnDataSession
				set datasession to DataSessionID
				llDataSession = .T.
			otherwise
				lnDataSession = set('DATASESSION')
		endcase
		if not llError
		
		* If no alias was passed, use the alias in the current workarea.
		
			do case
				case vartype(Alias) <> 'C' or empty(Alias)
					lcAlias = alias()
				case not used(Alias)
					error cnERR_ALIAS_NOTFOUND, Alias
					lcAlias = ''
				otherwise
					lcAlias = Alias
			endcase
		
		* Move the record pointer.
		
			do case
				case empty(lcAlias)
				case RecordNumber < 0 or between(RecordNumber, 1, reccount(lcAlias))
					go RecordNumber in (lcAlias)
				otherwise
					go bottom in (lcAlias)
					if not eof(lcAlias)
						skip in (lcAlias)
					endif not eof(lcAlias)
			endcase
		
		* Restore the former datasession if necessary.
		
			if llDataSession
				set datasession to DataSessionID
			endif llDataSession
		endif not llError
		return
		
	ENDPROC

	PROCEDURE opencursorsnapshot		&& Takes a snapshot of all open cursors so CloseOpenedCursors knows what to close
		lparameters DataSessionID as Integer
		local lnSessions, ;
			laSessions[1], ;
			llError, ;
			lnDataSession, ;
			lnCursors, ;
			laCursors[1]
		lnSessions = asessions(laSessions)
		do case
			case pcount() = 1 and (vartype(DataSessionID) <> 'N' or ;
				not between(DataSessionID, 1, lnSessions))
				llError = .T.
				error cnERR_ARGUMENT_INVALID
			case pcount() = 1
				lnDataSession = DataSessionID
			otherwise
				lnDataSession = set('DATASESSION')
		endcase
		if not llError
			lnCursors = aused(laCursors, lnDataSession)
			if lnCursors = 0
				dimension This.aCursors[1, 2]
			else
				dimension This.aCursors[lnCursors, 2]
			endif lnCursors = 0
			acopy(laCursors, This.aCursors)
		endif not llError
		
	ENDPROC

ENDDEFINE
