*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.20" SourceFile="my.vcx" CPID="1252" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS registry AS mybase OF "my.vcx" 		&& Provides access to the Windows Registry
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myregistry.h"
	*<DefinedPropArrayMethod>
		*m: closekey		&& Closes the current registry key
		*m: deletekey		&& Deletes the specified key
		*m: deletekeyvalue		&& Deletes the specified value from the specified key
		*m: enumeratekeys		&& Returns a collection of keys in the specified key
		*m: enumeratekeyvalues		&& Returns a collection of keys and values in the specified key
		*m: getkey		&& Gets the hive and key from the specified key
		*m: getvalue		&& Gets the specified value from the specified key
		*m: openkey		&& Opens the specified key
		*m: setvalue		&& Sets the specified value in the specified registry key
		*p: ccurrentkey		&& The key to use for the current access
		*p: ncurrentkey		&& The current open key handle
		*p: ncurrentmainkey		&& The current hive being accessed
		*p: nmainkey		&& The default hive being accessed
	*</DefinedPropArrayMethod>

	PROTECTED ccurrentkey,ncurrentkey,ncurrentmainkey,nmainkey
	*<PropValue>
		ccurrentkey = 
		cnamespace = My.Computer.Registry
		Name = "registry"
		ncurrentkey = 0
		ncurrentmainkey = 0
		nmainkey = 0
		_memberdata = <VFPData>
			<memberdata name="openmytable" type="method" display="OpenMyTable"/>
			<memberdata name="addmembers" type="method" display="AddMembers"/>
			<memberdata name="cnamespace" type="property" display="cNameSpace"/>
			<memberdata name="builder" type="property" display="Builder"/>
			<memberdata name="closekey" type="method" display="CloseKey"/>
			<memberdata name="deletekey" type="method" display="DeleteKey"/>
			<memberdata name="deletekeyvalue" type="method" display="DeleteKeyValue"/>
			<memberdata name="getkey" type="method" display="GetKey"/>
			<memberdata name="getvalue" type="method" display="GetValue"/>
			<memberdata name="openkey" type="method" display="OpenKey"/>
			<memberdata name="setvalue" type="method" display="SetValue"/>
			<memberdata name="ccurrentkey" type="property" display="cCurrentKey"/>
			<memberdata name="ncurrentkey" type="property" display="nCurrentKey"/>
			<memberdata name="ncurrentmainkey" type="property" display="nCurrentMainKey"/>
			<memberdata name="nmainkey" type="property" display="nMainKey"/>
			<memberdata name="enumeratekeys" type="method" display="EnumerateKeys"/>
			<memberdata name="enumeratekeyvalues" type="method" display="EnumerateKeyValues"/>
		</VFPData>
	*</PropValue>
	
	PROTECTED PROCEDURE closekey		&& Closes the current registry key
		* Close the current key and blank the current key value.
		
		with This
			RegCloseKey(.nCurrentKey)
			.nCurrentKey = 0 
		endwith
		
	ENDPROC

	PROCEDURE deletekey		&& Deletes the specified key
		* Delete the specified key and all subkeys and values under it.
		
		lparameters Key as String
		local lcCurrentKey, ;
			loKeys, ;
			llReturn, ;
			lcKey, ;
			lnResult
		with This
		
		* Get the key and hive to use, then get a collection of subkeys and delete
		* each one by calling ourselves recursively. Then delete the key and return .T.
		* if it succeeded.
		
			if .GetKey(Key)
				lcCurrentKey = .cCurrentKey
				loKeys       = .EnumerateKeys(Key)
				llReturn     = .T.
				for each lcKey in loKeys
					lcKey    = addbs(Key) + lcKey
					llReturn = .DeleteKey(lcKey)
					if not llReturn
						exit
					endif not llReturn
				next lcKey
				.cCurrentKey = lcCurrentKey
				if llReturn
					lnResult = RegDeleteKey(.nCurrentMainKey, .cCurrentKey)
					llReturn = lnResult = cnSUCCESS
				endif llReturn
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(Key)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE deletekeyvalue		&& Deletes the specified value from the specified key
		* Delete the specified value in the specified key.
		
		lparameters Key as String, ;
			ValueName as String
		local lnResult, ;
			llReturn
		with This
		
		* Give an error if the value name wasn't specified.
		
			do case
				case vartype(ValueName) <> 'C' or empty(ValueName)
					error cnERR_ARGUMENT_INVALID
		
		* Get the key and hive to use. If we succeeded, try to open the registry key.
		* If we could, delete the specified value name.
		
				case .GetKey(Key)
					if .OpenKey(.cCurrentKey, .nCurrentMainKey)
						lnResult = RegDeleteValue(.nCurrentKey, ValueName)
						llReturn = lnResult = cnSUCCESS
						.CloseKey()
					endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
				otherwise
					error cnERR_ARGUMENT_INVALID
			endcase
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE enumeratekeys		&& Returns a collection of keys in the specified key
		lparameters Key as String
		local loKeys as Collection, ;
			lnNames, ;
			lnResult, ;
			lcKey, ;
			lnSize, ;
			lcBuffer1, ;
			lnSize1, ;
			lcBuffer2
		with This
		
		* Instantiate a collection to return.
		
			loKeys = createobject('Collection')
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* Try to open the registry key. If we couldn't, return an empty collection.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Initialize the number of names and the result code.
		
					lnNames  = 0
					lnResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
					do while lnResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
						lcKey     = space(cnBUFFER_SIZE)
						lnSize    = cnBUFFER_SIZE
						lcBuffer1 = space(cnBUFFER_SIZE)
						lnSize1   = cnBUFFER_SIZE
						lcBuffer2 = space(cnBUFFER_SIZE)
		
		* Get the next key name from the Registry.
		
						lnResult = RegEnumKeyEx(.nCurrentKey, lnNames, @lcKey, ;
							@lnSize, cnRESERVED, @lcBuffer1, @lnSize1, @lcBuffer2)
		
		* If we got a name, add it to the collection.
		
						if lnResult = cnSUCCESS
							lcKey   = alltrim(lcKey)
							lcKey   = left(lcKey, len(lcKey) - 1)
							lnNames = lnNames + 1
							loKeys.Add(lcKey)
						endif lnResult = cnSUCCESS
					enddo while lnResult = cnSUCCESS
		
		* Close the registry key.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(tcKey)
		endwith
		return loKeys
		
	ENDPROC

	PROCEDURE enumeratekeyvalues		&& Returns a collection of keys and values in the specified key
		lparameters Key as String
		local loValues as Collection, ;
			lnValues, ;
			lnResult, ;
			lcKey, ;
			lnKeySize, ;
			lcValue, ;
			lnValSize, ;
			lnType, ;
			luValue
		with This
		
		* Instantiate a collection to return.
		
			loValues = createobject('Collection')
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* Try to open the registry key. If we couldn't, return an empty collection.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Initialize the number of names and the result code.
		
					lnValues = 0
					lnResult = cnSUCCESS
		
		* As long as everything is OK, keep getting key names.
		
					do while lnResult = cnSUCCESS
		
		* Create buffers to hold return values from the Registry function.
		
						lcKey     = space(cnBUFFER_SIZE)
						lnKeySize = cnBUFFER_SIZE
						lcValue   = space(cnBUFFER_SIZE)
						lnValSize = cnBUFFER_SIZE
						lnType    = 0
		
		* Get the next key name from the Registry.
		
						lnResult = RegEnumValue(.nCurrentKey, lnValues, @lcKey, ;
							@lnKeySize, cnRESERVED, @lnType, @lcValue, @lnValSize)
		
		* If we got a name, add it to the collection.
		
						if lnResult = cnSUCCESS
							lcKey    = left(lcKey, lnKeySize)
							lnValues = lnValues + 1
							do case
								case lnType = cnREG_SZ
									luValue = left(lcValue, lnValSize - 1)
								case lpdwType = cnREG_DWORD
									luValue = ctobin(left(lcValue, 4), 'RS')
								otherwise
									luValue = ''
							endcase
							loValues.Add(luValue, lcKey)
						endif lnResult = cnSUCCESS
					enddo while lnResult = cnSUCCESS
		
		* Close the registry key.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(tcKey)
		endwith
		return loValues
		
	ENDPROC

	PROTECTED PROCEDURE getkey		&& Gets the hive and key from the specified key
		lparameters tcKey
		local llReturn, ;
			lnPos, ;
			lcMainKey
		with This
		
		* Ensure the key was specified.
		
			llReturn = .T.
			do case
				case vartype(tcKey) <> 'C' or empty(tcKey)
					llReturn = .F.
		
		* If the hive was included in the key, get it. Otherwise, use the default
		* value.
		
				case upper(left(tcKey, 5)) = 'HKEY_'
					lnPos     = at('\', tcKey)
					lcMainKey = upper(left(tcKey, lnPos - 1))
					do case
						case lcMainKey = 'HKEY_CLASSES_ROOT'
							.nCurrentMainKey = cnHKEY_CLASSES_ROOT
						case lcMainKey = 'HKEY_CURRENT_USER'
							.nCurrentMainKey = cnHKEY_CURRENT_USER
						case lcMainKey = 'HKEY_LOCAL_MACHINE'
							.nCurrentMainKey = cnHKEY_LOCAL_MACHINE
						case lcMainKey = 'HKEY_USERS'
							.nCurrentMainKey = cnHKEY_USERS
						otherwise
							llReturn = .F.
					endcase
					.cCurrentKey = substr(tcKey, lnPos + 1)
				otherwise
					.nCurrentMainKey = .nMainKey
					.cCurrentKey     = tcKey
			endcase
		
		* Strip any trailing backslash off the key (Windows 95/98 won't accept a
		* trailing backslash).
		
			if llReturn
				.cCurrentKey = iif(right(.cCurrentKey, 1) = '\', ;
					left(.cCurrentKey, len(.cCurrentKey) - 1), .cCurrentKey)
			endif llReturn
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE getvalue		&& Gets the specified value from the specified key
		lparameters Key as String, ;
			ValueName as String, ;
			DefaultValue as Variant
		local luValue, ;
			lcValueName, ;
			lcBuffer, ;
			lnSize, ;
			lnType, ;
			lnResult
		with This
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* If the default to use wasn't passed, initialize it to an empty string.
		
				luValue = iif(vartype(DefaultValue) = 'C', DefaultValue, '')
		
		* If the value name wasn't specified, initialize it to an empty string.
		
				lcValueName = iif(pcount() = 1, '', ValueName)
		
		* Try to open the registry key. If we couldn't, return the default value.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Create a buffer to hold the key value.
		
					lcBuffer = space(cnBUFFER_SIZE)
					lnSize   = cnBUFFER_SIZE
					lnType   = 0
		
		* Set the key value. Make sure we have a data string data type.
		
					lnResult = RegQueryValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						@lnType, @lcBuffer, @lnSize)
					if lnResult = cnSUCCESS and lnType = cnREG_SZ
						luValue = left(lcBuffer, lnSize - 1)
					endif lnResult ...
		
		* Close the registry key and return the value.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
				luValue = .NULL.
			endif .GetKey(tcKey)
		endwith
		return luValue
		
	ENDPROC

	PROCEDURE Init
		* Declare the API functions we'll need.
		
		declare integer RegOpenKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegCreateKey in Win32API ;
			integer nKey, string @cSubKey, integer @nHandle
		declare integer RegDeleteKey in Win32API ;
			integer nKey, string @cSubKey
		declare integer RegCloseKey in Win32API ;
			integer nKey
		declare integer RegSetValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer nType, string cBuffer, integer nBufferSize
		declare integer RegQueryValueEx in Win32API ;
			integer nKey, string cValueName, integer nReserved, ;
			integer @nType, string @cBuffer, integer @nBufferSize
		declare integer RegDeleteValue in Win32API ;
			integer nKey, string cSubKey
		declare integer RegEnumKeyEx in Win32API ;
			integer nKey, integer nSubKey, string @cSubKey, integer @nKeySize,;
			integer nReserved, string @cBuffer, integer @nBufferSize, string @cBuffer
		declare integer RegEnumValue IN Win32API ;
			integer nKey, integer nValue, string @cSubKey, ;
			integer @nKeySize, integer nReserved, integer @nType, ;
			string @cValue, integer @nValSize
		
		* Initialize the main key to the default HKEY_CURRENT_USER.
		
		This.nMainKey = cnHKEY_CURRENT_USER
		
		* Carry on with the base behavior.
		
		dodefault()
		
	ENDPROC

	PROTECTED PROCEDURE openkey		&& Opens the specified key
		lparameters tcSubKey, ;
			tnMainKey, ;
			tlCreate
		local lnHandle, ;
			lcSubKey, ;
			lnResult, ;
			llReturn
		
		* Try to create or open the registry key. If it succeeded, store the key handle
		* in the nCurrentKey property; if not, zero nCurrentKey.
		
		with This
			lnHandle = 0
		
		* Strip any trailing backslash off the subkey (Windows NT accepts a trailing
		* backslash but Windows 95/98 do not).
		
			lcSubKey = iif(right(tcSubKey, 1) = '\', ;
				left(tcSubKey, len(tcSubKey) - 1), tcSubKey)
			if tlCreate
				lnResult = RegCreateKey(tnMainKey, lcSubKey, @lnHandle)
			else
				lnResult = RegOpenKey(tnMainKey, lcSubKey, @lnHandle)
			endif tlCreate
			llReturn     = lnResult = cnSUCCESS
			.nCurrentKey = iif(llReturn, lnHandle, 0)
		endwith
		return llReturn
		
	ENDPROC

	PROCEDURE setvalue		&& Sets the specified value in the specified registry key
		lparameters Key as String, ;
			ValueName as String, ;
			Value as Variant
		local lcType, ;
			lcValue, ;
			lnSize, ;
			lcValueName, ;
			lnResult, ;
			llReturn
		with This
		
		* Get the key and hive to use.
		
			if .GetKey(Key)
		
		* Convert the value to a string if necessary. Terminate the string with a null
		* and calculate the size.
		
				lcType = vartype(Value)
				do case
					case lcType = 'C'
						lcValue = Value
					case lcType $ 'NIFYB'
						lcValue = transform(Value)
					case lcType = 'D'
						lcValue = dtoc(Value)
					case lcType = 'T'
						lcValue = ttoc(Value)
					case lcType = 'L'
						lcValue = iif(Value, 'Y', 'N')
				endcase
				lcValue = lcValue + ccNULL
				lnSize  = len(lcValue)
		
		* If the value name wasn't specified, initialize it to an empty string.
		
				lcValueName = iif(vartype(ValueName) = 'C', ValueName, '')
		
		* Try to open or create the registry key. If we couldn't, return .F.
		
				if .OpenKey(.cCurrentKey, .nCurrentMainKey, .T.)
		
		* Set the key value.
		
					lnResult = RegSetValueEx(.nCurrentKey, lcValueName, cnRESERVED, ;
						cnREG_SZ, lcValue, lnSize)
					llReturn = lnResult = cnSUCCESS
		
		* Close the registry key and return the success flag.
		
					.CloseKey()
				endif .OpenKey(.cCurrentKey, .nCurrentMainKey, .T.)
		
		* Give an error if the key wasn't specified properly.
		
			else
				error cnERR_ARGUMENT_INVALID
			endif .GetKey(Key)
		endwith
		return llReturn
		
	ENDPROC

ENDDEFINE
