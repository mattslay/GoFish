*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="my.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS myfoxcode AS custom 		&& The IntelliSense handler for the My namespace
 	*< CLASSDATA: Baseclass="custom" Timestamp="" Scale="Pixels" Uniqueid="" />

	#INCLUDE "myconstants.h"
	*<DefinedPropArrayMethod>
		*m: displayenumeratedvalues		&& Builds a list of enumerated values for IntelliSense to display
		*m: displaymembers		&& Builds a list of members for IntelliSense to display
		*m: getmembers		&& This code returns methods used for Intellisense
		*m: getmymember		&& Finds the record in the My table matching the member or method the user typed so far
		*m: handlelocal		&& Called when we were triggered in IntelliSense from the LOCAL AS statement
		*m: main		&& Main routine that gets called by IntelliSense engine.
		*m: openintellisense		&& Opens the IntelliSense table
		*m: openmytable		&& Opens the My table
		*p: ccurrdeleted		&& The current setting of SET DELETED
		*p: lerroroccurred		&& .T. if an error occurred
		*p: _memberdata		&& XML Metadata for customizable properties
	*</DefinedPropArrayMethod>

	ccurrdeleted = 		&& The current setting of SET DELETED
	lerroroccurred = .F.		&& .T. if an error occurred
	Name = "myfoxcode"
	Width = 17
	_memberdata = <VFPData>
		<memberdata name="main" type="method" display="Main"/>
		<memberdata name="getmembers" type="method" display="GetMembers"/>
		<memberdata name="getmymember" type="method" display="GetMyMember"/>
		<memberdata name="openmytable" type="method" display="OpenMyTable"/>
		<memberdata name="handlelocal" type="method" display="HandleLOCAL"/>
		<memberdata name="displaymembers" type="method" display="DisplayMembers"/>
		<memberdata name="displayenumeratedvalues" type="method" display="DisplayEnumeratedValues"/>
		<memberdata name="openintellisense" type="method" display="OpenIntelliSense"/>
		<memberdata name="lerroroccurred" type="property" display="lErrorOccurred"/>
		<memberdata name="ccurrdeleted" type="property" display="cCurrDeleted"/>
		</VFPData>		&& XML Metadata for customizable properties
	
	PROCEDURE Destroy
		* Close the tables we opened and restore the setting of DELETED.
		
		use in select('__MY')
		use in select('__FOXCODE')
		if This.cCurrDeleted = 'OFF'
			set deleted off
		endif This.cCurrDeleted = 'OFF'
		
	ENDPROC

	PROTECTED PROCEDURE displayenumeratedvalues		&& Builds a list of enumerated values for IntelliSense to display
		lparameters toFoxCode, ;
			toData
		local laLines[1], ;
			lnLines, ;
			lnI, ;
			lcLine, ;
			lnPos, ;
			lcDescrip
		with toFoxCode
			lnLines = alines(laLines, toData.List)
			dimension .Items[lnLines, 2]
			for lnI = 1 to lnLines
				lcLine = laLines[lnI]
				lnPos  = at(',', lcLine)
				if lnPos > 0
					lcDescrip = alltrim(substr(lcLine, lnPos + 1))
					lcLine    = alltrim(left(lcLine, lnPos - 1))
				else
					lcDescrip = ''
				endif lnPos > 0
				.Items[lnI, 1] = lcLine
				.Items[lnI, 2] = lcDescrip
			next lnI
			.ValueType  = 'L'
			.ItemScript = 'funcmenu'
		endwith
		
	ENDPROC

	PROTECTED PROCEDURE displaymembers		&& Builds a list of members for IntelliSense to display
		* Builds a list of members for IntelliSense to display.
		
		lparameters toFoxCode, ;
			toData
		local loMembers, ;
			lcPath, ;
			lnI, ;
			loMember
		with toFoxCode
		
		* Get a collection of members for the current class.
		
			loMembers = This.GetMembers(alltrim(toData.Member))
			if loMembers.Count > 0
		
		* Add each member to the Items array of the FoxCode object.
		
				dimension .Items[loMembers.Count, 2]
				lcPath = iif(file('propty.bmp'), '', home() + 'FFC\Graphics\')
				for lnI = 1 to loMembers.Count
					loMember       = loMembers.Item(lnI)
					.Items[lnI, 1] = loMember.Name
					.Items[lnI, 2] = loMember.Description
					if loMember.Type = 'P'
						.Icon = lcPath + 'propty.bmp'
					else
						.Icon = lcPath + 'method.bmp'
					endif loMember.Type = 'P'
				next loMember
		
		* Set the FoxCode object's ValueType property to "L", meaning display a listbox
		* containing the items defined in the Items array.
		
				.ValueType = 'L'
			endif loMembers.Count > 0
		endwith
		
	ENDPROC

	PROCEDURE Error
		lparameters tnError, ;
			tcMethod, ;
			tnLine
		local laError[1], ;
			lcMessage
		aerror(laError)
		This.lErrorOccurred = .T.
		lcMessage = ccERR_ERROR_MESSAGE_LOC
		lcMessage = strtran(lcMessage, '{1}', transform(tnError))
		lcMessage = strtran(lcMessage, '{2}', laError[2])
		lcMessage = strtran(lcMessage, '{3}', transform(tnLine))
		lcMessage = strtran(lcMessage, '{4}', tcMethod)
		messagebox(lcMessage, MB_ICONEXCLAMATION, ccCAP_MY_FOXCODE_LOC)
		
	ENDPROC

	PROCEDURE getmembers		&& This code returns methods used for Intellisense
		* Fill a collection with the members of the namespace found in the My registry
		* table.
		
		lparameters tcNameSpace
		local loCollection, ;
			lnSelect, ;
			lcNameSpace, ;
			lnLen, ;
			lcCursor, ;
			lcMember, ;
			loMember
		loCollection = createobject('Collection')
		lnSelect     = select()
		lcNameSpace  = upper(tcNameSpace) + '.'
		lnLen        = len(lcNameSpace) + 1
		lcCursor     = sys(2015)
		select * from __My where upper(MEMBER) like (lcNameSpace + '%') and not deleted() ;
			into cursor (lcCursor)
		scan
			lcMember = alltrim(substr(MEMBER, lnLen))
			if at('.', lcMember) = 0
				loMember = createobject('Empty')
				addproperty(loMember, 'Name',        lcMember)
				addproperty(loMember, 'Description', alltrim(DESCRIP))
				addproperty(loMember, 'Type',        TYPE)
				loCollection.Add(loMember)
			endif at('.', lcMember) = 0
		endscan
		use
		select (lnSelect)
		return loCollection
		
	ENDPROC

	PROTECTED PROCEDURE getmymember		&& Finds the record in the My table matching the member or method the user typed so far
		* Determine which member of the namespace the user typed and return a SCATTER
		* NAME object from the appropriate record in the FFI table.
		
		lparameters tcUserTyped, ;
			tcNameSpace
		local loReturn, ;
			lcUserTyped, ;
			llFound, ;
			lnPos, ;
			lcMember, ;
			lnSelect
		
		* Grab what the user typed. If it ends with an opening parenthesis, strip that
		* off.
		
		loReturn    = .NULL.
		lcUserTyped = alltrim(tcUserTyped)
		if right(lcUserTyped, 1) = '('
			lcUserTyped = substr(lcUserTyped, len(lcUserTyped) - 1)
		endif right(lcUserTyped, 1) = '('
		
		* Find the record for the class in the My table. If there's a period in the
		* typed text, try to find a record for the member.
		
		if seek(upper(padr(tcNameSpace, len(__My.CLASS))), '__My', 'MEMBER')
			llFound = .T.
			lnPos   = at('.', lcUserTyped)
			if lnPos > 0
				lcMember = alltrim(__My.MEMBER) + substr(lcUserTyped, lnPos)
				llFound  = seek(upper(padr(lcMember, len(__My.MEMBER))), '__My', ;
					'MEMBER')
			endif lnPos > 0
		
		* If we found the desired record, create a SCATTER NAME object for it.
		
			if llFound
				lnSelect = select()
				select __My
				scatter memo name loReturn
				select (lnSelect)
			endif llFound
		endif seek(upper(padr(tcNameSpace ...
		return loReturn
		
	ENDPROC

	PROTECTED PROCEDURE handlelocal		&& Called when we were triggered in IntelliSense from the LOCAL AS statement
		* Handle being triggered from the LOCAL AS statement.
		
		lparameters toFoxCode, ;
			tcNameSpace, ;
			tcClass, ;
			tcLibrary
		local lcCode, ;
			lcCase, ;
			lcVariable, ;
			lcReturn
		with toFoxCode
			lcCode = 'NEWOBJECT'
			lcCase = ''
		
		* Open the IntelliSense table and find the record for the NEWOBJECT function.
		* If we did, get the case we're supposed to use. If it specifies the default
		* IntelliSense case, get that from the V record.
		
			if This.OpenIntelliSense() and seek('FNEWO', '__FOXCODE', 1)
				lcCase = __FOXCODE.CASE
				lcCode = alltrim(__FOXCODE.EXPANDED)
				if empty(lcCase) and seek('V', '__FOXCODE', 1)
					lcCase = __FOXCODE.CASE
				endif empty(lcCase) ...
			endif This.OpenIntelliSense() ...
		
		* Handle the case as specified.
		
			do case
				case lcCase = 'U'
					lcCode = upper(lcCode)
				case lcCase = 'L'
					lcCode = lower(lcCode)
				case lcCase = 'P'
					lcCode = proper(lcCode)
			endcase
		
		* Get the variable name the user typed in the LOCAL VariableName AS statement,
		* then construct the code we want inserted and set the ValueType property of
		* the FoxCode object to "V" so it inserts this string.
		
			lcVariable = substr(.FullLine, rat(' ', .FullLine) + 1)
		*** Note: we'll use KEYBOARD rather than including the code to add in lcReturn
		*** so the code is indented properly if necessary
		***	lcReturn   = tcNameSpace + chr(13) + lcVariable + ' = ' + lcCode + "('" + ;
				tcClass + "', '" + tcLibrary + "')" + chr(13)
			lcReturn   = tcNameSpace
			if not This.lErrorOccurred
				keyboard chr(13) + lcVariable + ' = ' + lcCode + "('" + ;
					tcClass + "', '" + tcLibrary + "')" + chr(13) plain
			endif not This.lErrorOccurred
			.ValueType = 'V'
		endwith
		return lcReturn
		
	ENDPROC

	PROCEDURE Init
		* Turn debugging on.
		
		sys(2030, 1)
		
		* Open the My table.
		
		local llReturn
		llReturn = This.OpenMyTable()
		if not llReturn
			messagebox(ccERR_COULD_NOT_OPEN_MY_LOC, MB_ICONEXCLAMATION, ;
				ccCAP_MY_FOXCODE_LOC)
		endif not llReturn
		return llReturn
		
	ENDPROC

	PROCEDURE main		&& Main routine that gets called by IntelliSense engine.
		* This is main routine that gets called from the IntelliSense script for My.
		
		lparameters toFoxCode
		local lcNameSpace, ;
			loData, ;
			lcReturn, ;
			lcTrigger
		with toFoxCode
			.ValueType = 'V'
		
		* Get the namespace and an object from the My table for that namespace.
		
			lcNameSpace = .Data
			loData      = This.GetMyMember(.UserTyped, lcNameSpace)
			lcReturn    = ''
			do case
		
		* We couldn't figure out which member was specified.
		
				case vartype(loData) <> 'O'
		
		* If we're on the LOCAL statement, handle that by returning text we want
		* inserted.
		
				case atc(lcNameSpace, .MenuItem) > 0
					lcReturn = This.HandleLOCAL(toFoxCode, lcNameSpace, ;
						trim(loData.Class), trim(loData.Library))
		
		* Other IntelliSense. Start by getting the character that triggered
		* IntelliSense.
		
				otherwise
					lcTrigger = right(.FullLine, 1)
					do case
		
		* If we were triggered by a ".", display a list of members.
		
						case lcTrigger = '.'
							This.DisplayMembers(toFoxCode, loData)
		
		* If we were triggered by a "(" (to start a method parameter list) and the
		* method accepts enumerated values specified in the LIST memo, display them.
		
						case lcTrigger = '(' and not empty(loData.List)
							This.DisplayEnumeratedValues(toFoxCode, loData)
		
		* If we were triggered by a "(" (to start a method parameter list), an "="
		* (for a property), or "," (to enter a new parameter) and we have a script,
		* execute it.
		
						case inlist(lcTrigger, '=', '(', ',') and ;
							not empty(loData.Script)
							lcReturn = execscript(loData.Script, toFoxCode, loData)
		
		* If we were triggered by a "(" (to start a method parameter list) or "," (to
		* enter a new parameter), display the parameters for the method.
		
						case inlist(lcTrigger, '(', ',') and not empty(loData.Tip)
							.ValueTip  = loData.Tip
							.ValueType = 'T'
					endcase
			endcase
		endwith
		return lcReturn
		
	ENDPROC

	PROTECTED PROCEDURE openintellisense		&& Opens the IntelliSense table
		local lcDir, ;
			lcTable, ;
			llReturn
		if used('__FOXCODE')
			llReturn = .T.
		else
			try
				use (_foxcode) again shared alias __FOXCODE in 0
				llReturn = .T.
			catch to loException
				llReturn = .F.
			endtry
		endif used('__FOXCODE')
		return llReturn
		
	ENDPROC

	PROTECTED PROCEDURE openmytable		&& Opens the My table
		local lcDir, ;
			lcTable, ;
			llReturn
		lcDir   = sys(16)
		lcDir   = addbs(justpath(substr(lcDir, at(' ', lcDir, 2) + 1)))
		lcTable = lcDir + 'my.dbf'
		if used('__MY')
			llReturn = .T.
		else
			try
				use (lcTable) again shared alias __MY in 0
				llReturn = .T.
			catch to loException
				llReturn = .F.
			endtry
		endif used('__MY')
		
		* If we successfully opened the table, save the current setting of DELETED and
		* turn it on.
		
		if llReturn
			This.cCurrDeleted = set('Deleted')
			set deleted on
		endif llReturn
		return llReturn
		
	ENDPROC

ENDDEFINE
