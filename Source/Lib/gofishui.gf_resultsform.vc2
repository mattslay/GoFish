*--------------------------------------------------------------------------------------------------------------------------------------------------------
* (ES) AUTOGENERADO - ¡¡ATENCIÓN!! - ¡¡NO PENSADO PARA EJECUTAR!! USAR SOLAMENTE PARA INTEGRAR CAMBIOS Y ALMACENAR CON HERRAMIENTAS SCM!!
* (EN) AUTOGENERATED - ATTENTION!! - NOT INTENDED FOR EXECUTION!! USE ONLY FOR MERGING CHANGES AND STORING WITH SCM TOOLS!!
*--------------------------------------------------------------------------------------------------------------------------------------------------------
*< FOXBIN2PRG: Version="1.19" SourceFile="gofishui.vcx" /> (Solo para binarios VFP 9 / Only for VFP 9 binaries)
*
DEFINE CLASS gf_resultsform AS gf_baseform OF "gofishui.vcx" 
 	*< CLASSDATA: Baseclass="form" Timestamp="" Scale="Pixels" Uniqueid="" />

	*-- OBJECTDATA items order determines ZOrder / El orden de los items OBJECTDATA determina el ZOrder 
	*< OBJECTDATA: ObjPath="lblSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="comboSearchExpressionHistory" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="editSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="comboSearchScopeHistory" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblScope" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerLeft" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerLeft.oTreeView" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerLeft.cntVersion" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerLeft.cntVersion.Gf_versionlabel1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerLeft.cntVersion.cmdVFPX" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerLeft.cntVersion.Gf_versionlabel2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerLeft.cntVersion.Gf_versionlabel3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2.containerWebControl" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2.containerWebControl.comboViewPosition" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2.containerWebControl.lblCodeView" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2.containerWebControl.ButtonContainer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2.containerWebControl.ButtonContainer.lblFilePath" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2.containerWebControl.cmdCompressCodeview" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container2.containerWebControl.cmdMaximizeCodeView" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.cmdGoToObject" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.cmdMenu" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.lblResults" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.GridFiles" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdReplace" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page1.Label1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdCheckAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdClearAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page1.chkPreview" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page1.editReplaceExpression" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page2.editReplaceLine" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page2.lblReplaceLine" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page2.cmdSaveLine" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdBrowse" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdReplace" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdEdit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdCheckAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdClearAll" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.Pageframe.Page3.Text1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.cmdReplaceErrors" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.containerReplaceText.optiongroupReplaceMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.cmdOpenExplorer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.cmdReport" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.cmdSearchErrors" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.chkReplaceMode" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.cmdClassBrowser" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.Container1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.Container1.chkApplyFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.Container1.cmdFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.cmdEdit" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.Command1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.Container2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.Container2.chkCodeOnly" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Container1.Container2.Check1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.Splitter1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="containerRight.splitter3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="splitter2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="comboSearchScope" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ProgressBar" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="comboSearchExpressionHistoryDropDownArrow" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="timerShowAdvancedForm" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgScopeIcon" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.chkSubdirectories" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.chkLimitToProjectFolder" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.cmdSearch" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.cmdAdvanced" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.cmdOptions" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.cmdHistory" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.Container1" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.Container1.chkApplyFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.comboViewPosition" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.lblCodeView" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.Container2" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.Container2.chkApplyFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.Container3" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.Container3.chkApplyFilter" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.lblSearchTime" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.cmdHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.cmdRegexpHelp" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="ButtonContainer.cmdSave" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrEvent" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgProj_Pick" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="lblReplaceHistory" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="imgFolder_Pick" UniqueID="" Timestamp="" />
	*< OBJECTDATA: ObjPath="tmrGrid" UniqueID="" Timestamp="" />

	#INCLUDE "gofish.h"
	*<DefinedPropArrayMethod>
		*m: addclassestotreeview
		*m: addclassestotreeviewsimple
		*m: adjustformforreplacepanel
		*m: applyfilter
		*m: buildsearchhistorycursor
		*m: captureresizingproperties
		*m: check2gblimit
		*m: checkall
		*m: clearall
		*m: cleargfsefilter
		*m: clearsearchresultscursor
		*m: cleartreeview
		*m: combinefilters
		*m: confirmreplace
		*m: deletesearchresults		&& Delete single or all results from history
		*m: delete_history		&& Delete the history "parent" record
		*m: delete_historyhits		&& Delete the history records per hit
		*m: doreplace
		*m: dosearch
		*m: editfile
		*m: editmenufromcurrentrow
		*m: editobjectfromcurrentrow
		*m: expandallnodes
		*m: exporttoexcel
		*m: fillsearchresultscursor
		*m: filtergfse
		*m: fixcolumnheadings
		*m: focusonreplacepageframe
		*m: formatgrid
		*m: formatgridforreplacemode
		*m: formatprocesscolumn
		*m: getcurrentscope		&& Will return the Active Project, Browsed Project, Current Dir, or Browsed Dir depending on current setting of nSearchScope (Values: 1 through 4)
		*m: getcustomcss
		*m: getfilter		&& Read filter settings of the form
		*m: getlastsavedresultsfolder
		*m: get_onodetag		&& Create object for node tag.
		*m: get_replaceid		&& Determine the next ID to create a backup replace folder.
		*m: get_resultorderby		&& Get the Order By clause for the reult cursor
		*m: gridcolumnrightclick
		*m: gridheaderrightclick
		*m: lmaximizecodeview_assign
		*m: loadfiltersettings
		*m: loadreplaceline
		*m: loadsavedresults
		*m: lockwindow
		*m: lreplaceviewmode_assign
		*m: lreplace_history_assign
		*m: mhelpnotes
		*m: navigatetomasterrecord
		*m: ncodewindowposition_assign
		*m: nreplacemode_assign
		*m: populatenewsearch		&& Populate / Add a new search to the Treeview.
		*m: populatenode		&& Populate / Expand a single Node.
		*m: populatetreefromhistory		&& Populate Tree with all previeous searches (per scope filter)
		*m: populatetreeview		&& Fill the Treeview.
		*m: populatetreeviewsimple
		*m: refreshresults		&& Refresh (re-search) a result
		*m: replace
		*m: replaceline
		*m: resizecodepage
		*m: restoredefaultdir
		*m: restorelastsearch
		*m: restoreprevioussearch
		*m: restoresavedsearch
		*m: restoresearchengineoptions
		*m: restoresearchfromhistory
		*m: restoretreeviewonstartup
		*m: runjanitor
		*m: savereplaceresults
		*m: savesearchinfo
		*m: savesearchresults
		*m: save_resultmemo		&& Save the code snippets from memo to file, to stop the memo file to overgrow
		*m: save_search_history		&& Save the GF_Search_History table
		*m: search
		*m: setcaption
		*m: seterror
		*m: setpath
		*m: setproject
		*m: setscope
		*m: setsearchexpression
		*m: set_gridcolour		&& Set the colours for the grid, moved to load options
		*m: set_searchresultsalias_filter		&& Setzte den Filter für THIScSearchResultsAlias
		*m: showadvancedform
		*m: showcodeforcurrentrow
		*m: showerrors
		*m: showfilterform
		*m: showform
		*m: showgofishhelppage
		*m: showgridcolumn
		*m: showhelpform
		*m: showhtml
		*m: showhtmlcodeview
		*m: showoptionsform
		*m: showreplaceerrors
		*m: showreplacepanel
		*m: showsearcherrors
		*m: sortcolumn
		*m: sortcolumnsecondary
		*m: treeview_nodeclick		&& A Node on Treeview is clicked.
		*m: treeview_nodedblclick		&& A Node of the Treeview is DblClicked.
		*m: treeview_nodeexpand		&& A Node of the Treeview is expanded
		*m: treeview_rightclick		&& A Node of the Treeview is RightClicked.
		*m: updateformaftereplace
		*m: updateformaftersearch
		*m: updatesearchenginecursor
		*m: updatesearchscopevariables
		*m: updatetreeview
		*m: validateinputs
		*m: validatereplaceexpression
		*m: viewreport
		*p: cactiveproject
		*p: cbrowseproject
		*p: ccr_storelocal_option		&& Internal storage for local path, just to display and set. Just to store change for second call of options
		*p: ccurrentdir
		*p: ccurrentid
		*p: ccustomcss
		*p: cdonotrenderextensions		&& A list of common file types that cannot be rendered in the code viewer on the GoFish form.
		*p: cfilter
		*p: cfilteroptionsclass
		*p: cfilteroptionsxmlfile
		*p: chtmlcodeviewfilename
		*p: cinitialdefaultdir
		*p: conkeylabeldot
		*p: corderby
		*p: creplaceline
		*p: creplaceudffilename
		*p: cresultsmessage
		*p: csavedsearchresultsfolder		&& This property value is used by the RemoveFolder() function in the GoFishProc.prg file. If changed here, you'll need to update code in that fucntion also.
		*p: csearchoptionsxmlfile
		*p: csearchresultsalias
		*p: csearchresultsmessage
		*p: csortfield
		*p: csortfields
		*p: csortfieldsecondary
		*p: csortfieldtertiary
		*p: csortorder
		*p: csortordersecondary
		*p: csortordertertiary
		*p: ctreeviewfilter
		*p: c_hasfocus
		*p: dlastjanitorrundate
		*p: lapplyfilter
		*p: lautoyield
		*p: lclearapplyfilter
		*p: lcodeonly
		*p: lcodeviewsingleline
		*p: lcommentsonly
		*p: lcr_historyperscope		&& Shows search history  per scope.
		*p: lcr_historytree		&& Tree with History in it. Follows lCR_HistoryPerScope.
		*p: lcr_historytreeauto		&& Fill all searches with data on startup. (slow)
		*p: lcr_local		&& Use local storage place.
		*p: lcr_local_default		&& Local storage will be created on standard place by default.
		*p: lcr_openmode		&& Open like Code Referenves, Active Project or Folder.
		*p: lcr_refreshtree		&& Refresh tree after options closed.
		*p: lcr_searchcomboperscope		&& Show only searches for the recent scape.
		*p: lcr_simpletree		&& Tree without the class nodes. Just search / files.
		*p: lcr_sorttreealpha		&& Sort tree alphanumeric NOT by recent.
		*p: lcr_sorttreebyext		&& Sort Nodes by extension first. Only for Tree without the class nodes.
		*p: lcr_store_restart		&& Internal storage if Goish must be restart for several settings
		*p: ldesktop		&& The setting for Desktop
		*p: lduringforminit
		*p: lgooglechromeframe		&& Indicates if the HTML view should be generated using the Google Chrome frame plug-ing for Internet Explorer. Slower due to file activity, but allows selecting of text from matched row in html view.
		*p: lidecolorsincodeview
		*p: linit
		*p: lmaximizecodeview
		*p: lmovenewcodetotopleft
		*p: loldsearchhistorystructure
		*p: lonlyfirstmatchinstatement
		*p: lotherhistory		&& Sort buttons on Histoey form normal
		*p: lreplaceformvisible
		*p: lreplacepreview
		*p: lreplaceviewmode
		*p: lreplace_history		&& Form shows history of replace, search is not available
		*p: lrestoreprevioussearchresultsonstartup
		*p: lrunjanitordaily
		*p: lsavesearchresults
		*p: lsearchformvisible
		*p: lsearching
		*p: lshowrelativepath
		*p: lsortscopedropdown
		*p: lwarnwholeword
		*p: nbrowserzoom
		*p: ncodewindowposition		&& *** nEnum 1=Below; 2= on Right; 3 = on Left
		*p: ncontainerframecolour		&& Frame colour for several containers, in case red is something you do not see.
		*p: ncss_tr_even_colour		&& CSS für tr:even
		*p: ncss_tr_odd_colour		&& CSS für tr:odd
		*p: ndropdowndisplaycount		&& Controls the numbner of history items shown in the Search Expression and Scope history dropdown boxes.
		*p: ndropdownmaxmru
		*p: nfiledefaultdynamicforecolour		&& Grid, dynamic fore colour file type Default
		*p: nfileprgdynamicforecolour		&& Grid, dynamic fore colour file type PRG
		*p: nfilescxdynamicforecolour		&& Grid, dynamic fore colour file type SCX
		*p: nfilevcxdynamicforecolour		&& Grid, dynamic fore colour file type VCX
		*p: ngridfontsize
		*p: njanitorreplacehistorydays
		*p: njanitorsearchhistorydays
		*p: nmaxsizetorenderhtml		&& If the code from the match is too large, the HTML rendering can be slow. This will skip the html rendering for code blocks larger than this size and just display it as plaint text.
		*p: noriginalsearchscope		&& The original value of nSearchScope on the SearchOptions after reading the xml files. Used to restore value right before saving the settings upon exit (if SearchScope combo is used).
		*p: nprevioussessiontreeviewindex
		*p: nreplaceddynamicbackcolour		&& Grid, dynamic back colour replaced
		*p: nreplacemode
		*p: nreplacerisk
		*p: nrisk1dynamicbackcolour		&& Grid, dynamic back colour replace risk value 1
		*p: nrisk2dynamicbackcolour		&& Grid, dynamic back colour replace risk value 2
		*p: nrisk3dynamicbackcolour		&& Grid, dynamic back colour replace risk value 3
		*p: nriskexceededdynamicbackcolour		&& Grid, dynamic back colour replace risk exceeds setting
		*p: nsearchboxfontsize
		*p: nsplitterposratio
		*p: ntabstospaces
		*p: ntreesearchcolour		&& Tree colour while searching?
		*p: ntreeupdatecolour		&& Tree colour while updateing?
		*p: ntreeviewfontsize
		*p: obrowser
		*p: ofilter
		*p: ogrid
		*p: otree
		*p: owebcontrol
		*a: gafields[1,6]		&& Array to control default behaviour of fields. Instead of setting in grid. See FormatGrid for definition.
	*</DefinedPropArrayMethod>

	*<PropValue>
		AllowOutput = .F.
		BorderStyle = 3
		cactiveproject = 
		Caption = "GoFish 7"
		cbrowseproject = 
		ccurrentdir = 
		ccurrentid = 
		ccustomcss = .NULL.
		cdonotrenderextensions = (' DOC DOCX XLS XLXS PDF CHM ')
		cfilter = 
		cfilteroptionsclass = GF_SearchResultsFilter
		cfilteroptionsxmlfile = GF_Filter_Settings.xml
		chtmlcodeviewfilename = 
		cinitialdefaultdir = 
		conkeylabeldot = 
		corderby = 
		creplaceline = 
		creplaceudffilename = 
		cresultsmessage = 
		csavedsearchresultsfolder = GF_Saved_Search_Results
		csearchoptionsxmlfile = GF_Search_Settings.xml
		csearchresultsalias = csrSummarySearchResults
		csearchresultsmessage = 
		csortfield = 
		csortfields = 
		csortfieldsecondary = 
		csortfieldtertiary = 
		csortorder = 
		csortordersecondary = 
		csortordertertiary = 
		ctreeviewfilter = 
		cuisettingsfile = GF_Results_Form_Settings.xml
		c_hasfocus = .F.
		DataSession = 2
		Desktop = .F.
		dlastjanitorrundate = ({//})
		Dockable = 0
		DoCreate = .T.
		FontName = "Tahoma"
		Height = 613
		KeyPreview = .T.
		lapplyfilter = .F.
		lautoyield = .F.
		lclearapplyfilter = .F.
		lcodeonly = .F.
		lcodeviewsingleline = .T.
		lcommentsonly = .F.
		lcr_local_default = .T.
		ldesktop = .F.
		lduringforminit = .F.
		Left = 0
		lgooglechromeframe = .F.
		lidecolorsincodeview = .T.
		linit = .F.
		lmaximizecodeview = .F.
		lmovenewcodetotopleft = .T.
		loldsearchhistorystructure = .F.
		lonlyfirstmatchinstatement = .F.
		lreplaceformvisible = .F.
		lreplaceviewmode = .F.
		lrestoreprevioussearchresultsonstartup = .F.
		lrunjanitordaily = .F.
		lsavesearchresults = .T.
		lsearchformvisible = .F.
		lsearching = .F.
		lshowrelativepath = .F.
		lsortscopedropdown = .F.
		lwarnwholeword = .F.
		MaxWidth = -1
		MinHeight = 425
		MinWidth = 800
		Name = "gf_resultsform"
		nbrowserzoom = 0.9
		ncodewindowposition = 1
		ncontainerframecolour = (RGB(255,  0,  0))
		ncss_tr_even_colour = (RGB(0xa8,0xfa,0xf4))
		ncss_tr_odd_colour = (RGB(0xD1,0xF1,0xEF))
		ndropdowndisplaycount = 30
		ndropdownmaxmru = 7
		nfiledefaultdynamicforecolour = (RGB(  0,  0,  0))
		nfileprgdynamicforecolour = (RGB(255,  0,  0))
		nfilescxdynamicforecolour = (RGB(  0,  0,128))
		nfilevcxdynamicforecolour = (RGB(  0,128,  0))
		ngridfontsize = 8
		njanitorreplacehistorydays = 10000
		njanitorsearchhistorydays = 10000
		nmaxsizetorenderhtml = 5000000
		noriginalsearchscope = 0
		nprevioussessiontreeviewindex = 0
		nreplaceddynamicbackcolour = (RGB(149,249,147))
		nreplacemode = 0
		nreplacerisk = 1
		nrisk1dynamicbackcolour = (Rgb(0, 176, 80))
		nrisk2dynamicbackcolour = (Rgb(255,255,128))
		nrisk3dynamicbackcolour = (Rgb(255,192,  0))
		nriskexceededdynamicbackcolour = (Rgb(210,210,210))
		nsearchboxfontsize = 9
		nsplitterposratio = 0
		ntabstospaces = 0
		ntreesearchcolour = (RGB(  0,128,  0))
		ntreeupdatecolour = (RGB(128,  0,  0))
		ntreeviewfontsize = 8
		obrowser = .NULL.
		ofilter = 
		ogrid = .NULL.
		otree = .NULL.
		owebcontrol = .NULL.
		ShowTips = .T.
		TabStop = .T.
		Top = 0
		Visible = .T.
		Width = 1000
		WindowType = 0
		_memberdata = <VFPData>
			<memberdata name="osearchengine" display="oSearchEngine"/>
			<memberdata name="csearchresultsalias" display="cSearchResultsAlias"/>
			<memberdata name="csearchoptionsxmlfile" display="cSearchOptionsXMLFile"/>
			<memberdata name="cuisettingsfile" display="cUISettingsFile"/>
			<memberdata name="ogrid" display="oGrid"/>
			<memberdata name="cinitialdefaultdir" display="cInitialDefaultDir"/>
			<memberdata name="chtmlcodeviewfilename" display="cHtmlCodeViewFilename"/>
			<memberdata name="cbrowseproject" display="cBrowseProject"/>
			<memberdata name="ccurrentdir" display="cCurrentDir"/>
			<memberdata name="cactiveproject" display="cActiveProject"/>
			<memberdata name="ccurrentid" display="cCurrentId"/>
			<memberdata name="obrowser" display="oBrowser"/>
			<memberdata name="nbrowserzoom" display="nBrowserZoom"/>
			<memberdata name="lsearchformvisible" display="lSearchFormVisible"/>
			<memberdata name="otree" display="oTree"/>
			<memberdata name="cfilter" display="cFilter"/>
			<memberdata name="csortorder" display="cSortOrder"/>
			<memberdata name="csortfields" display="cSortFields"/>
			<memberdata name="ngridfontsize" display="nGridFontSize"/>
			<memberdata name="navigatetomasterrecord" display="NavigateToMasterRecord"/>
			<memberdata name="lsearching" display="lSearching"/>
			<memberdata name="linit" display="lInit"/>
			<memberdata name="owebcontrol" display="oWebControl"/>
			<memberdata name="csearchresultsmessage" display="cSearchResultsMessage"/>
			<memberdata name="cresultsmessage" display="cResultsMessage"/>
			<memberdata name="lapplyfilter" display="lApplyFilter"/>
			<memberdata name="lreplaceformvisible" display="lReplaceFormVisible"/>
			<memberdata name="lreplaceviewmode" display="lReplaceViewMode"/>
			<memberdata name="lreplacemode_assign" display="lReplaceMode_Assign"/>
			<memberdata name="nreplacerisk" display="nReplaceRisk"/>
			<memberdata name="creplaceline" display="cReplaceLine"/>
			<memberdata name="cdonotrenderextensions" display="cDoNotRenderExtensions"/>
			<memberdata name="noriginalsearchscope" display="nOriginalSearchScope"/>
			<memberdata name="nreplacemode" display="nReplaceMode"/>
			<memberdata name="creplaceudffilename" display="cReplaceUDFFilename"/>
			<memberdata name="nsplitterposratio" display="nSplitterPosRatio"/>
			<memberdata name="osearchoptions" display="oSearchOptions"/>
			<memberdata name="lautoyield" display="lAutoYield"/>
			<memberdata name="ndropdowndisplaycount" display="nDropDownDisplayCount"/>
			<memberdata name="lgooglechromeframe" display="lGoogleChromeFrame"/>
			<memberdata name="nmaxsizetorenderhtml" display="nMaxSizeToRenderHtml"/>
			<memberdata name="ndropdownmaxmru" display="nDropDownMaxMRU"/>
			<memberdata name="lclearapplyfilter" display="lClearApplyFilter"/>
			<memberdata name="lwarnwholeword" display="lWarnWholeWord"/>
			<memberdata name="conkeylabeldot" display="cOnKeyLabelDot"/>
			<memberdata name="csortordersecondary" display="cSortOrderSecondary"/>
			<memberdata name="csortfieldsecondary" display="cSortFieldSecondary"/>
			<memberdata name="csortfieldtertiary" display="cSortFieldTertiary"/>
			<memberdata name="csortordertertiary" display="cSortOrderTertiary"/>
			<memberdata name="csortfield" display="cSortField"/>
			<memberdata name="corderby" display="cOrderBy"/>
			<memberdata name="nprevioussessiontreeviewindex" display="nPreviousSessionTreeviewIndex"/>
			<memberdata name="csavedsearchresultsfolder" display="cSavedSearchResultsFolder"/>
			<memberdata name="lrestoreprevioussearchresultsonstartup" display="lRestorePreviousSearchResultsOnStartup"/>
			<memberdata name="ldesktop" display="lDesktop"/>
			<memberdata name="nfirstload" type="property" display="nFirstLoad" favorites="False"/>
			<memberdata name="gafields" type="property" display="gaFields" favorites="False"/>
			<memberdata name="ccr_storelocal_option" type="property" display="cCR_StoreLocal_Option"/>
			<memberdata name="cfilteroptionsclass" type="property" display="cFilterOptionsClass"/>
			<memberdata name="cfilteroptionsxmlfile" type="property" display="cFilterOptionsXMLFile"/>
			<memberdata name="csaveddbc" type="property" display="cSavedDBC"/>
			<memberdata name="ctreeviewfilter" type="property" display="cTreeViewFilter"/>
			<memberdata name="dlastjanitorrundate" type="property" display="dLastJanitorRunDate"/>
			<memberdata name="lcodeonly" type="property" display="lCodeOnly"/>
			<memberdata name="lcr_allowed" type="property" display="lCR_Allowed"/>
			<memberdata name="lcr_historyperscope" type="property" display="lCR_HistoryPerScope"/>
			<memberdata name="lcr_historytree" type="property" display="lCR_HistoryTree"/>
			<memberdata name="lcr_historytreeauto" type="property" display="lCR_HistoryTreeAuto"/>
			<memberdata name="lcr_local" type="property" display="lCR_Local"/>
			<memberdata name="lcr_local_default" type="property" display="lCR_Local_Default"/>
			<memberdata name="lcr_openmode" type="property" display="lCR_OpenMode"/>
			<memberdata name="lcr_refreshtree" type="property" display="lCR_RefreshTree"/>
			<memberdata name="lcr_searchcomboperscope" type="property" display="lCR_SearchComboPerScope"/>
			<memberdata name="lcr_simpletree" type="property" display="lCR_SimpleTree"/>
			<memberdata name="lcr_sorttreealpha" type="property" display="lCR_SortTreeAlpha"/>
			<memberdata name="lcr_sorttreebyext" type="property" display="lCR_SortTreeByExt"/>
			<memberdata name="lcr_store_restart" type="property" display="lCR_Store_Restart"/>
			<memberdata name="lmaximizecodeview" type="property" display="lMaximizeCodeView"/>
			<memberdata name="lmovenewcodetotopleft" type="property" display="lMoveNewCodeToTopLeft"/>
			<memberdata name="lreplacepreview" type="property" display="lReplacePreview"/>
			<memberdata name="lrunjanitordaily" type="property" display="lRunJanitorDaily"/>
			<memberdata name="lsavesearchresults" type="property" display="lSaveSearchResults"/>
			<memberdata name="lonlyfirstmatchinstatement" type="property" display="lOnlyFirstMatchInStatement"/>
			<memberdata name="lotherhistory" type="property" display="lOtherHistory"/>
			<memberdata name="ncodewindowposition" type="property" display="nCodeWindowPosition"/>
			<memberdata name="ncontainerframecolour" type="property" display="nContainerFrameColour"/>
			<memberdata name="ncss_tr_even_colour" type="property" display="nCSS_Tr_Even_Colour"/>
			<memberdata name="ncss_tr_odd_colour" type="property" display="nCSS_Tr_Odd_Colour"/>
			<memberdata name="nfiledefaultdynamicforecolour" type="property" display="nFileDefaultDynamicForeColour"/>
			<memberdata name="nfileprgdynamicforecolour" type="property" display="nFilePrgDynamicForeColour"/>
			<memberdata name="nfilescxdynamicforecolour" type="property" display="nFileScxDynamicForeColour"/>
			<memberdata name="nfilevcxdynamicforecolour" type="property" display="nFileVcxDynamicForeColour"/>
			<memberdata name="njanitorreplacehistorydays" type="property" display="nJanitorReplaceHistoryDays"/>
			<memberdata name="njanitorsearchhistorydays" type="property" display="nJanitorSearchHistoryDays"/>
			<memberdata name="nreplaceddynamicbackcolour" type="property" display="nReplacedDynamicBackColour"/>
			<memberdata name="nrisk1dynamicbackcolour" type="property" display="nRisk1DynamicBackColour"/>
			<memberdata name="nrisk2dynamicbackcolour" type="property" display="nRisk2DynamicBackColour"/>
			<memberdata name="nrisk3dynamicbackcolour" type="property" display="nRisk3DynamicBackColour"/>
			<memberdata name="nriskexceededdynamicbackcolour" type="property" display="nRiskExceededDynamicBackColour"/>
			<memberdata name="nsearchboxfontsize" type="property" display="nSearchBoxFontsize"/>
			<memberdata name="ntabstospaces" type="property" display="nTabsToSpaces"/>
			<memberdata name="ntreesearchcolour" type="property" display="nTreeSearchColour"/>
			<memberdata name="ntreeupdatecolour" type="property" display="nTreeUpdateColour"/>
			<memberdata name="ntreeviewfontsize" type="property" display="nTreeViewFontSize"/>
			<memberdata name="ofilter" type="property" display="oFilter"/>
			<memberdata name="lreplace_history" type="property" display="lReplace_History" favorites="False"/>
			<memberdata name="lcommentsonly" display="lCommentsOnly"/>
			<memberdata name="ccustomcss" display="cCustomCss"/>
			<memberdata name="captureresizingproperties" display="CaptureResizingProperties"/>
			<memberdata name="lduringforminit" display="lDuringFormInit"/>
			<memberdata name="lshowrelativepath" display="lShowRelativePath"/>
		</VFPData>
	*</PropValue>

	ADD OBJECT 'ButtonContainer' AS container WITH ;
		Anchor = 8, ;
		BackStyle = 0, ;
		BorderWidth = 0, ;
		Height = 58, ;
		Left = 470, ;
		Name = "ButtonContainer", ;
		Picture = ..\images\, ;
		TabIndex = 7, ;
		Top = -2, ;
		Width = 528
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'ButtonContainer.chkLimitToProjectFolder' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Limit to home...", ;
		ControlSource = "thisform.oSearchOptions.lLimitToProjectFolder", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 8, ;
		Name = "chkLimitToProjectFolder", ;
		Picture = ..\images\, ;
		TabIndex = 12, ;
		ToolTipText = "Limit search to project home directory and sub-folders", ;
		Top = 37, ;
		Width = 89
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'ButtonContainer.chkSubdirectories' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Subdirectories", ;
		ControlSource = "Thisform.oSearchOptions.lIncludeSubDirectories", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 8, ;
		Name = "chkSubdirectories", ;
		Picture = ..\images\, ;
		TabIndex = 11, ;
		ToolTipText = "Include subdirectories in search", ;
		Top = 37, ;
		Width = 88
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'ButtonContainer.cmdAdvanced' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = "\<Advanced", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 278, ;
		Name = "cmdAdvanced", ;
		Picture = ('images\find.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 5, ;
		ToolTipText = "See context menu", ;
		Top = 7, ;
		Width = 76
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'ButtonContainer.cmdHelp' AS commandbutton WITH ;
		Anchor = 9, ;
		Caption = "", ;
		Height = 22, ;
		Left = 439, ;
		Name = "cmdHelp", ;
		Picture = ('images\refhelp.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 16, ;
		Top = 7, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'ButtonContainer.cmdHistory' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = " \<History", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 362, ;
		Name = "cmdHistory", ;
		Picture = ('images\openfold.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 9, ;
		ToolTipText = "See context menu", ;
		Top = 34, ;
		Width = 65
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'ButtonContainer.cmdOptions' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = "\<Options", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 364, ;
		Name = "cmdOptions", ;
		Picture = ('images\properties.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 9, ;
		ToolTipText = "", ;
		Top = 7, ;
		Width = 62
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'ButtonContainer.cmdRegexpHelp' AS commandbutton WITH ;
		Caption = "", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 250, ;
		Name = "cmdRegexpHelp", ;
		Picture = ('images\GrammarIconRegex.gif'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 5, ;
		ToolTipText = "Help for forming regular expressions", ;
		Top = 7, ;
		Width = 22
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'ButtonContainer.cmdSave' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = " Save", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 417, ;
		Name = "cmdSave", ;
		Picture = ('save.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 9, ;
		ToolTipText = "See context menu", ;
		Top = 42, ;
		Visible = .F., ;
		Width = 65
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'ButtonContainer.cmdSearch' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = " \<Go Fish", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 8, ;
		Name = "cmdSearch", ;
		Picture = ('images\GoFish16.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 4, ;
		Top = 7, ;
		Width = 68
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'ButtonContainer.comboViewPosition' AS combobox WITH ;
		ControlSource = "Thisform.oSearchOptions.nSearchMode", ;
		FontSize = 8, ;
		Height = 24, ;
		Left = 118, ;
		Name = "comboViewPosition", ;
		Style = 2, ;
		TabIndex = 24, ;
		TabStop = .F., ;
		ToolTipText = "", ;
		Top = 6, ;
		Width = 128, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'ButtonContainer.Container1' AS container WITH ;
		BackStyle = 0, ;
		BorderColor = 255,0,0, ;
		BorderWidth = 2, ;
		Height = 25, ;
		Left = 99, ;
		Name = "Container1", ;
		Picture = ..\images\, ;
		Top = 33, ;
		Width = 83
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'ButtonContainer.Container1.chkApplyFilter' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		AutoSize = .T., ;
		Caption = "\<Whole word", ;
		ControlSource = "thisform.oSearchEngine.oSearchOptions.lMatchWholeWord", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 3, ;
		Name = "chkApplyFilter", ;
		Picture = ..\images\, ;
		TabIndex = 7, ;
		Top = 4, ;
		Width = 77
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'ButtonContainer.Container2' AS container WITH ;
		BackStyle = 0, ;
		BorderColor = 255,0,0, ;
		BorderWidth = 2, ;
		Height = 25, ;
		Left = 190, ;
		Name = "Container2", ;
		Picture = ..\images\, ;
		Top = 33, ;
		Width = 81
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'ButtonContainer.Container2.chkApplyFilter' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		AutoSize = .T., ;
		Caption = "Match \<Case", ;
		ControlSource = "Thisform.oSearchEngine.oSearchOptions.lMatchCase", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 3, ;
		Name = "chkApplyFilter", ;
		Picture = ..\images\, ;
		TabIndex = 7, ;
		Top = 4, ;
		Width = 75
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'ButtonContainer.Container3' AS container WITH ;
		BackStyle = 0, ;
		BorderColor = 255,0,0, ;
		BorderWidth = 2, ;
		Height = 25, ;
		Left = 279, ;
		Name = "Container3", ;
		Picture = ..\images\, ;
		Top = 33, ;
		Width = 75
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'ButtonContainer.Container3.chkApplyFilter' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		AutoSize = .T., ;
		Caption = "Co\<mments", ;
		ControlSource = "Thisform.oSearchEngine.oSearchOptions.lSearchInComments", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 3, ;
		Name = "chkApplyFilter", ;
		Picture = ..\images\, ;
		TabIndex = 7, ;
		Top = 4, ;
		Width = 68
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'ButtonContainer.lblCodeView' AS label WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Mode:", ;
		FontBold = .F., ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Height = 16, ;
		Left = 84, ;
		Name = "lblCodeView", ;
		TabIndex = 7, ;
		Top = 11, ;
		Width = 31, ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ButtonContainer.lblSearchTime' AS label WITH ;
		Alignment = 1, ;
		Anchor = 8, ;
		BackStyle = 0, ;
		Caption = "9999 lines in 9999 files in 999.9 seconds", ;
		FontSize = 8, ;
		ForeColor = 128,128,128, ;
		Height = 46, ;
		Left = 436, ;
		Name = "lblSearchTime", ;
		TabIndex = 21, ;
		Top = 12, ;
		Width = 83, ;
		WordWrap = .T.
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'comboSearchExpressionHistory' AS gf_combosearchexpressionhistory WITH ;
		Anchor = 10, ;
		Height = 26, ;
		Left = 47, ;
		Name = "comboSearchExpressionHistory", ;
		nexpressionstostore = 50, ;
		TabIndex = 9, ;
		TabStop = .F., ;
		Top = 3, ;
		Width = 420
		*< END OBJECT: ClassLib="gofishui.vcx" BaseClass="combobox" />

	ADD OBJECT 'comboSearchExpressionHistoryDropDownArrow' AS combobox WITH ;
		Anchor = 8, ;
		BorderColor = 255,255,255, ;
		BorderStyle = 0, ;
		Height = 26, ;
		Left = 446, ;
		Name = "comboSearchExpressionHistoryDropDownArrow", ;
		TabIndex = 3, ;
		TabStop = .F., ;
		Top = 14, ;
		Width = 17
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'comboSearchScope' AS combobox WITH ;
		ControlSource = "Thisform.oSearchOptions.nSearchScope", ;
		FontSize = 8, ;
		Height = 25, ;
		Left = 47, ;
		Name = "comboSearchScope", ;
		Style = 2, ;
		TabIndex = 24, ;
		TabStop = .F., ;
		ToolTipText = "", ;
		Top = 31, ;
		Width = 110, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'comboSearchScopeHistory' AS gf_combosearchscope WITH ;
		Anchor = 10, ;
		BoundTo = .T., ;
		ControlSource = "Thisform.oSearchEngine.oSearchOptions.cRecentScope", ;
		Height = 25, ;
		Left = 185, ;
		Name = "comboSearchScopeHistory", ;
		nexpressionstostore = 40, ;
		SelectOnEntry = .T., ;
		TabIndex = 5, ;
		Top = 31, ;
		Width = 239
		*< END OBJECT: ClassLib="gofishui.vcx" BaseClass="combobox" />

	ADD OBJECT 'containerLeft' AS container WITH ;
		Anchor = 5, ;
		BackColor = 255,255,255, ;
		Height = 555, ;
		Left = 2, ;
		Name = "containerLeft", ;
		Picture = ..\images\, ;
		TabIndex = 8, ;
		Top = 59, ;
		Width = 187
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerLeft.cntVersion' AS container WITH ;
		Anchor = 14, ;
		BorderWidth = 0, ;
		Height = 43, ;
		Left = -2, ;
		Name = "cntVersion", ;
		Picture = ..\images\, ;
		Top = 513, ;
		Width = 186
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerLeft.cntVersion.cmdVFPX' AS commandbutton WITH ;
		Anchor = 8, ;
		Caption = "", ;
		Height = 22, ;
		Left = 92, ;
		Name = "cmdVFPX", ;
		Picture = ..\..\..\gofishclassic\installedfiles\images\vfpxpoweredby_alternative.gif, ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 16, ;
		ToolTipText = "Go to VFPX home page", ;
		Top = 2, ;
		Width = 93
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerLeft.cntVersion.Gf_versionlabel1' AS gf_versionlabel WITH ;
		Alignment = 0, ;
		Anchor = 4, ;
		Caption = "Version", ;
		FontName = "Arial", ;
		Height = 13, ;
		Left = 8, ;
		Name = "Gf_versionlabel1", ;
		TabIndex = 13, ;
		Top = 6, ;
		Width = 178
		*< END OBJECT: ClassLib="..\..\..\gofishclassic\installedfiles\lib\gofishui.vcx" BaseClass="label" />

	ADD OBJECT 'containerLeft.cntVersion.Gf_versionlabel2' AS gf_versionlabel WITH ;
		Alignment = 0, ;
		Anchor = 0, ;
		AutoSize = .T., ;
		Caption = "Report Issues", ;
		FontItalic = .T., ;
		FontName = "Arial", ;
		FontUnderline = .T., ;
		ForeColor = 0,0,255, ;
		Height = 16, ;
		Left = 8, ;
		Name = "Gf_versionlabel2", ;
		TabIndex = 13, ;
		ToolTipText = "Links to the issues page in GitHub for GoFish", ;
		Top = 23, ;
		Width = 71
		*< END OBJECT: ClassLib="..\..\..\gofishclassic\installedfiles\lib\gofishui.vcx" BaseClass="label" />

	ADD OBJECT 'containerLeft.cntVersion.Gf_versionlabel3' AS gf_versionlabel WITH ;
		Alignment = 0, ;
		Anchor = 0, ;
		AutoSize = .T., ;
		Caption = "What's New", ;
		FontItalic = .T., ;
		FontName = "Arial", ;
		FontUnderline = .T., ;
		ForeColor = 0,0,255, ;
		Height = 16, ;
		Left = 95, ;
		Name = "Gf_versionlabel3", ;
		TabIndex = 13, ;
		ToolTipText = "Links to the Change Log page in GitHub for GoFish", ;
		Top = 23, ;
		Width = 60
		*< END OBJECT: ClassLib="..\..\..\gofishclassic\installedfiles\lib\gofishui.vcx" BaseClass="label" />

	ADD OBJECT 'containerLeft.oTreeView' AS olecontrol WITH ;
		Anchor = 15, ;
		Height = 513, ;
		Left = 0, ;
		Name = "oTreeView", ;
		Top = 0, ;
		Width = 186
		*< END OBJECT: BaseClass="olecontrol" OLEObject="c:\windows\syswow64\mscomctl.ocx" Value="0M8R4KGxGuEAAAAAAAAAAAAAAAAAAAAAPgADAP7/CQAGAAAAAAAAAAAAAAABAAAAAQAAAAAAAAAAEAAAAgAAAAEAAAD+////AAAAAAAAAAD////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9/////v////7///8EAAAA/v///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////1IAbwBvAHQAIABFAG4AdAByAHkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAWAAUA//////////8BAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAV9CuVbtoBAwAAAEACAAAAAAAAAwBPAGwAZQBPAGIAagBlAGMAdABEAGEAdABhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4AAgEDAAAAAgAAAP////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAagAAAAAAAAADAEEAYwBjAGUAcwBzAE8AYgBqAFMAaQB0AGUARABhAHQAYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJgACAP///////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAABcAAAAAAAAAAMAQwBoAGEAbgBnAGUAZABQAHIAbwBwAHMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcAAIA////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwAAACABAAAAAAAABAAAAAIAAAD+////BQAAAP7///8GAAAABwAAAAgAAAD+//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////+2kEHHiYXREbFqAMDwKDYoIUM0EggAAAA5EwAABTUAALE8wWoBAAYAIgAAABkAAAARAgAACgAAAAEAAAAB782rXAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAACQAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA5MzY4MjY1RS04NUZFLTExZDEtOEJFMy0wMDAwRjg3NTREQTEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAACADgAAAEhpZGVTZWxlY3Rpb24ABQAAAEwAAAAADAAAAEluZGVudGF0aW9uABEAAABODQAAAAcAAAAAAAAAAAAFAADp+QIGAAAAAAAAAAUAAIBw5xkAAQAAAFwAH97svQEABQC45xkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANEAKAAAATGluZVN0eWxlAAkAAABJCgAAAAEAAAANAAAATW91c2VQb2ludGVyAAkAAABJCgAAAAAAAAAOAAAAUGF0aFNlcGFyYXRvcgAKAAAASAAAAAABAAAAXAYAAABTdHlsZQAJAAAASQoAAAAGAAAADAAAAE9MRURyYWdNb2RlAAkAAABJCgAAAAAAAAAMAAAAT0xFRHJvcE1vZGUACQAAAEkKAAAAAAAAAA4AAABGdWxsUm93U2VsZWN0AAUAAABMAQAAAAoAAABTaW5nbGVTZWwABQAAAEwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA" />

	ADD OBJECT 'containerRight' AS container WITH ;
		Anchor = 15, ;
		Height = 555, ;
		Left = 199, ;
		Name = "containerRight", ;
		Picture = ..\images\, ;
		TabIndex = 10, ;
		Top = 57, ;
		Width = 800
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerRight.Container1' AS container WITH ;
		Anchor = 10, ;
		Height = 357, ;
		Left = 0, ;
		Name = "Container1", ;
		Picture = ..\images\, ;
		TabIndex = 5, ;
		Top = 0, ;
		Width = 800
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerRight.Container1.chkReplaceMode' AS checkbox WITH ;
		Alignment = 0, ;
		Caption = " \<Replace View", ;
		ControlSource = "Thisform.lReplaceViewMode", ;
		DownPicture = ..\images\gf_uparrow.bmp, ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 156, ;
		Name = "chkReplaceMode", ;
		Picture = ..\images\gf_dnarrow.bmp, ;
		PicturePosition = 0, ;
		Style = 1, ;
		TabIndex = 7, ;
		Top = 4, ;
		Value = 0, ;
		Width = 105
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'containerRight.Container1.cmdClassBrowser' AS commandbutton WITH ;
		Caption = "", ;
		Height = 20, ;
		Left = 90, ;
		Name = "cmdClassBrowser", ;
		Picture = ..\images\class.bmp, ;
		SpecialEffect = 2, ;
		ToolTipText = "Open Class Browser", ;
		Top = 5, ;
		Width = 22, ;
		ZOrderSet = 10
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.cmdEdit' AS commandbutton WITH ;
		Caption = "", ;
		Height = 19, ;
		Left = 34, ;
		Name = "cmdEdit", ;
		Picture = ..\images\method.bmp, ;
		SpecialEffect = 2, ;
		ToolTipText = "Edit (same as double-clicking the row in the grid)", ;
		Top = 5, ;
		Width = 22, ;
		ZOrderSet = 11
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.cmdGoToObject' AS commandbutton WITH ;
		Caption = "", ;
		Height = 20, ;
		Left = 62, ;
		Name = "cmdGoToObject", ;
		Picture = ..\images\obfind.bmp, ;
		SpecialEffect = 2, ;
		ToolTipText = "Modify this form or class and then select this object, if possible.", ;
		Top = 5, ;
		Width = 22, ;
		ZOrderSet = 0
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.cmdMenu' AS commandbutton WITH ;
		Caption = "", ;
		Height = 20, ;
		Left = 90, ;
		Name = "cmdMenu", ;
		Picture = ..\images\menu.bmp, ;
		SpecialEffect = 2, ;
		ToolTipText = "Display an outline of this menu, highlighting the prompt that matches the current line in the grid.", ;
		Top = 5, ;
		Width = 22, ;
		ZOrderSet = 1
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.cmdOpenExplorer' AS commandbutton WITH ;
		Caption = "", ;
		Height = 20, ;
		Left = 118, ;
		Name = "cmdOpenExplorer", ;
		Picture = ..\images\browsefolder.bmp, ;
		SpecialEffect = 2, ;
		ToolTipText = "Open Explorer window to this path.", ;
		Top = 5, ;
		Width = 22, ;
		ZOrderSet = 5
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.cmdReport' AS commandbutton WITH ;
		Caption = "E\<xport", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 640, ;
		Name = "cmdReport", ;
		Picture = ('images\doc.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 8, ;
		ToolTipText = "Export to DBF, XLSX, a cursor, or your browser", ;
		Top = 4, ;
		Width = 58
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.cmdSearchErrors' AS commandbutton WITH ;
		Caption = "!", ;
		FontBold = .T., ;
		FontSize = 12, ;
		Height = 22, ;
		Left = 2, ;
		Name = "cmdSearchErrors", ;
		Picture = ..\images\yellow_exclamation_16.bmp, ;
		PicturePosition = 14, ;
		SpecialEffect = 2, ;
		ToolTipText = "Show search errors", ;
		Top = 4, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.Command1' AS commandbutton WITH ;
		Caption = "", ;
		Height = 22, ;
		Left = 271, ;
		Name = "Command1", ;
		Picture = ('images\refhelp.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 16, ;
		ToolTipText = "How Replace works", ;
		Top = 5, ;
		Width = 24
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.Container1' AS container WITH ;
		BackStyle = 0, ;
		BorderColor = 255,0,0, ;
		BorderWidth = 2, ;
		Height = 27, ;
		Left = 304, ;
		Name = "Container1", ;
		Picture = ..\images\, ;
		Top = 1, ;
		Width = 129
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerRight.Container1.Container1.chkApplyFilter' AS checkbox WITH ;
		Alignment = 0, ;
		Anchor = 8, ;
		Caption = "Apply", ;
		ControlSource = "Thisform.lApplyFilter", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 74, ;
		Name = "chkApplyFilter", ;
		Picture = ..\images\, ;
		TabIndex = 7, ;
		Top = 4, ;
		Width = 48
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'containerRight.Container1.Container1.cmdFilter' AS commandbutton WITH ;
		Caption = "\<Filter", ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 7, ;
		Name = "cmdFilter", ;
		Picture = ('images\filter.bmp'), ;
		PicturePosition = 1, ;
		SpecialEffect = 2, ;
		TabIndex = 6, ;
		Top = 4, ;
		Width = 53
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.Container2' AS container WITH ;
		BackStyle = 0, ;
		BorderColor = 255,0,0, ;
		BorderWidth = 2, ;
		Height = 27, ;
		Left = 445, ;
		Name = "Container2", ;
		Top = 1, ;
		Width = 186
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerRight.Container1.Container2.Check1' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Comments Only", ;
		ControlSource = "Thisform.lcommentsonly", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 87, ;
		Name = "Check1", ;
		TabIndex = 7, ;
		Top = 5, ;
		Width = 93
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'containerRight.Container1.Container2.chkCodeOnly' AS checkbox WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		Caption = "Code Only", ;
		ControlSource = "Thisform.lcodeonly", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Arial", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 7, ;
		Name = "chkCodeOnly", ;
		TabIndex = 7, ;
		Top = 5, ;
		Width = 68
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText' AS container WITH ;
		Anchor = 10, ;
		BackColor = 149,249,147, ;
		BorderWidth = 1, ;
		Height = 84, ;
		Left = 0, ;
		Name = "containerReplaceText", ;
		Picture = ..\images\, ;
		Top = 28, ;
		Width = 800
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.cmdReplaceErrors' AS commandbutton WITH ;
		Caption = "!", ;
		FontBold = .T., ;
		FontSize = 12, ;
		Height = 28, ;
		Left = 540, ;
		Name = "cmdReplaceErrors", ;
		Picture = ..\images\errors.bmp, ;
		PicturePosition = 14, ;
		SpecialEffect = 2, ;
		ToolTipText = "Show search errors", ;
		Top = 1, ;
		Width = 88
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.optiongroupReplaceMode' AS optiongroup WITH ;
		BackStyle = 0, ;
		BorderStyle = 0, ;
		ButtonCount = 5, ;
		ControlSource = "Thisform.nReplaceMode", ;
		Height = 26, ;
		Left = 6, ;
		Name = "optiongroupReplaceMode", ;
		Top = 1, ;
		Value = 2, ;
		Width = 501, ;
		Option1.BackStyle = 0, ;
		Option1.Caption = "Off", ;
		Option1.FontSize = 8, ;
		Option1.Height = 16, ;
		Option1.Left = 5, ;
		Option1.Name = "Option1", ;
		Option1.TabIndex = 1, ;
		Option1.Top = 5, ;
		Option1.Width = 34, ;
		Option2.BackStyle = 0, ;
		Option2.Caption = "Replace \<Text", ;
		Option2.FontSize = 8, ;
		Option2.Height = 16, ;
		Option2.Left = 54, ;
		Option2.Name = "Option2", ;
		Option2.TabIndex = 2, ;
		Option2.Top = 5, ;
		Option2.Value = 1, ;
		Option2.Width = 81, ;
		Option3.BackStyle = 0, ;
		Option3.Caption = "Replace L\<ine", ;
		Option3.FontSize = 8, ;
		Option3.Height = 16, ;
		Option3.Left = 149, ;
		Option3.Name = "Option3", ;
		Option3.TabIndex = 3, ;
		Option3.Top = 5, ;
		Option3.Width = 80, ;
		Option4.BackStyle = 0, ;
		Option4.Caption = "Ad\<vanced Replace", ;
		Option4.FontSize = 8, ;
		Option4.Height = 16, ;
		Option4.Left = 244, ;
		Option4.Name = "Option4", ;
		Option4.TabIndex = 4, ;
		Option4.Top = 5, ;
		Option4.Width = 120, ;
		Option5.BackStyle = 0, ;
		Option5.Caption = "View Replace History", ;
		Option5.FontSize = 8, ;
		Option5.Height = 16, ;
		Option5.Left = 369, ;
		Option5.Name = "Option5", ;
		Option5.TabIndex = 5, ;
		Option5.Top = 5, ;
		Option5.Width = 134
		*< END OBJECT: BaseClass="optiongroup" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe' AS pageframe WITH ;
		Anchor = 10, ;
		ErasePage = .T., ;
		Height = 55, ;
		Left = 0, ;
		Name = "Pageframe", ;
		PageCount = 3, ;
		Tabs = .F., ;
		TabStyle = 1, ;
		Themes = .F., ;
		Top = 25, ;
		Width = 800, ;
		Page1.BackStyle = 0, ;
		Page1.Caption = "Replace Text", ;
		Page1.Name = "Page1", ;
		Page1.Picture = ..\images\, ;
		Page2.BackStyle = 0, ;
		Page2.Caption = "Edit Line", ;
		Page2.Name = "Page2", ;
		Page2.Picture = ..\images\, ;
		Page3.BackStyle = 0, ;
		Page3.Caption = "Advanced Search", ;
		Page3.Name = "Page3", ;
		Page3.Picture = ..\images\
		*< END OBJECT: BaseClass="pageframe" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page1.chkPreview' AS checkbox WITH ;
		Alignment = 0, ;
		BackStyle = 0, ;
		Caption = "Preview", ;
		ControlSource = "Thisform.lReplacePreview", ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 335, ;
		Name = "chkPreview", ;
		Picture = ..\images\, ;
		TabIndex = 6, ;
		Top = 28, ;
		Value = .F., ;
		Width = 80
		*< END OBJECT: BaseClass="checkbox" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdCheckAll' AS commandbutton WITH ;
		Caption = "Check All", ;
		Enabled = .T., ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 4, ;
		Name = "cmdCheckAll", ;
		Picture = ..\images\, ;
		TabIndex = 3, ;
		Top = 28, ;
		Visible = .T., ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdClearAll' AS commandbutton WITH ;
		Caption = "Clear All", ;
		Enabled = .T., ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 68, ;
		Name = "cmdClearAll", ;
		Picture = ..\images\, ;
		TabIndex = 4, ;
		Top = 28, ;
		Visible = .T., ;
		Width = 51
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdReplace' AS commandbutton WITH ;
		Anchor = 0, ;
		Caption = "Replace checked", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 205, ;
		Name = "cmdReplace", ;
		Picture = ('images\GoFish16.bmp'), ;
		PicturePosition = 1, ;
		TabIndex = 5, ;
		Top = 28, ;
		Width = 113
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page1.editReplaceExpression' AS editbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.oSearchEngine.oSearchOptions.cReplaceExpression", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Courier New", ;
		FontSize = 9, ;
		Height = 23, ;
		Left = 205, ;
		Name = "editReplaceExpression", ;
		TabIndex = 2, ;
		Top = 3, ;
		Width = 590, ;
		ZOrderSet = 5
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page1.Label1' AS label WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Replacement Text", ;
		FontBold = .F., ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Height = 16, ;
		Left = 111, ;
		Name = "Label1", ;
		TabIndex = 1, ;
		Top = 7, ;
		Width = 88, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page2.cmdSaveLine' AS commandbutton WITH ;
		Anchor = 0, ;
		Caption = "Replace line", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 205, ;
		Name = "cmdSaveLine", ;
		Picture = ('images\GoFish16.bmp'), ;
		PicturePosition = 1, ;
		Top = 28, ;
		Width = 113
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page2.editReplaceLine' AS editbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.cReplaceLine", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Courier New", ;
		FontSize = 9, ;
		Height = 23, ;
		Left = 205, ;
		Name = "editReplaceLine", ;
		TabIndex = 2, ;
		Top = 3, ;
		Width = 590, ;
		ZOrderSet = 5
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page2.lblReplaceLine' AS label WITH ;
		Alignment = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Edit Current Line", ;
		FontBold = .F., ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Height = 16, ;
		Left = 116, ;
		Name = "lblReplaceLine", ;
		TabIndex = 7, ;
		Top = 8, ;
		Width = 81, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdBrowse' AS commandbutton WITH ;
		Anchor = 0, ;
		Caption = "Select UDF", ;
		FontBold = .F., ;
		FontSize = 8, ;
		Height = 20, ;
		Left = 80, ;
		Name = "cmdBrowse", ;
		Picture = ..\images\, ;
		Top = 4, ;
		Width = 65
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdCheckAll' AS commandbutton WITH ;
		Caption = "Check All", ;
		Enabled = .T., ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 4, ;
		Name = "cmdCheckAll", ;
		Picture = ..\images\, ;
		Top = 28, ;
		Visible = .T., ;
		Width = 55
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdClearAll' AS commandbutton WITH ;
		Caption = "Clear All", ;
		Enabled = .T., ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 68, ;
		Name = "cmdClearAll", ;
		Picture = ..\images\, ;
		Top = 28, ;
		Visible = .T., ;
		Width = 51
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdEdit' AS commandbutton WITH ;
		Caption = "Edit UDF", ;
		FontSize = 8, ;
		Height = 19, ;
		Left = 147, ;
		Name = "cmdEdit", ;
		Picture = ..\images\, ;
		Top = 4, ;
		Width = 54
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdReplace' AS commandbutton WITH ;
		Anchor = 0, ;
		Caption = "Replace checked", ;
		FontSize = 8, ;
		Height = 22, ;
		Left = 205, ;
		Name = "cmdReplace", ;
		Picture = ('images\GoFish16.bmp'), ;
		PicturePosition = 1, ;
		TabIndex = 3, ;
		Top = 28, ;
		Width = 113
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container1.containerReplaceText.Pageframe.Page3.Text1' AS textbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.cReplaceUDFFilename", ;
		Enabled = .F., ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontName = "Courier New", ;
		FontSize = 9, ;
		Height = 23, ;
		Left = 205, ;
		Name = "Text1", ;
		Top = 2, ;
		Width = 590
		*< END OBJECT: BaseClass="textbox" />

	ADD OBJECT 'containerRight.Container1.GridFiles' AS gf_grid WITH ;
		Anchor = 15, ;
		DeleteMark = .F., ;
		DragMode = 0, ;
		FontName = "Arial", ;
		FontSize = 8, ;
		GridLineColor = 192,192,192, ;
		Height = 276, ;
		HighlightForeColor = 0,0,0, ;
		HighlightStyle = 2, ;
		Left = 1, ;
		Name = "GridFiles", ;
		Panel = 1, ;
		RecordMark = .F., ;
		RowHeight = 17, ;
		TabIndex = 36, ;
		Tag = "", ;
		Top = 112, ;
		Width = 798
		*< END OBJECT: ClassLib="gofishui.vcx" BaseClass="grid" />

	ADD OBJECT 'containerRight.Container1.lblResults' AS label WITH ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "0 Instances found", ;
		FontSize = 8, ;
		ForeColor = 128,128,128, ;
		Height = 16, ;
		Left = 705, ;
		Name = "lblResults", ;
		TabIndex = 24, ;
		Top = 8, ;
		Width = 89
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'containerRight.Container2' AS container WITH ;
		Anchor = 15, ;
		Height = 185, ;
		Left = 1, ;
		Name = "Container2", ;
		Picture = ..\images\, ;
		TabIndex = 6, ;
		Top = 367, ;
		Width = 798
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerRight.Container2.containerWebControl' AS gf_webcontrol WITH ;
		Anchor = 15, ;
		BorderWidth = 0, ;
		Height = 186, ;
		Name = "containerWebControl", ;
		Picture = ..\images\, ;
		Top = 1, ;
		Width = 799, ;
		obrowser.Height = 183, ;
		obrowser.Left = 1, ;
		obrowser.Name = "obrowser", ;
		obrowser.Top = 23, ;
		obrowser.Width = 794, ;
		obrowser.ZOrderSet = 2, ;
		cmdZoomIn.Anchor = 0, ;
		cmdZoomIn.Caption = "", ;
		cmdZoomIn.Left = 196, ;
		cmdZoomIn.Name = "cmdZoomIn", ;
		cmdZoomIn.Picture = ..\images\gf_large_letter.bmp, ;
		cmdZoomIn.SpecialEffect = 2, ;
		cmdZoomIn.ToolTipText = "Zoom in on HTML Code View", ;
		cmdZoomIn.Top = 1, ;
		cmdZoomIn.ZOrderSet = 3, ;
		cmdZoomOut.Anchor = 0, ;
		cmdZoomOut.Caption = "", ;
		cmdZoomOut.Left = 224, ;
		cmdZoomOut.Name = "cmdZoomOut", ;
		cmdZoomOut.Picture = ..\images\gf_small_letter.bmp, ;
		cmdZoomOut.SpecialEffect = 2, ;
		cmdZoomOut.ToolTipText = "Zoom out from HTML Code View", ;
		cmdZoomOut.Top = -1, ;
		cmdZoomOut.ZOrderSet = 4
		*< END OBJECT: ClassLib="gofishwebtools.vcx" BaseClass="container" />

	ADD OBJECT 'containerRight.Container2.containerWebControl.ButtonContainer' AS container WITH ;
		Anchor = 10, ;
		BackStyle = 0, ;
		BorderWidth = 0, ;
		Height = 23, ;
		Left = 316, ;
		Name = "ButtonContainer", ;
		Picture = ..\images\, ;
		Top = 0, ;
		Width = 478
		*< END OBJECT: BaseClass="container" />

	ADD OBJECT 'containerRight.Container2.containerWebControl.ButtonContainer.lblFilePath' AS label WITH ;
		Anchor = 11, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Filename and path here...", ;
		FontSize = 8, ;
		Height = 16, ;
		Left = 5, ;
		Name = "lblFilePath", ;
		TabIndex = 24, ;
		Top = 4, ;
		Width = 123, ;
		ZOrderSet = 7
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'containerRight.Container2.containerWebControl.cmdCompressCodeview' AS commandbutton WITH ;
		Anchor = 0, ;
		Caption = "", ;
		Height = 20, ;
		Left = 280, ;
		Name = "cmdCompressCodeview", ;
		Picture = ..\images\gf_dnarrow.bmp, ;
		SpecialEffect = 2, ;
		Top = 1, ;
		Width = 24, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container2.containerWebControl.cmdMaximizeCodeView' AS commandbutton WITH ;
		Anchor = 0, ;
		Caption = "", ;
		Height = 20, ;
		Left = 252, ;
		Name = "cmdMaximizeCodeView", ;
		Picture = ..\images\zoom-in-2-16.bmp, ;
		SpecialEffect = 2, ;
		Top = 1, ;
		Width = 24, ;
		ZOrderSet = 6
		*< END OBJECT: BaseClass="commandbutton" />

	ADD OBJECT 'containerRight.Container2.containerWebControl.comboViewPosition' AS combobox WITH ;
		Anchor = 0, ;
		ControlSource = "Thisform.nCodeWindowPosition", ;
		FontSize = 8, ;
		Left = 108, ;
		Name = "comboViewPosition", ;
		Style = 2, ;
		TabIndex = 24, ;
		TabStop = .F., ;
		Top = -1, ;
		Width = 80, ;
		ZOrderSet = 8
		*< END OBJECT: BaseClass="combobox" />

	ADD OBJECT 'containerRight.Container2.containerWebControl.lblCodeView' AS label WITH ;
		Alignment = 0, ;
		Anchor = 0, ;
		AutoSize = .T., ;
		BackStyle = 0, ;
		Caption = "Code View Position:", ;
		FontBold = .F., ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Height = 16, ;
		Left = 8, ;
		Name = "lblCodeView", ;
		TabIndex = 7, ;
		Top = 4, ;
		Width = 99, ;
		ZOrderSet = 9
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'containerRight.Splitter1' AS sfsplitterv WITH ;
		Anchor = 10, ;
		BackColor = 210,210,210, ;
		cobject1name = Container1, ;
		cobject2name = Container2, ;
		Height = 10, ;
		Left = 0, ;
		Name = "Splitter1", ;
		nobject2minsize = 25, ;
		Picture = ..\images\, ;
		TabIndex = 14, ;
		Top = 357, ;
		Width = 800, ;
		GRIPPER.GripperDot1.Name = "GripperDot1", ;
		GRIPPER.GripperDot1.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot1.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot1.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot2.Name = "GripperDot2", ;
		GRIPPER.GripperDot2.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot2.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot2.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot3.Name = "GripperDot3", ;
		GRIPPER.GripperDot3.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot3.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot3.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot4.Name = "GripperDot4", ;
		GRIPPER.GripperDot4.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot4.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot4.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot5.Name = "GripperDot5", ;
		GRIPPER.GripperDot5.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot5.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot5.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.Name = "GRIPPER"
		*< END OBJECT: ClassLib="sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'containerRight.splitter3' AS sfsplitterh WITH ;
		Anchor = 5, ;
		BackColor = 210,210,210, ;
		cobject1name = Container1, ;
		cobject2name = Container2, ;
		Height = 555, ;
		Left = 587, ;
		Name = "splitter3", ;
		Picture = ..\images\, ;
		TabIndex = 22, ;
		Top = 2, ;
		Visible = .F., ;
		Width = 10, ;
		GRIPPER.GripperDot1.Name = "GripperDot1", ;
		GRIPPER.GripperDot1.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot1.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot1.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot2.Name = "GripperDot2", ;
		GRIPPER.GripperDot2.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot2.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot2.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot3.Name = "GripperDot3", ;
		GRIPPER.GripperDot3.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot3.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot3.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot4.Name = "GripperDot4", ;
		GRIPPER.GripperDot4.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot4.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot4.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot5.Name = "GripperDot5", ;
		GRIPPER.GripperDot5.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot5.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot5.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.Name = "GRIPPER"
		*< END OBJECT: ClassLib="sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'editSearch' AS editbox WITH ;
		Anchor = 10, ;
		ControlSource = "Thisform.oSearchEngine.oSearchOptions.cSearchExpression", ;
		Height = 26, ;
		Left = 47, ;
		Name = "editSearch", ;
		SelectOnEntry = .T., ;
		TabIndex = 2, ;
		Top = 3, ;
		Width = 400
		*< END OBJECT: BaseClass="editbox" />

	ADD OBJECT 'imgFolder_Pick' AS image WITH ;
		Anchor = 8, ;
		Height = 16, ;
		Left = 448, ;
		Name = "imgFolder_Pick", ;
		Picture = ..\images\gf_folderpick_icon_16.bmp, ;
		ToolTipText = "Click to pick folder.", ;
		Top = 36, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'imgProj_Pick' AS image WITH ;
		Anchor = 8, ;
		Height = 16, ;
		Left = 428, ;
		Name = "imgProj_Pick", ;
		Picture = ..\images\gf_projectpick_icon_16.bmp, ;
		ToolTipText = "Click to pick project.", ;
		Top = 36, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'imgScopeIcon' AS image WITH ;
		Height = 16, ;
		Left = 163, ;
		Name = "imgScopeIcon", ;
		Picture = ..\images\gf_project_icon_16.bmp, ;
		Top = 36, ;
		Width = 16
		*< END OBJECT: BaseClass="image" />

	ADD OBJECT 'lblReplaceHistory' AS label WITH ;
		Alignment = 2, ;
		BackColor = 149,249,147, ;
		Caption = "Replace History", ;
		FontBold = .T., ;
		FontItalic = .F., ;
		FontSize = 20, ;
		ForeColor = 0,0,0, ;
		Height = 35, ;
		Left = 456, ;
		Name = "lblReplaceHistory", ;
		Style = 0, ;
		TabIndex = 6, ;
		Top = 245, ;
		Visible = .F., ;
		Width = 236
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblScope' AS label WITH ;
		BackStyle = 0, ;
		Caption = "Scope:", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Height = 13, ;
		Left = 6, ;
		Name = "lblScope", ;
		TabIndex = 4, ;
		Top = 35, ;
		Width = 35
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'lblSearch' AS label WITH ;
		BackStyle = 0, ;
		Caption = "\<Search:", ;
		FontBold = .F., ;
		FontItalic = .F., ;
		FontSize = 8, ;
		ForeColor = 0,0,0, ;
		Height = 13, ;
		Left = 5, ;
		Name = "lblSearch", ;
		TabIndex = 1, ;
		Top = 9, ;
		Width = 37
		*< END OBJECT: BaseClass="label" />

	ADD OBJECT 'ProgressBar' AS gf_progressbar WITH ;
		Left = 235, ;
		Name = "ProgressBar", ;
		Picture = ..\images\, ;
		TabIndex = 12, ;
		Top = 307, ;
		Image1.Name = "Image1", ;
		Image1.Picture = ..\images\progressbarbackground.bmp, ;
		Box.Name = "Box", ;
		Box.Picture = ..\images\, ;
		bar.Image1.Name = "Image1", ;
		bar.Image1.Picture = ..\images\progressbar.bmp, ;
		bar.Name = "bar", ;
		bar.Picture = ..\images\, ;
		Label1.Name = "Label1", ;
		Label2.Name = "Label2"
		*< END OBJECT: ClassLib="gofishui.vcx" BaseClass="container" />

	ADD OBJECT 'splitter2' AS sfsplitterh WITH ;
		Anchor = 5, ;
		BackColor = 210,210,210, ;
		cobject1name = containerLeft, ;
		cobject2name = containerRight, ;
		Height = 555, ;
		Left = 189, ;
		Name = "splitter2", ;
		Picture = ..\images\, ;
		TabIndex = 11, ;
		Top = 58, ;
		Width = 10, ;
		GRIPPER.GripperDot1.Name = "GripperDot1", ;
		GRIPPER.GripperDot1.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot1.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot1.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot2.Name = "GripperDot2", ;
		GRIPPER.GripperDot2.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot2.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot2.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot3.Name = "GripperDot3", ;
		GRIPPER.GripperDot3.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot3.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot3.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot4.Name = "GripperDot4", ;
		GRIPPER.GripperDot4.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot4.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot4.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.GripperDot5.Name = "GripperDot5", ;
		GRIPPER.GripperDot5.ShapeDark.Name = "ShapeDark", ;
		GRIPPER.GripperDot5.ShapeLight.Name = "ShapeLight", ;
		GRIPPER.GripperDot5.ShapeMiddle.Name = "ShapeMiddle", ;
		GRIPPER.Name = "GRIPPER"
		*< END OBJECT: ClassLib="sfsplitter.vcx" BaseClass="control" />

	ADD OBJECT 'timerShowAdvancedForm' AS timer WITH ;
		Height = 25, ;
		Left = 24, ;
		Name = "timerShowAdvancedForm", ;
		Top = 527, ;
		Width = 25
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'tmrEvent' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 5, ;
		Left = 54, ;
		Name = "tmrEvent", ;
		Top = 292, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />

	ADD OBJECT 'tmrGrid' AS timer WITH ;
		Enabled = .F., ;
		Height = 23, ;
		Interval = 400, ;
		Left = 56, ;
		Name = "tmrGrid", ;
		Top = 320, ;
		Width = 23
		*< END OBJECT: BaseClass="timer" />
	
	PROCEDURE Activate
		Local lcApp, lcProc, lcProcedures, lcScope, lnPrevSearchScope, lnSearchScope
		
		*!* ******************** Removed 05/12/2016 *****************
		*!* *-- This code was added 2012-08-30 to allow GF to work properly with 'IntellisenseX by Dot' from Thor
		*!* This.cOnKeyLabelDot = On("Key", ".")
		*!* On Key Label .
		Thisform.lAutoYield	= _vfp.AutoYield
		_vfp.AutoYield		= .T.
		
		lcApp = ''
		
		Try
			lcApp = _Screen._GoFish.cAppPath + _Screen._GoFish.cAppName
		Catch
			Messagebox('Error: Cannot find _Screen._GoFish object.', 0, 'GoFish error:')
		Endtry
		
		*-- Need to restore these Procedure files in case the user clears them out outside of this form.
		If Not Empty(m.lcApp)
			lcProcedures = Upper(Set('Procedure'))
			lcProc		 = 'GoFishSearchEngine'
			If Not (Upper(m.lcProc) $ m.lcProcedures)
				Try
					Set Procedure To &lcProc Additive
				Catch
					Messagebox('Cannot restore procedure file ' + m.lcProc, 0, 'GoFish error:')
				Endtry
			Endif
		
			lcProc = 'GF_PEME_BaseTools'
			If Not (Upper(m.lcProc) $ m.lcProcedures)
				Try
					Set Procedure To &lcProc Additive
				Catch
					Messagebox('Cannot restore procedure file ' + m.lcProc, 0, 'GoFish error:')
				Endtry
			Endif
		Endif
		
		Thisform.UpdateSearchScopeVariables()
		
		lcScope = Thisform.GetCurrentScope()
		
		With Thisform.comboSearchScopeHistory
			lnPrevSearchScope = Thisform.oSearchOptions.nSearchScope
		
			.LoadRows()
			.SaveSearchScope(m.lcScope)
			.Value = Lower(m.lcScope)
		
			*** JRN 2024-02-28 : Preserving "Active Project", "All Open Projects", "Current Dir"
			lnSearchScope = Thisform.oSearchOptions.nSearchScope
			If Inlist(m.lnPrevSearchScope, 1, 3, 5)
				Thisform.oSearchOptions.nSearchScope = m.lnPrevSearchScope
			Endif
		
		Endwith
		
		DoDefault()
		
		Set Safety Off
		
		If Thisform.lCR_AllowEd And Thisform.lCR_SearchComboPerScope Then
			Thisform.comboSearchExpressionHistory.LoadRows
		Endif &&Thisform.lCR_Allowed And Thisform.lCR_StorePerScope
		Thisform.comboSearchExpressionHistory.Requery()
		
		
		*--- Update UDF info on Advanced Replace stuff ------------------
		If Not Empty(Thisform.cReplaceUDFFilename) And File(Thisform.cReplaceUDFFilename)
			Thisform.oSearchEngine.cReplaceUDFCode = Filetostr(Thisform.cReplaceUDFFilename)
		Else
			Thisform.cReplaceUDFFilename		   = ''
			Thisform.oSearchEngine.cReplaceUDFCode = ''
		Endif
		
		If Thisform.nReplaceMode = 4 && Update the Replace lines, in case the UDF has been modified.
			Thisform.doreplace(.T.)
		Endif
		
		Thisform.Refresh()
		
		
		
	ENDPROC

	PROCEDURE addclassestotreeview
		*******************************************************************************
		*                                                                             *
		*  Abstract                                                                   *
		*  Fill the node given with classes of the files named                        *
		*                                                                             *
		*  called by                                                                  *
		*  - PopulateNode                                                             *
		*                                                                             *
		*  indirectly controlled by                                                   *
		*  - search form internal filters                                             *
		*                                                                             *
		* Parameters                                                                  *
		* ==========                                                                  *
		* toVcxNode                                                                   *
		*  The node to add child node for each class                                  *
		*                                                                             *
		* tcUni                                                                       *
		*  unique ID of the search                                                    *
		*                                                                             *
		* tcSearch                                                                    *
		*  Search expression, for storage purposes                                    *
		*                                                                             *
		* tcScope                                                                     *
		*  Scope expression, for storage purposes                                     *
		*                                                                             *
		* tcNFilter                                                                   *
		*  Filter expression for node, for storage purposes                           *
		*  - used to create result set of nodes                                       *
		*                                                                             *
		* Return                                                                      *
		* ======                                                                      *
		* n/a                                                                         *
		*                                                                             *
		* SF 2022/11/13                                                               *
		*                                                                             *
		*******************************************************************************
		Lparameters toVcxNode, tcUni, tcSearch, tcScope, tcNFilter
		*tcWhere
		
		Local lcAlias, lcClass, lcClassLibFilter, lcFileName, lcFilter, lnSelect, loNode
		Local loException, lcWhere
		
		lnSelect = Select()
		lcAlias	 = Thisform.cSearchResultsAlias
		
		lcNFilter = Iif(Empty(m.tcNFilter), "", "(" + m.tcNFilter + ") And ")
		
		*lcFilter = Alltrim(Filter(m.lcAlias))
		lcFilter = Thisform.GetFilter()
		
		Do Case
			Case Empty(m.tcNFilter)
				lcWhere	 = "Where " + m.lcFilter
			Case Empty(m.lcFilter)
				lcWhere	 = "Where " + m.tcNFilter
			Otherwise
				lcWhere	 = "Where " + m.lcNFilter + m.lcFilter
		Endcase
		
		Select Distinct;
			FileName, Class;
			From (m.lcAlias);
			&lcWhere;
			Order By Class;
			Into Cursor curClasses
		*!*	SELECT;
		*!*		FileName, Class, Id;
		*!*		From (m.lcAlias);
		*!*		&lcWhere;
		*!*		Order By Class, Id;
		*!*		Into Cursor "Classes"
		
		lcFilePath = m.toVcxNode.Tag.gcFilePath
		lcFileName = m.toVcxNode.Tag.gcFileName
		Scan For Not Empty(Class)
			lcFileName = Alltrim(FileName)
			lcClass	   = Alltrim(Class)
			Try
					loNode     = Thisform.oTree.Nodes.Add(m.toVcxNode.Key, 4, "Class_" + Sys(2015), m.lcClass, ,)
		*			loNode     = Thisform.oTree.Nodes.Add(m.toVcxNode.Key, 4, "Class_" + Alltrim(Str(Id)), m.lcClass, ,)
					loNode.Tag = Thisform.Get_oNodeTag("CLASS", m.tcUni, m.tcSearch, m.tcScope,	"",;
						m.lcNFilter + "Lower(class) = [" + m.lcClass + "]",;
						m.toVcxNode.Tag.gcFileName, m.toVcxNode.Tag.gcFilePath, m.toVcxNode.Tag.gcFileExt, m.lcClass,.F.)
				Catch To m.loException
			Endtry
		*!*		Locate Rest For;
		*!*			Alltrim(FileName) + Alltrim(Class) # m.lcFileName + m.lcClass
		
		*!*		If Not Eof()
		*!*			Skip - 1
		*!*		Endif
		
		Endscan
		
		Use In Select("curClasses")
		Select (m.lnSelect)
		
	ENDPROC

	PROCEDURE addclassestotreeviewsimple
		Lparameters toVcxNode, tcClassLib
		
		Local lcAlias, lcClass, lcClassLibFilter, lcFileName, lcFilter, lcWhere, lnSelect, loClassLibsNode
		Local loException
		
		lnSelect = Select()
		lcAlias	 = Thisform.cSearchResultsAlias
		
		lcClassLibFilter = 'filepath = [' + Alltrim(m.tcClassLib) + ']'
		
		lcFilter = Alltrim(Filter(m.lcAlias))
		lcWhere	 = 'Where ' + m.lcFilter + Iif(Not Empty(m.lcFilter), ' and ', '') + m.lcClassLibFilter
		Select FileName, Class, Id From (m.lcAlias) &lcWhere Order By Class, ID Into Cursor 'Classes'
		
		Scan For Not Empty(Class)
			lcFileName = Alltrim(FileName)
			lcClass	   = Alltrim(Class)
			Try
				loClassLibsNode = Thisform.oTree.Nodes.Add(m.toVcxNode.Key, 4, 'Class_' + Alltrim(Str(Id)), m.lcClass, ,)
			Catch To m.loException
			Endtry
			Locate For Alltrim(FileName) + Alltrim(Class) # m.lcFileName + m.lcClass Rest
		
			If Not Eof()
				Skip - 1
			Endif
		
		Endscan
		
		Select (m.lnSelect)
		
		
		
	ENDPROC

	PROCEDURE adjustformforreplacepanel
		Local;
			loGrid      As Object,;
			loGridPanel As Object,;
			loReplacePanel As Object
		
		loGridPanel    = Thisform.containerRight.container1
		loGrid         = Thisform.containerRight.container1.gridFiles
		loReplacePanel = m.loGridPanel.containerReplaceText
		
		If Empty(Thisform.oSearchEngine.oSearchOptions.cReplaceExpression)
			Thisform.oSearchEngine.oSearchOptions.cReplaceExpression = Thisform.oSearchEngine.oSearchOptions.cSearchExpression
		Endif
		
		loGrid.Anchor = 0
		
		If Thisform.lReplaceViewMode 
			If Inlist(Thisform.nReplaceMode,2,3,4) Then
				loReplacePanel.PageFrame.Visible = .T.
				loReplacePanel.Height = loReplacePanel.PageFrame.Top + loReplacePanel.PageFrame.Height
			Else  &&Inlist(Thisform.nReplaceMode,2,3,4)
				loReplacePanel.PageFrame.Visible = .F.
				loReplacePanel.Height = loReplacePanel.PageFrame.Top
			Endif &&Inlist(Thisform.nReplaceMode,2,3,4)
		
			loGrid.Top = m.loReplacePanel.Top + m.loReplacePanel.Height
		
		Else &&Thisform.lReplaceViewMode
			loGrid.Top = m.loReplacePanel.Top
		Endif &&Thisform.lReplaceViewMode
		
		loGrid.Height = m.loGrid.Parent.Height - m.loGrid.Top - 1
		
		loGrid.Anchor = 15
		
		Thisform.Refresh()
		
	ENDPROC

	PROCEDURE applyfilter
		Local lcFilter, lcSelectCode
		
		If This.lApplyFilter
			lcFilter = Evl(Thisform.cFilter, '')
		Else
			lcFilter = ''
		Endif
		
		Do Case
			*** JRN 2024-02-05 : Extended definition of 'Code Only' to include some entries in MNXs and FRXs
			Case Thisform.lCodeOnly
				lcMatchTypes = ['CODE', '<CONSTANT>', '<COMMAND>', '<PROCEDURE>', '<SKIPFOR>', '<METHOD>', '<FUNCTION>']
				lcSelectCode = [(InList(Upper(MatchType), ] + m.lcMatchTypes + [) or (Upper(MatchType) = '<EXPR>' and Upper(class) = 'FIELD'))]
				lcFilter	 = m.lcSelectCode + Iif(Empty(m.lcFilter), '', [ and ] + m.lcFilter)
		
			*** JRN 2024-02-05 : New option 'Comments Only'
			Case Thisform.lCommentsOnly
				lcSelectCode = [(Upper(MatchType) = '<COMMENT>')]
				lcFilter	 = m.lcSelectCode + Iif(Empty(m.lcFilter), '', [ and ] + m.lcFilter)
		
		Endcase
		
		Set Filter To &lcFilter In (Thisform.cSearchResultsAlias)
		
		Goto Top In (Thisform.cSearchResultsAlias)
		
		Return m.lcFilter
		
	ENDPROC

	PROCEDURE buildsearchhistorycursor
		Lparameters						;
			tlForceEmptyCursor,			;
			tlOldStyle
		
		Local lcDir As String
		Local lcInfoFile As String
		Local lcName As String
		Local lcRoot As String
		Local lcScope As String
		Local lcScopeMacro As String
		Local llNoFilter As Boolean
		Local lnALen As Number
		Local lnSelect As Integer
		Local laDirs[1], laInfo[1], lcDate, lnDayIndex, lnHourIndex, lnMinuteIndex, lnMonthIndex
		Local lnSecondIndex, lnSpace, lnYearIndex
		
		*:Global		;
		x
		
		If Not m.tlOldStyle Then
			lcScopeMacro = ''
		
			*search / show replaced mode
			If This.lReplace_History
				lcScopeMacro = m.lcScopeMacro + ' AND Cur1.lReplace'
			Else  &&This.lReplace_History
				lcScopeMacro = m.lcScopeMacro + ' AND Cur1.lSaved'
			Endif &&This.lReplace_History
		
			If Not This.lReplace_History And This.lCR_AllowEd And This.lCR_HistoryPerScope Then
				lcScopeMacro = m.lcScopeMacro + [ AND Lower(Cur1.Scope)==Lower("] + Thisform.GetCurrentScope() + [")]
			Endif &&!This.lReplace_History And This.lCR_Allowed And This.lCR_HistoryPerScope
		
			lcScopeMacro = Strtran(m.lcScopeMacro, ' AND', ' WHERE', 1, 1)
		
			lnSelect = Select()
		
			Thisform.savedbc_open()
		
			This.UseTable('GF_Search_History', 'GF_Search_History')
		
			Select														;
					Cur1.*,												;
					.F.                   As  lRestored,				;
					Ctot(DateTime)        As  TDateTime					;
				From GF_Search_History    As  Cur1						;
				Into Cursor gf_SearchHistory NoFilter Readwrite			;
					&lcScopeMacro										;
				Order By Cur1.Search Asc,								;
					Cur1.Datetime Asc
		
			Index On TDateTime Descending Tag _DateT
		
			Use In Select('GF_Search_History')
		
			Thisform.savedbc_close()
		
			Select(m.lnSelect)
		
			Return Reccount('gf_SearchHistory')
			********************************************************************************************
		Endif &&!m.tlOldStyle
		********************************************************************************************
		
		*just to migrate to v6.0
		lcScope	   = ''
		llNoFilter = .T.
		If This.lCR_AllowEd And This.lCR_HistoryPerScope Then
			lcScope	   = Lower(Thisform.GetCurrentScope())
			llNoFilter = .F.
		Endif &&This.lCR_Allowed And This.lCR_HistoryPerScope
		
		lnSelect = Select()
		
		lcName = Thisform.cSavedSearchResultsFolder
		*SF 20221018 -> local storage
		*lcRoot = Home(7) + lcName
		lcRoot = This.cCR_StoreLocal + m.lcName
		*/SF 20221018 -> local storage
		
		Adir(laDirs, Addbs(m.lcRoot) + '*', 'D', 1)
		
		If Type('laDirs') $ 'UL'
			lnALen = 0
		Else
			lnALen = Alen(m.laDirs) / 5
		Endif
		
		
		If m.lnALen > 0 Or m.tlForceEmptyCursor Then
			*-- Create cursor to hold the results
			Select  Space(11)     As  cUni,								;
					Space(24)     As  Datetime,							;
					Space(40)     As  Search,							;
					Space(10)     As  Results,							;
					Space(150)    As  Scope,							;
					Space(255)    As  SearchHistoryFolder,				;
					.F.           As  lSaved,							;
					.F.           As  lReplace,							;
					.F.           As  lRestored							;
				From (Thisform.oSearchEngine.cSearchResultsAlias)		;
				Where 0 = 1												;
				Into Cursor gf_SearchHistory Readwrite
		
			Index On Datetime Descending Tag nnn
		
		Endif &&m.lnAlen>0 OR m.tlForceEmptyCursor
		
		If m.lnALen = 0 Then
			Return 0
		Endif &&m.lnAlen=0
		
		For x = 1 To m.lnALen
			lcDir	   = m.laDirs[x, 1]
			lcInfoFile = Addbs(m.lcRoot) + Addbs(m.lcDir) + m.lcName + '.txt'
			If File(m.lcInfoFile)
				Alines(laInfo, Filetostr(m.lcInfoFile))
		
				If m.llNoFilter Or Lower(m.laInfo[3]) == m.lcScope Then
					Append Blank
					Replace cUni                With '_' + Sys(2007, m.laInfo[1], 0, 1)
					Replace Datetime            With m.laInfo[1]
					Replace Search              With m.laInfo[2]
					Replace Scope               With m.laInfo[3]
					Replace Results             With m.laInfo[4]
					Replace SearchHistoryFolder With Addbs(m.lcRoot) + Addbs(m.lcDir)
					Replace lSaved              With .T.
		
				Endif &&m.llNoFilter Or LOWER(laInfo[3])==m.lcScope
			Endif
		
		Endfor
		
		Select(m.lnSelect)
		
		Return Reccount('gf_SearchHistory')
		
	ENDPROC

	PROCEDURE captureresizingproperties
		* Captures resizing properties for a few controls on the top of the form
		* so that they do not skitter all the way to the far right when form is wide
		
		Local loControl
		
		For Each m.loControl In This.Controls FoxObject
			With m.loControl
				Do Case
					Case .Top > Thisform.Containerright.Top - 3  && skip
		
					Case Pemstatus(m.loControl, 'Anchor', 5) = .F.
		
					Case m.loControl.Anchor = 0
		
					Case .Anchor = 10 && Width changes
						.AddProperty('nWidthDifference', Thisform.Width - .Width)
						.Anchor = 0
		
					Case .Anchor = 8 && Left changes
						.AddProperty('nLeftDifference', Thisform.Width - .Left)
						.Anchor = 0
		
				Endcase
			Endwith
		Endfor
		
		loControl = Null
		
		
	ENDPROC

	PROCEDURE check2gblimit
		* Checking if close to 2GB limit
		#Define cnLimit  		2**31
		#Define cnWarningSize	80 && that is, start warning at 80%
		
		Local laFiles[1], lcText, lnI, lnMax, lnCount
		
		lnCount =  Adir(laFiles, This.cCR_StoreLocal + 'GF_RESULTS_FORM_SETTINGS.*')
		
		lnMax = 0
		For lnI = 1 To m.lnCount
			lnMax = Max(m.lnMax, 100 * m.laFiles[m.lnI, 2] / cnLimit)
		Endfor
		
		If m.lnMax < cnWarningSize
			Return
		Endif
		
		Text To m.lcText Noshow Textmerge
		Warning! Search history table approaching 2GB limit (<<Round(m.lnMax, 1)>>%)
		
		You will need to remove old searches, in either of two ways:
		   1) Clicking on the History button and deleting them manually.
		   2) Using the Janitor ("Options" form => Janitor)    
		Endtext
		
		Messagebox(m.lcText, 64, 'Approaching 2GB limit')
		
	ENDPROC

	PROCEDURE checkall
		Thisform.FilterGFSE()
		
		*-- Update local cursor
		Replace process with .t. All in (Thisform.cSearchResultsAlias) ;
		 For replacerisk <= Thisform.nReplaceRisk and ;
				 replaced = .f. 
		
		*-- Update GFSE cursor
		Replace process with .t. All in (Thisform.oSearchEngine.cSearchResultsAlias) ;
		 For replacerisk <= Thisform.nReplaceRisk and ;
				 replaced = .f. 
		 
		Thisform.DoReplace(.t.)  &&.t. means "Preview" Replace
		
		
	ENDPROC

	PROCEDURE clearall
		Thisform.FilterGFSE()
		
		Replace process with .f. all in (Thisform.cSearchResultsAlias)
		Replace replaceline with "" for replaced = .f. in (Thisform.cSearchResultsAlias)
		Replace trimmedreplaceline with "" for replaced = .f. in (Thisform.cSearchResultsAlias)
		
		Replace process with .f. all in (Thisform.oSearchEngine.cSearchResultsAlias)
		Replace replaceline with "" for replaced = .f. in (Thisform.oSearchEngine.cSearchResultsAlias)
		Replace trimmedreplaceline with "" for replaced = .f. in (Thisform.oSearchEngine.cSearchResultsAlias)
		
		Thisform.ClearGFSEFilter()
		Goto top in (Thisform.cSearchResultsAlias)
		Thisform.oGrid.SetFocus()
		
		
	ENDPROC

	PROCEDURE cleargfsefilter
		Set Filter To in (This.oSearchEngine.cSearchResultsAlias)
	ENDPROC

	PROCEDURE clearsearchresultscursor
		Local lcSafety, lnSelect
		
		lnSelect = Select()
		
		Select (This.cSearchResultsAlias)
		
		If Used(This.cSearchResultsAlias)
			lcSafety = Set("Safety")
			Set Safety Off
			Zap in (This.cSearchResultsAlias)
			Set Safety &lcSafety
		Else
			MessageBox("Error clearing search results cursor for new search.", 0, "Error:")
			Select (lnSelect)
			Return .f.
		EndIf
		
		Select (lnSelect)
		   
	ENDPROC

	PROCEDURE cleartreeview
		*Thisform.oTree.visible = .f.
		Thisform.LockWindow(.t.)
		Thisform.oTree.Nodes.Clear()
		Thisform.LockWindow(.f.)
		*Thisform.oTree.visible = .t.
		
	ENDPROC

	PROCEDURE combinefilters
		Lparameters lcFilter1, lcFilter2
		
		Return m.lcFilter1 + Iif(Empty(m.lcFilter1) Or Empty(m.lcFilter2), "", " and ") + m.lcFilter2
	ENDPROC

	PROCEDURE confirmreplace
		Local lcBackupOption, llBackup, lnResponse
		
		If Thisform.oSearchEngine.oSearchOptions.lDoNotShowReplaceWarning
			Return .T.
		Endif
		
		llBackup = Thisform.oSearchEngine.oSearchOptions.lBackup
		
		lcBackupOption = "Backup option: " + Iif(llBackup, "[Enabled]", "[*** DISABLED ***]")
		
		lnResponse = Messagebox("=============================================" + CR + ;
			  "             W  A  R  N  I  N  G	"											+ CR + ;
			  "============================================="	+ CR + CR + ;
			  "Are you SURE you are ready to Replace?" + CR + CR + ;
			  lcBackupOption + CR + CR + ;
			  "These changes cannot be reversed!!", 3 + 32, "GoFish Replace")
		
		If lnResponse <> 6
			Return .F.
		Endif
		
		
		
	ENDPROC

	PROCEDURE Deactivate
		Local lcDot
		
		_VFP.AutoYield = Thisform.lAutoYield
		
		*!* ******************** Removed 05/12/2016 *****************
		*!* *-- This code was added 2012-08-30 to allow GF to work properly with 'IntellisenseX by Dot' from ThorLocal lcDot
		*!* lcDot = This.cOnKeyLabelDot
		*!* On Key Label . &lcDot
		
	ENDPROC

	PROCEDURE deletesearchresults		&& Delete single or all results from history
		Lparameters				;
			tcUni,				;
			tdDateLimit,		;
			tlJustResult,		;
			tlReplace,			;
			tlIgnoreScope,		;
			tlAll
		
		Local lcScope As String
		Local llDeepSearch As Boolean
		Local lnSelect As Number
		
		If m.tlIgnoreScope Or Not This.lCR_HistoryPerScope Then
			lcScope = ''
		Else  &&m.tlIgnoreScope OR !This.lCR_HistoryPerScope
			lcScope = Lower(Thisform.GetCurrentScope())
		Endif &&m.tlIgnoreScope OR ! This.lCR_HistoryPerScope
		
		lnSelect = Select()
		This.SaveDBC_Open()
		
		If m.tlJustResult Then
			llDeepSearch = .F.
		Else  &&m.tlJustResult
			llDeepSearch = Not This.Delete_History(m.tcUni, m.tdDateLimit, m.lcScope,		;
				  m.tlReplace, m.tlAll)
		Endif &&m.tlJustResult
		
		This.Delete_HistoryHits(m.tcUni, m.tdDateLimit, m.lcScope,		;
			  m.tlReplace, m.llDeepSearch, m.tlAll)
		
		Select (m.lnSelect)
		
	ENDPROC

	PROCEDURE delete_history		&& Delete the history "parent" record
		Lparameters;
			tcUni,;
			tdDateLimit,;
			tcScope,;
			tlReplace,;
			tlAll
		
		Local;
			lcDBF As String,;
			lcMacro As String,;
			llReturn As Boolean,;
			lnSelect As Number
		
		lcMacro = ""
		If !Empty(m.tdDateLimit) Then
		*Janitor
			lcMacro = m.lcMacro + " AND TTOD(CTOT(DATETIME)) < m.tdDateLimit"
		Endif &&EMPTY(m.tdDateLimit)
		
		Do Case
			Case m.tlAll
		*all (ignore Janitor)
				lcMacro = ""
		
			Case !Isnull(m.tcUni)
		*per Search Id (save or replace)
				lcMacro = m.lcMacro + ' AND cUni=="' + m.tcUni + '"'
		
			Case !Empty(m.tcScope)
		*active setting filter by scope
				lcMacro = m.lcMacro + ' AND Lower(Scope)=="' + m.tcScope + '"'
			Otherwise
		*all (save or replace) per Janitor
		
		Endcase
		
		lnSelect = Select()
		
		Select 0
		
		lcDBF = "GF_Search_History"
		Try
				Use (m.lcDBF) Exclusive
				Pack
			Catch
				Use (m.lcDBF) In Select(m.lcDBF)
		Endtry
		
		Do Case
			Case m.tlAll
		*delete all and anything, ignore scope datetime
				Delete;
				 All
		
		*all deleted
				llReturn = .T.
		
		*	&&m.tlAll
			Case m.tlReplace
		*delete replaced, but keep stored
		*optional older then tdDateLimit
				Update Cur1 Set;
				 lReplace = .F.;
				 From (m.lcDBF) As Cur1;
				 Where Cur1.lSaved;
				  &lcMacro
		
		*saved records kept
				llReturn = _Tally=0
		
				Delete From (m.lcDBF);
				 Where !lSaved;
				  &lcMacro
		
		*	&&m.tlReplace
			Otherwise
		*delete stored, but keep replaced
		*optional older then tdDateLimit
				Update Cur1 Set;
				 lSaved = .F.;
				 From (m.lcDBF) As Cur1;
				 Where Cur1.lReplace;
				  &lcMacro
		
		*replaced records kept
				llReturn = _Tally=0
		
				Delete From (m.lcDBF);
				 Where !lReplace;
				  &lcMacro
		
		Endcase
		
		Use In Select(m.lcDBF)
		
		Select (m.lnSelect)
		
		*All deleted (no replace / stored found)
		Return m.llReturn
		
	ENDPROC

	PROCEDURE delete_historyhits		&& Delete the history records per hit
		Lparameters;
			tcUni,;
			tdDateLimit,;
			tcScope,;
			tlReplace,;
			tlDeep,;
			tlAll
		
		Local;
			lcAlias     As String,;
			lcBackupFolder As String,;
			lcDBF       As String,;
			lcFile      As String,;
			lcMacro     As String,;
			llReturn    As Boolean,;
			lnSelect    As Number
		
		lnSelect = Select()
		
		Select 0
		
		lcDBF   = Juststem(Thisform.cUISettingsFile)
		lcAlias = Thisform.cSearchResultsAlias
		
		If !Indbc(m.lcDBF,"TABLE") Then
			Return
		Endif &&!INDBC(m.lcDBF,"TABLE")
		
		lcMacro = ""
		If !Empty(m.tdDateLimit) Then
		*Janitor
			lcMacro = m.lcMacro + " AND TTOD(CTOT(DATETIME)) < m.tdDateLimit"
		Endif &&EMPTY(m.tdDateLimit)
		
		Do Case
			Case m.tlAll
		*all (ignore Janitor)
				lcMacro = ""
		
			Case !Isnull(m.tcUni)
		*per Search Id (save or replace)
				lcMacro = m.lcMacro + ' AND cUni=="' + m.tcUni + '"'
		
			Case !Empty(m.tcScope)
		*active setting filter by scope
				lcMacro = m.lcMacro + ' AND Lower(Scope)=="' + m.tcScope + '"'
			Otherwise
		*all (save or replace) per Janitor
		
		Endcase
		
		Try
				Use (m.lcDBF) Exclusive
				Pack
			Catch
				Use (m.lcDBF) In Select(m.lcDBF)
		Endtry
		
		Do Case
			Case m.tlAll
		*delete all and anything, ignore scope datetime
		*all
		
				Delete From (m.lcDBF)
				Delete From (m.lcAlias)
		
				Select 0
				Use GF_ReplaceID
		        Replace;
		         iID With 1000
				Use
		
		*all deleted
				llReturn = .T.
		
		*	&&m.tlAll
			Case m.tlReplace
		*delete replaced, but keep stored
		*get all replace backup folder to remove
				Select Distinct;
				 Cur1.iReplaceFolder;
				 From (m.lcDBF) As Cur1;
				 Into Cursor curBackFiles NoFilter;
				 Where !Empty(Cur1.iReplaceFolder);
				  And Cur1.Replaced;
				  &lcMacro
		
		*get all code snipets to remove (an only-restore-history record still owns snipets)
				Select Distinct;
				 Cur1.cUni_File;
				 From (m.lcDBF) As Cur1;
				 Into Cursor curFiles NoFilter;
				 Where !Cur1.lSaved;
				  And Cur1.Replaced;
				  &lcMacro
		
				If m.tlDeep Then
		*we are supposed to have mixed save/replace storage, set the save ones to only save and remove the only replace
					Update Cur1 Set;
					 Replaced = .F.;
					 From (m.lcDBF) As Cur1;
					 Where Cur1.lSaved;
					  &lcMacro
		
					Update Cur1 Set;
					 Replaced = .F.;
					 From (m.lcAlias) As Cur1;
					 Where Cur1.lSaved;
					  &lcMacro
		
					lcMacro = m.lcMacro + " AND !lSaved"
				Endif &&m.tlDeep
		
				lcMacro = m.lcMacro + " AND Replaced"
				lcMacro = Strtran(m.lcMacro, " AND", " WHERE", 1, 1)
				Delete From (m.lcDBF);
				 &lcMacro
				Delete From (m.lcAlias);
				 &lcMacro
		
		*	&&m.tlReplace
			Otherwise
		*delete stored, but keep replaced
		*delete replaced, but keep stored
				If m.tlDeep Or !Empty(m.tdDateLimit) Or;
						(Isnull(m.tcUni) And !Empty(m.tcScope)) Then
		*get all snipets to remove. This is more complex, since we keep the snipets when hiding a replaced but saved record
					Select Distinct;
					 Cur1.cUni_File;
					 From (m.lcDBF) As Cur1;
					 Into Cursor curFiles NoFilter;
					 Where Cur1.lSaved;
					  And !Cur1.Replaced;
					  &lcMacro
				Endif &&m.tlDeep OR !Empty(m.tdDateLimit) OR (Isnull(m.tcUni) AND !Empty(m.tcScope))
		
				If m.tlDeep Then
		*we are supposed to have mixed save/replace storage, set the replace ones to only replace and remove the only save
					Update Cur1 Set;
					 lSaved = .F.;
					 From (m.lcDBF) As Cur1;
					 Where Cur1.Replaced;
					  &lcMacro
		
					Update Cur1 Set;
					 lSaved = .F.;
					 From (m.lcAlias) As Cur1;
					 Where Cur1.Replaced;
					  &lcMacro
		
					lcMacro = m.lcMacro + " AND !Replaced"
				Endif &&m.tlDeep
		
				lcMacro = Strtran(m.lcMacro, " AND", " WHERE", 1, 1)
				Delete From (m.lcDBF);
				 &lcMacro
				Delete From (m.lcAlias);
				 &lcMacro
		
		
		Endcase
		
		Use In Select(m.lcDBF)
		
		Select (m.lnSelect)
		
		*delete code snipets
		Do Case
			Case m.tlAll
				lcFile = Addbs(Thisform.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder) + "*.*"
		
			Case Used("curFiles")
		*special range per Janitor or scope
		*will un if replace reocrds are deleted (not hidden)
				Select  Distinct Padr(Left(cUni_File, At('_', cUni_File, 2)), 15) as cUni_File	;
					From curfiles															;
					Into Cursor crsr_Unis
						
				Scan
					lcFile = Addbs(Thisform.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder) + Trim(cUni_File) +"*.*"
					Delete File (m.lcFile)
				Endscan &&All
		
				Use
				lcFile = ""
			Case m.tlReplace
		*just replace, nothing to do here
				lcFile = ""
			Case Isnull(m.tcUni)
		* nothing
				lcFile = ""
		
			Otherwise
		*per Search Id (save or replace)
				lcFile = Addbs(Thisform.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder) + m.tcUni +"_*.*"
		
		Endcase
		
		If !Empty(m.lcFile)
			Delete File (m.lcFile)
			If m.tlAll Then
				GF_Write_Readme_Text(3, Addbs(Thisform.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder) + 'README.md', .T.)
		
			Endif &&m.tlAll
		Endif &&!Empty(m.lcFile)
		*/delete code snipets
		
		*delete replace backups
		lcBackupFolder = Addbs(This.cCR_StoreLocal + "GF_ReplaceBackups")
		If m.tlAll Then
		* just wipe the whole Backup Dir and rebuild
			GF_RemoveFolder(m.lcBackupFolder)
			Mkdir (m.lcBackupFolder)
		
			GF_Write_Readme_Text(4, m.lcBackupFolder + 'README.md', .T.)
		
		Else  &&m.tlAll
			If m.tlReplace Or m.tlAll And Used("curBackFiles")
				Select curBackFiles
				Scan
					lcFile = m.lcBackupFolder + Ltrim(Str(iReplaceFolder,12,0))
					GF_RemoveFolder(m.lcFile)
				Endscan &&All
		
				Use
		
			Endif &&m.tlReplace OR m.tlAll AND USED("curBackFiles")
		Endif &&m.tlAll
		
		*/delete replace backups
		
		*All deleted (no replace / stored found)
		Return m.llReturn
		
	ENDPROC

	PROCEDURE Destroy
		Local lcFolder, lcSearchEngineOptionsFile
		
		If thisform.dLastJanitorRunDate # Date()
			Thisform.RunJanitor()
			thisform.dLastJanitorRunDate = Date()
		EndIf 
		
		If thisform.lReplaceViewMode
			thisform.lReplaceViewMode = .F. && this removes the extra columns possibly visible from replace mode
		EndIf 
		
		DoDefault()
		
		If Thisform.lSaveSettings
			*-- Save Search Engine settings
			*	Wait 'Save GF search engine settings' Window at 20, 30 Nowait
		*SF 20221018 -> local storage
		*	lcSearchEngineOptionsFile = Home(7) + This.cSearchOptionsXMLFile
			lcSearchEngineOptionsFile = This.cCR_StoreLocal + This.cSearchOptionsXMLFile
		*/SF 20221018 -> local storage
			This.oSearchEngine.SaveOptions(lcSearchEngineOptionsFile)
		Endif
		
		This.oSearchOptions = .Null.
		This.oSearchEngine = .Null.
		This.oGrid = .Null.
		This.oBrowser = .Null.
		This.oTree = .Null.
		This.oWebControl = .Null.
		this.oFilter = .Null.
		
		Release _Screen._GoFish
		_Screen._GoFish = .Null.
		
		Wait Clear
	ENDPROC

	PROCEDURE doreplace
		Lparameters tlPreviewReplace, tnCount && .t. means do a "Preview" Replace
		
		Local;
			lnCurrentId As Number,;
			lnReplaceId As Number
		
		If m.tlPreviewReplace And !Thisform.lReplacePreview Then
			Return
		Endif &&m.tlPreviewReplace and !Thisform.lReplacePreview
		
		If !m.tlPreviewReplace && If not doing a Preview, then we are doing a replace and will do some extra validation
			If !Thisform.ValidateReplaceExpression() Or !Thisform.ConfirmReplace()
				Return .F.
			Endif
			Thisform.oSearchEngine.oProgressBar = Thisform.ProgressBar
			Thisform.ProgressBar.Start(m.tnCount, "Replacing in selected lines...")
		Else
			Thisform.oSearchEngine.oProgressBar = .Null.
		Endif
		
		lnCurrentId = Evaluate(Thisform.cSearchResultsAlias + ".id")
		lnReplaceId = This.Get_ReplaceID(m.tlPreviewReplace)
		
		*Thisform.UpdateSearchEngineCursor()&& Copy over the Process settings from local cursor to GFSE cursor
		Thisform.oSearchEngine.oSearchOptions.lAllowBlankReplace = .T.
		Thisform.oSearchEngine.oSearchOptions.lPreviewReplace    = m.tlPreviewReplace
		
		Thisform.FilterGFSE()
		
		*Thisform.oSearchEngine.ReplaceMarkedRows(Thisform.oSearchEngine.cSearchResultsAlias,m.lnReplaceId)
		Thisform.oSearchEngine.ReplaceMarkedRows(Thisform.cSearchResultsAlias,m.lnReplaceId)
		
		If !m.tlPreviewReplace && If not doing a Preview, then we are doing a replace and will do some extra validation
			Thisform.ProgressBar.Stop()
		Endif
		
		If Thisform.oSearchEngine.oReplaceErrors.Count > 0 And !m.tlPreviewReplace
			Thisform.containerRight.Container1.containerReplaceText.cmdReplaceErrors.Refresh() && To make sure the icon is visible before we show dialog box
			Messagebox("Error(s) during replace operation. Click on red Error icon for more details.", "Error:")
		Endif
		
		Thisform.ClearGFSEFilter()
		
		If !m.tlPreviewReplace Then
			Select (Thisform.cSearchResultsAlias)
			Locate;
				For Id=m.lnCurrentId
			Thisform.SaveReplaceResults()
		
		Endif &&!m.tlPreviewReplace
		
		Select (Thisform.cSearchResultsAlias)
		Locate;
			For Id=m.lnCurrentId
		
		If !Found()
			Locate
		Endif &&!Found()
		
		Thisform.UpdateFormAfteReplace(m.lnCurrentId)
		
	ENDPROC

	PROCEDURE dosearch
		Lparameters tlDoNotSearch, ttTime, tcUni
		
		Local lcMessage, lcScope, lcSearchExpression, lcSetEscape
		Local loSearchEngine As "GoFishSearchEngine"
		Local loSearchOptions As "GoFishSearchOptions"
		Local llUpdate
		
		llUpdate = Empty(m.tcUni)
		
		loSearchEngine = Thisform.oSearchEngine
		loSearchOptions = Thisform.oSearchEngine.oSearchOptions
		
		Thisform.lApplyFilter = .F.
		
		This.lMaximizeCodeView = .F.
		
		This.lInit = .T.
		Thisform.oSearchEngine.oSearchOptions.cReplaceExpression = ""
		
		If !tlDoNotSearch And !This.ValidateInputs()
			Thisform.lSearching = .F.
			Thisform.comboSearchScopeHistory.SetFocus()
			Thisform.Refresh()
			Return .F.
		Endif
		
		If loSearchOptions.lMatchWholeWord And Thisform.lWarnWholeWord =.T.
			lnResponse = Messagebox("Use Whole Word search?", 3, "Whole Word option...")
			If lnResponse = 2
				Return .F.
			Endif
			If lnResponse = 7 && NO
				loSearchOptions.lMatchWholeWord = .F.
			Endif
		Endif
		
		lcSetEscape = Set("Escape")
		Set Escape Off
		
		*!* ******************** Removed 11/10/2015 *****************
		*!* Set Typeahead To 1
		*!* Clear Typeahead
		*!* KEYBOARD "{spacebar}"
		
		Thisform.lSearching = .T.
		Thisform.cCurrentId = ""
		Thisform.cTreeViewFilter = ""
		
		If Thisform.lReplaceViewMode
			Thisform.lReplaceViewMode = .F.
		Endif
		
		If !Thisform.lCR_HistoryTree Then
			Thisform.ClearTreeview()
		Endif &&!Thisform.lCR_HistoryTree
		
		*-- This is required because I had problems getting the checkboxes to be usable after the cursor is zapped
		*-- and then re-populated. This value will be restored after the search.
		Thisform.oGrid.SetFocus()
		*Thisform.oGrid.colProcess.DynamicCurrentControl = ""
		*loColumn = Thisform.oGrid.FindColumn("PROCESS")
		*loColumn.DynamicCurrentControl = ""
		
		If !Thisform.lCR_HistoryTree Then
			Thisform.ClearSearchResultsCursor()
		Endif &&!Thisform.lCR_HistoryTree
		*Thisform.ClearSearchResultsCursor() && Go ahead and blank out the cursor so the grid will be empty during the search
		
		If !tlDoNotSearch
		
			Thisform.Refresh()
		
		*-- Save Search Expression ---------------------------------------------------
			lcSearchExpression = Thisform.oSearchEngine.oSearchOptions.cSearchExpression
		
			Thisform.comboSearchExpressionHistory.SaveSearchExpression(lcSearchExpression)
		
		*-- Save Search Scope ---------------------------------------------------
			lcScope = Alltrim(Lower(Thisform.comboSearchScopeHistory.Text))
		
			lcMessage = "Searching..."
		
			If m.llUpdate
		*SF 20221016 added colour options
		*	Thisform.PopulateTreeview(, lcMessage , 32768)
		
			Thisform.PopulateTreeview(, m.lcMessage , m.lcMessage , Thisform.nTreeSearchColour)
		*/ SF 20221016 added colour options
			Endif &&m.llUpdate
		
			Thisform.ShowHtml("<h3>&nbsp;&nbsp;&nbsp;" + lcMessage + "</h3>")
		
			loSearchEngine.oProgressBar = Thisform.ProgressBar
			loSearchEngine.PrepareForSearch() && Blank out settings from last search so I can refresh the UI with blank value
		
			Do Case
				Case Thisform.oSearchOptions.nSearchScope = 5 and _VFP.Projects.Count >= 1
					lnReturn = loSearchEngine.SearchInOpenProjects(lcScope, m.ttTime, m.tcUni)
					
				Case Thisform.oSearchOptions.nSearchScope = 1 and _VFP.Projects.Count >= 1
					lnReturn = loSearchEngine.SearchInProject(_vfp.ActiveProject.Name , m.ttTime, m.tcUni)
					
				Case Thisform.oSearchOptions.nSearchScope = 3
					lcScope = Alltrim(Lower(Thisform.oSearchEngine.GetCurrentDirectory()), '\')
					lnReturn = loSearchEngine.SearchInProject(lcScope, m.ttTime, m.tcUni)
					
				Case ".PJX" $ Upper(lcScope)
					lnReturn = loSearchEngine.SearchInProject(lcScope, m.ttTime, m.tcUni)
					
				Otherwise 
					lnReturn = loSearchEngine.SearchInPath(lcScope, m.ttTime, m.tcUni)
			Endcase
			
			If lnReturn <= 0 And Thisform.oSearchEngine.oSearchErrors.Count > 0
				Messagebox(Thisform.oSearchEngine.oSearchErrors[Thisform.oSearchEngine.oSearchErrors.count], 16, "GoFish - Search error:")
			Endif
		
			Set Escape &lcSetEscape
		
			Thisform.oSearchEngine.oSearchOptions.cReplaceExpression = lcSearchExpression
		
			Thisform.comboSearchScopeHistory.SaveSearchScope(lcScope)
		Else
			loSearchEngine.nMatchLines = Reccount(loSearchEngine.cSearchResultsAlias)
		Endif
		
		If !m.tlDoNotSearch And Thisform.lSaveSearchResults
			Select (Thisform.cSearchResultsAlias)
			Thisform.SaveSearchResults(loSearchEngine.tRunTime, loSearchEngine.cUni, m.llUpdate)
		Endif
		
		Select (Thisform.cSearchResultsAlias)
		Locate
		
		Thisform.UpdateFormAfterSearch(m.llUpdate)
		
		
	ENDPROC

	PROCEDURE editfile
		ThisForm.ShowCodeForCurrentRow()
		
		Thisform.oSearchEngine.EditFromCurrentRow(thisform.cSearchResultsAlias,,Thisform.lMoveNewCodeToTopLeft)
	ENDPROC

	PROCEDURE editmenufromcurrentrow
		Thisform.oSearchEngine.EditMenuFromCurrentRow(thisform.cSearchResultsAlias)
	ENDPROC

	PROCEDURE editobjectfromcurrentrow
		Thisform.oSearchEngine.EditObjectFromCurrentRow(thisform.cSearchResultsAlias)
	ENDPROC

	PROCEDURE expandallnodes
		Local i
		
		For i = 1 To This.oTree.Nodes.Count
			This.ExpandNode(This.oTree.Nodes.Item(i))
		EndFor
		
		Thisform.oTree.SelectedItem.EnsureVisible()
		
	ENDPROC

	PROCEDURE exporttoexcel
		Lparameters llToFile
		
		Local loExport As "CreateExportCursor"
		Local laFields[1], lcCursorName, lcExportCursor, lcFieldList, lcFile, lcFilter, lcName, lcOrderBy
		Local lcResultsCursor, lcTempTable, lnResponse, lnSelect, lnX, loColumn
		
		If m.llToFile
			lcFile = Getfile("xlsx, dbf", "File Name:", "Export to", 0, "Export to DBF or XLSX")
			If Empty(m.lcFile)
				Return
			Endif
		
			If Not Inlist(Justext(m.lcFile), "DBF", "XLSX")
				Messagebox("Invalid file type")
				Return
			Endif
		
			If File(m.lcFile)
				lnResponse = Messagebox("File [" + m.lcFile + "] exists. Overwrite?", 3, "Overwrite file?")
				If m.lnResponse # 6
					Return
				Endif
			Endif
		Else
			lcFile = "GFResults.TMP" && awkward, but results from incomplete refactoring (used to indicate cursor by using TMP extension)
		Endif
		
		lcFile = Upper(m.lcFile)
		
		lnSelect		= Select()
		lcResultsCursor	= This.cSearchResultsAlias
		
		Dimension m.laFields[1, 2]
		lcFieldList	= ""
		lnX			= 1
		
		*-- First choose visible columns
		For Each m.loColumn In Thisform.oGrid.Columns
			If m.loColumn.Visible
				If m.lnX > 1
					Dimension m.laFields[m.lnX, 2]
				Endif
				laFields[m.lnX, 1] = Transform(m.loColumn.ColumnOrder, "999")
				laFields[m.lnX, 2] = GetWordNum(m.loColumn.ControlSource, 2, '., )')
				lnX				   = m.lnX + 1
			Endif
		Endfor
		
		= Asort(m.laFields)
		
		For Each m.loColumn In Thisform.oGrid.Columns
			If !m.loColumn.Visible
				If m.lnX > 1
					Dimension m.laFields[m.lnX, 2]
				Endif
				laFields[m.lnX, 1] = Transform(m.loColumn.ColumnOrder, "999")
				laFields[m.lnX, 2] = GetWordNum(m.loColumn.ControlSource, 2, '., )')
				lnX				   = m.lnX + 1
			Endif
		ENDFOR
		
		For lnX = 1 To Alen(m.laFields) / 2
			If Not Empty(m.lcFieldList)
				lcFieldList = m.lcFieldList + ","
			Endif
			lcFieldList = m.lcFieldList + m.laFields[m.lnX, 2]
		Endfor
		
		lcFilter = Filter(m.lcResultsCursor)
		
		If Not Empty(m.lcFilter)
			lcFilter = "Where " + m.lcFilter
		Endif
		
		If Not Empty(Thisform.cOrderBy)
			lcOrderBy = "Order By " + Thisform.cOrderBy
		Else
			lcOrderBy = ""
		Endif
		
		lcExportCursor = "ResultForExcelExport"
		
		Do Case
			Case Justext(m.lcFile) =  "DBF"
				Select  &lcFieldList								;
					From &lcResultsCursor &lcFilter &lcOrderBy		;
					Into Table (m.lcFile)
				Use
				Messagebox([Exported to "] + m.lcFile + ["])
		
			Case Justext(m.lcFile) =  "XLSX"
				Select  &lcFieldList								;
					From &lcResultsCursor &lcFilter &lcOrderBy		;
					Into Cursor &lcExportCursor && Readwrite
		
				loExport = Createobject("CreateExports", Set("Datasession"))
				lcName	 = m.loExport.ExportToExcel(m.lcExportCursor, m.lcFile)
		
			Case Justext(m.lcFile) =  "TMP"
				lcTempTable = Addbs(Sys(2023)) + "Cursor" + Sys(2015) + ".DBF"
				Select  &lcFieldList								;
					From &lcResultsCursor &lcFilter &lcOrderBy		;
					Into Table (m.lcTempTable)
				Use
		
				loExport	 = Createobject("CreateExports", 1)
				lcCursorName = Juststem(m.lcFile)
				lcName		 = m.loExport.ExportToCursor(m.lcTempTable, m.lcCursorName)
				Messagebox([Exported to cursor "] + m.lcName + ["])
		
		Endcase
		
		Select (m.lnSelect)
		
	ENDPROC

	PROCEDURE fillsearchresultscursor
		Lparameters;
			tlAppend,;
			tcUni
		
		Local;
			lcCollate               As String,;
			lcOrderBy               As String,;
			lcSearchEngineResultsAlias As String,;
			lcSearchResultsAlias    As String,;
			llReturn                As Boolean,;
			lnSelect                As Number,;
			loException             As Object
		
		lcSearchEngineResultsAlias = Thisform.oSearchEngine.cSearchResultsAlias
		lcSearchResultsAlias       = Thisform.cSearchResultsAlias
		
		lnSelect  = Select()
		*lcOrderBy = ""
		llReturn  = .T.
		
		*!*	*** JRN 11/06/2015 : using !Empty(Field( to provide for case of changed field names in GF 5
		*!*	*-- Construct Order By clause for Select statement from stored form property
		*!*	If !Empty(Thisform.cSortField) And !Empty(Field(Thisform.cSortField, m.lcSearchEngineResultsAlias))
		*!*		lcSortField = Thisform.cSortField
		*!*		lcSortOrder = Thisform.cSortOrder
		*!*		If (Empty(m.lcSortOrder) Or ("ASC" $ Upper(m.lcSortOrder)))
		*!*			lcSortOrder = "ASC"
		*!*		Endif
		*!*		lcOrderBy = m.lcSortField + " " + m.lcSortOrder
		*!*	Endif
		
		*!*	If !Empty(Thisform.cSortFieldSecondary) And !Empty(Field(Thisform.cSortFieldSecondary, m.lcSearchEngineResultsAlias))
		*!*		lcSecondarySortField = Thisform.cSortFieldSecondary
		*!*		lcSecondarySortOrder = Thisform.cSortOrderSecondary
		*!*		If (Empty(m.lcSecondarySortOrder) Or ("ASC" $ Upper(m.lcSecondarySortOrder)))
		*!*			lcSecondarySortOrder = "ASC"
		*!*		Endif
		*!*		lcOrderBy = m.lcOrderBy + ", " + m.lcSecondarySortField + " " + m.lcSecondarySortOrder
		*!*	Endif
		
		*!*	If !Empty(Thisform.cSortFieldTertiary) And !Empty(Field(Thisform.cSortFieldTertiary, m.lcSearchEngineResultsAlias))
		*!*		lcTertiarySortField = Thisform.cSortFieldTertiary
		*!*		lcTertiarySortOrder = Thisform.cSortOrderTertiary
		*!*		If (Empty(m.lcTertiarySortOrder) Or ("ASC" $ Upper(m.lcTertiarySortOrder)))
		*!*			lcTertiarySortOrder = "ASC"
		*!*		Endif
		*!*		lcOrderBy = m.lcOrderBy + ", " + m.lcTertiarySortField + " " + m.lcTertiarySortOrder
		*!*	Endif
		
		*!*	If Empty(m.lcOrderBy)
		*!*		lcOrderBy           = "filename, class, name, methodname"
		*!*		Thisform.cSortField = Getwordnum(m.lcOrderBy, 1, ",")
		*!*	Else
		*!*		lcOrderBy = Alltrim(m.lcOrderBy, 1, ",")
		*!*	Endif
		
		*!*	Thisform.cOrderBy = m.lcOrderBy
		
		*!*	*-- Make header bold for primary sort column
		*!*	If Thisform.lInit
		*!*		For Each m.loColumn In Thisform.oGrid.Columns
		*!*			loColumn.header1.FontBold = .F.
		*!*			lcField                   = Getwordnum(m.loColumn.ControlSource, 2, ".")
		*!*			If Upper(m.lcField) = Upper(Getwordnum(m.lcOrderBy, 1, ", "))
		*!*				loColumn.header1.FontBold = .T.
		*!*			Endif
		*!*		Endfor
		*!*	Endif
		
		*-- This gives us case insensitive sorting...
		lcCollate = Set("Collate")
		Try
				Set Collate To "General"
			Catch To m.loException
		
		Endtry
		
		*!*	If !"filepath "$Lower(m.lcOrderBy) Then
		*!*		lcOrderBy =  "filepath," + m.lcOrderBy
		*!*	Endif &&!"filepath "$Lower(m.lcOrderBy)
		
		*!*	If !Empty(Field("datetime",m.lcSearchEngineResultsAlias)) Then
		*!*		lcOrderBy =  "datetime ," + m.lcOrderBy
		*!*	Endif &&!Empty(Field("datetime",m.lcSearchEngineResultsAlias))
		
		*!*	If !"filename "$Lower(m.lcOrderBy) Then
		*!*		lcOrderBy = m.lcOrderBy + ",filename "
		*!*	Endif &&!"filename "$Lower(m.lcOrderBy)
		*!*	If !"class "$Lower(m.lcOrderBy) Then
		*!*		lcOrderBy = m.lcOrderBy + ",class "
		*!*	Endif &&!"class "$Lower(m.lcOrderBy)
		*!*	If !"name "$Lower(m.lcOrderBy) Then
		*!*		lcOrderBy = m.lcOrderBy + ",name "
		*!*	Endif &&!"name "$Lower(m.lcOrderBy)
		*!*	If !"methodname "$Lower(m.lcOrderBy) Then
		*!*		lcOrderBy = m.lcOrderBy + ",methodname "
		*!*	Endif &&!"methodname "$Lower(m.lcOrderBy)
		*!*	If !"matchstart "$Lower(m.lcOrderBy) Then
		*!*		lcOrderBy = m.lcOrderBy + ",MatchStart "
		*!*	Endif &&!"matchstart "$Lower(m.lcOrderBy)
		
		lcOrderBy = This.Get_ResultOrderBy()
		
		If Reccount(m.lcSearchEngineResultsAlias)=0 Then
			tcUni = ""
		Else  &&RECCOUNT(m.lcSearchEngineResultsAlias)=0
			Select (m.lcSearchEngineResultsAlias)
			Go Bottom
			tcUni = cUni
		Endif &&RECCOUNT(m.lcSearchEngineResultsAlias)=0
		
		*-- Create the local cursor if it does not already exist -----------------------
		If !Used(m.lcSearchResultsAlias)
		*	Select *;
		From (Select *;
		From (m.lcSearchEngineResultsAlias);
		Order By &lcOrderBy) Source ;
		Into Cursor (m.lcSearchResultsAlias) Readwrite
		
				Try
		*Was zu testen ist
			Select *;
			 From (m.lcSearchEngineResultsAlias);
			 Into Cursor (m.lcSearchResultsAlias) Readwrite;
			 Order By &lcOrderBy
		
		
					Catch To m.loException When m.loException.ErrorNo=1808
						Messagebox("Error sorting, all sort fields reset to default",0,"GoFish")
		* Error to catch, ORDER BY is invalid
		* we asssume an odd field like memo is used
		*reset the sort fields
						Store "" To;
							Thisform.cSortField,;
							Thisform.cSortOrder,;
							Thisform.cSortFieldSecondary,;
							Thisform.cSortOrderSecondary,;
							Thisform.cSortFieldTertiary,;
							Thisform.cSortOrderTertiary
		*Get OrderBy again
						lcOrderBy = This.Get_ResultOrderBy()
		*Rerun
			Select *;
			 From (m.lcSearchEngineResultsAlias);
			 Into Cursor (m.lcSearchResultsAlias) Readwrite;
			 Order By &lcOrderBy
		
					Catch
						Throw
					Finally
		*
				Endtry
		
		Else && Otherwise, Zap it and rebuild from GFSE cursor...
		
			If m.tlAppend Then
				Try
						*!* ******** JRN Removed 2024-02-23 ********
						*!* Update (m.lcSearchResultsAlias) Set;
						*!*  ReplaceRisk = 100
						Insert Into (m.lcSearchEngineResultsAlias);
							Select;
							 Cur1.*;
							 From (m.lcSearchResultsAlias) As Cur1
					Catch To m.loException
						Messagebox("Failure restoring old search.",0+64,"GoFish",10000)
						llReturn = .F.
				Endtry
			Endif &&m.tlAppend
		
			If m.llReturn Then
				Thisform.ClearSearchResultsCursor() && Zap it
		*-- Build a temp local cursor in correct initial order
		
		*TODO: The orderby clause here could fail since some field names were changed
		*      in relase 4.3.015. Need to handle this...
		*		Select *;
		From (Select *;
		From (m.lcSearchEngineResultsAlias);
		Order By &lcOrderBy) Source ;
		Into Cursor gf_temp_csr Readwrite
		
				Try
		*Was zu testen ist
						Select *;
						 From (m.lcSearchEngineResultsAlias);
						 Into Cursor gf_temp_csr Readwrite;
						 Order By &lcOrderBy
		
		
					Catch To m.loException When m.loException.ErrorNo=1808
						Messagebox("Error sorting, all sort fields reset to default",0,"GoFish")
		* Error to catch, ORDER BY is invalid
		* we asssume an odd field like memo is used
		*reset the sort fields
						Store "" To;
							Thisform.cSortField,;
							Thisform.cSortOrder,;
							Thisform.cSortFieldSecondary,;
							Thisform.cSortOrderSecondary,;
							Thisform.cSortFieldTertiary,;
							Thisform.cSortOrderTertiary
		*Get OrderBy again
						lcOrderBy = This.Get_ResultOrderBy()
		*Rerun
						Select *;
						 From (m.lcSearchEngineResultsAlias);
						 Into Cursor gf_temp_csr Readwrite;
						 Order By &lcOrderBy
		
					Catch
						Throw
					Finally
		*
				Endtry
		
		*-- Update local cursor in order that user has applied
		*!* ******************** Removed 11/09/2015 *****************
		*!* Insert Into (lcSearchResultsAlias) Select * From gf_temp_csr
				Select (m.lcSearchResultsAlias)
				Append From (Dbf("gf_temp_csr"))
			Endif &&m.llReturn
		Endif
		
		Use In Select ("gf_temp_csr")
		
		Set Collate To (m.lcCollate)
		
		Select (m.lcSearchResultsAlias)
		Goto Top
		
		Select (m.lnSelect)
		
		Return m.llReturn
		
	ENDPROC

	PROCEDURE filtergfse
		Local lcFilter
		
		lcFilter = Filter(this.cSearchResultsAlias)         
		Set Filter To &lcFilter in (This.oSearchEngine.cSearchResultsAlias)
		 
	ENDPROC

	PROCEDURE fixcolumnheadings
		Local loColumn
		
		For Each m.loColumn In This.oGrid.Columns FoxObject
			If Atc('filepath', m.loColumn.ControlSource) # 0
				loColumn.Header1.Caption = Iif(Thisform.lShowRelativePath, 'Path relative to Scope', 'Full Path')
			Endif
		Endfor
		
		loColumn = Null
		
	ENDPROC

	PROCEDURE focusonreplacepageframe
		Local loReplacePageframe
		loReplacePageframe = This.Containerright.Container1.containerReplaceText.PageFrame
		
		Do Case
			Case Thisform.nReplaceMode = 1
				*hide the pgf
			Case Thisform.nReplaceMode = 2
				m.loReplacePageframe.Page1.editReplaceExpression.SetFocus()
			Case Thisform.nReplaceMode = 3
				m.loReplacePageframe.Page2.editReplaceLine.SetFocus()
			Case Thisform.nReplaceMode = 4
				m.loReplacePageframe.Page3.cmdBrowse.SetFocus()
			Case Thisform.nReplaceMode = 5
				*hide the pgf
		Endcase
		
		*switch the pgf
		
	ENDPROC

	PROCEDURE formatgrid
		*-- This method provides basic grid formatting when form is first launched,
		*-- then, in the Form.Init(), the user settings will be loaded, which will
		*-- restore column width and column order based on usee's last sesssion.
		
		*switch all Fields (.T.) on, else only a limited range is in options
		#Define dlDebug .F.
		
		Local;
			lcControlSourceField As String,;
			lcDynamicBackColor As String,;
			lcSearchResultsAlias As String,;
			lnColumn          As Number,;
			lnRow             As Number,;
			loColumn          As Object,;
			loGrid            As Grid
		
		Local Array;
			laFields(44, 6)
		
		lnRow = 01
		
		*!*	laFields:
		*!*	(m.lnRow, 1) = controlsource
		*!*	(m.lnRow, 2) = Default column order
		*!*	(m.lnRow, 3) = Caption, if emptyas controlsource
		*!*	(m.lnRow, 4) = Usage:
		*!*	 <0: only if dlDebug is .T., no column in the grid
		*!*	 -2: Group "Control" in options control fields, not visible as default, only if dlDebug is .T.
		*!*	 -1: Group "Debug" in options, not visible as default, only if dlDebug is .T.
		*!*	  0: Group "Default" in options, visible as default
		*!*	  1: Alternative group #1 in options, not visible as default
		*!*	  2: Alternative group #2 in options, not visible as default
		*!*	  3: Replace group disabled in options, visibility will switch with replace mode
		*!*	  4: Replace group enabled in options, not visible as default
		*!*	(m.lnRow, 5) = column.width
		
		*default
		laFields(m.lnRow, 1) = "FILENAME"
		laFields(m.lnRow, 2) = 02
		laFields(m.lnRow, 3) = "File Name"
		laFields(m.lnRow, 4) = 0
		laFields(m.lnRow, 5) = 200
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "TRIMMEDMATCHLINE"
		laFields(m.lnRow, 2) = 07
		laFields(m.lnRow, 3) = "Match Line"
		laFields(m.lnRow, 4) = 0
		laFields(m.lnRow, 5) = 300
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "CLASS"
		laFields(m.lnRow, 2) = 03
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = 0
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "NAME"
		laFields(m.lnRow, 2) = 04
		laFields(m.lnRow, 3) = "Object Name"
		laFields(m.lnRow, 4) = 0
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "METHODNAME"
		laFields(m.lnRow, 2) = 06
		laFields(m.lnRow, 3) = "Method/Property Name"
		laFields(m.lnRow, 4) = 0
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "CONTAININGCLASS"
		laFields(m.lnRow, 2) = 05
		laFields(m.lnRow, 3) = "Containing Class"		&&Object Class
		laFields(m.lnRow, 4) = 0
		laFields(m.lnRow, 5) = 0
		*secondary
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "FILEPATH"
		laFields(m.lnRow, 2) = 10
		laFields(m.lnRow, 3) = "Full Path"
		laFields(m.lnRow, 4) = 1
		laFields(m.lnRow, 5) = 200
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "BASECLASS"
		laFields(m.lnRow, 2) = 11
		laFields(m.lnRow, 3) = "Base Class"
		laFields(m.lnRow, 4) = 1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "PARENTCLASS"
		laFields(m.lnRow, 2) = 12
		laFields(m.lnRow, 3) = "Parent Class"
		laFields(m.lnRow, 4) = 1
		laFields(m.lnRow, 5) = 0
		*tertiary
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "CLASSLOC"
		laFields(m.lnRow, 2) = 13
		laFields(m.lnRow, 3) = "Parent Class VCX"
		laFields(m.lnRow, 4) = 2
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "MATCHTYPE"
		laFields(m.lnRow, 2) = 14
		laFields(m.lnRow, 3) = "Match Type"
		laFields(m.lnRow, 4) = 2
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "FILETYPE"
		laFields(m.lnRow, 2) = 15
		laFields(m.lnRow, 3) = "Ext"
		laFields(m.lnRow, 4) = 2
		laFields(m.lnRow, 5) = 0
		*replace
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "PROCESS"
		laFields(m.lnRow, 2) = 01
		laFields(m.lnRow, 3) = "Replace"
		laFields(m.lnRow, 4) = 3
		laFields(m.lnRow, 5) = 50
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "TRIMMEDREPLACELINE"
		laFields(m.lnRow, 2) = 08
		laFields(m.lnRow, 3) = "Replace Line"
		laFields(m.lnRow, 4) = 3
		laFields(m.lnRow, 5) = 200
		
		*control fields (hidden)
		lnRow = m.lnRow+1	&&14
		laFields(m.lnRow, 1) = "CUNI"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -2
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "CUNI_FILE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -2
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "DATETIME"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Searched at"
		laFields(m.lnRow, 4) = -2
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "SCOPE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Scope"
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "SEARCH"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Search expr."
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "LMEMLOADED"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "File loaded"
		laFields(m.lnRow, 4) = -2
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "TIMESTAMP"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "File/Record time stamp"
		laFields(m.lnRow, 4) = 1
		laFields(m.lnRow, 5) = 125
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "TYPE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "RECNO"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "PROCSTART"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "PROCEND"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "PROCCODE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "STATEMENT"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "STATEMENTSTART"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "FIRSTMATCHINSTATEMENT"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "FIRSTMATCHINPROCEDURE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "MATCHSTART"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "MATCHLEN"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "LISTEXT"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "COLUMN"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "CODE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "ID"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -2
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "MATCHLINE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "REPLACED"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Replaced"
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "REPLACELINE"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = ""
		laFields(m.lnRow, 4) = 4
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "REPLACERISK"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Replace risk"
		laFields(m.lnRow, 4) = 4
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "REPLACE_DT"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Replaced at"
		laFields(m.lnRow, 4) = 4
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "iReplaceFolder"
		laFields(m.lnRow, 2) = 09
		laFields(m.lnRow, 3) = "Backup Folder"
		laFields(m.lnRow, 4) = 4
		laFields(m.lnRow, 5) = 80
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "lSaved"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Saved"
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 0
		
		lnRow = m.lnRow+1
		laFields(m.lnRow, 1) = "lJustReplace"
		laFields(m.lnRow, 2) = m.lnRow
		laFields(m.lnRow, 3) = "Only Replaced Saved"
		laFields(m.lnRow, 4) = -1
		laFields(m.lnRow, 5) = 120
		
		loGrid               = Thisform.oGrid
		lcSearchResultsAlias = Thisform.cSearchResultsAlias
		
		Thisform.oGrid.ArrangeColumns()
		
		*-- Now, override a few Header captions so they'll read better ------------------
		*-- Note: Any "Visible = .f." settings assigned here oly affect GF the first time it is ever used.
		*         After first use, the XML settings files take over this visibility of columns.
		
		*-- Set Header captions from Field name -----------------
		For lnColumn = m.loGrid.ColumnCount To 1 Step -1
			loColumn             = loGrid.Columns(m.lnColumn)
			lcControlSourceField = Proper(Getwordnum(m.loColumn.ControlSource, 2, "."))
			lnRow                = Ascan(m.laFields, m.lcControlSourceField, -1, -1, 1, 15)
			If Empty(m.lnRow) Or (laFields(m.lnRow, 4)<0 And !dlDebug) Then
				lcControlSourceField = m.loColumn.Name
				loColumn = .Null.
		*		loGrid.DeleteColumn(m.lnColumn)
				loGrid.RemoveObject(m.lcControlSourceField)
		*		lnColumn = m.lnColumn-1
				Loop
				laFields(m.lnRow, 6) = .Null.
			Endif &&Empty(m.lnRow) Or (laFields(m.lnRow, 4)<0 AND !dlDebug)
		
			laFields(m.lnRow, 6)        = laFields(m.lnRow, 4)=0
			loColumn.Width             = Evl(laFields(m.lnRow, 5), 100)
			AddProperty(loColumn, "gnWidth", loColumn.Width)
			AddProperty(loColumn, "gnLevel", laFields(m.lnRow, 4))
			loColumn.Visible           = laFields(m.lnRow, 6)
			laFields(m.lnRow, 3)       = Evl(laFields(m.lnRow, 3), m.lcControlSourceField)
			loColumn.Header1.Caption   = laFields(m.lnRow, 3)
			loColumn.Header1.Alignment = 0
			loColumn.Header1.Tag       = m.lcControlSourceField  && Save ControlSource on tag so Options form can access it.
		Endfor &&lnColumn
		
		*** JRN 2024-02-06 : Show relative path (to the scope) instead of full path
		loColumn = loGrid.FindColumn('Filepath')
		loColumn.ControlSource = [GF_RelativePath(csrsummarysearchresults.filepath, Thisform, Thisform.oSearchEngine.oSearchOptions)]
		
		loGrid.ReadOnly = .F.
		loGrid.SetAll("ReadOnly", .T., "Column")
		loGrid.SetAll("Movable", .T., "Column") 
		
		loColumn = loGrid.FindColumn("Process")
		loColumn.Alignment = 2
		loColumn.ReadOnly  = .F.
		loColumn.Sparse    = .F.
		
		loColumn.Newobject("Check1", "gf_Check", "GoFishUI.vcx")
		loColumn.Check1.Visible = .T.
		
		loColumn.AddObject("Label1", "Label")
		loColumn.Label1.Caption = ""
		loColumn.Label1.Visible = .T.
		
		loColumn.AddObject("imageCheck", "Image")
		loColumn.imageCheck.Picture = "check.bmp"
		loColumn.imageCheck.Visible = .T.
		
		lnColumn = Alen(m.laFields, 1)
		For lnRow = m.lnColumn To 1 Step -1
			If Isnull(laFields(m.lnRow, 6)) Then
				Adel(m.laFields, m.lnRow)
				lnColumn = m.lnColumn-1
			Endif &&ISNULL(laFields(m.lnRow, 6))
		Endfor &&lnRow
		
		If !Empty(m.lnColumn) Then
			Dimension;
				laFields(m.lnColumn, Alen(m.laFields, 2))
			Asort(m.laFields,2,-1,0)
			For lnRow = 1 To m.lnColumn To 1
				loColumn = loGrid.FindColumn(laFields(m.lnRow, 1))
				If !Isnull(m.loColumn) Then
					loColumn.ColumnOrder = laFields(m.lnRow, 2)
				Endif &&!ISNULL(m.loColumn)
			Endfor &&lnRow
		Endif &&!EMPTY(m.lnColumn)
		
		Dimension;
			this.gaFields(Alen(laFields, 1), Alen(laFields, 2))
		
		Acopy(laFields,This.gaFields)
		
		THIS.Set_GridColour()
		This.FormatProcessColumn()
		
	ENDPROC

	PROCEDURE formatgridforreplacemode
		Local llReplaceMode, lnOrder, lnWidth, loColumn
		
		IF !Thisform.lInit
		 Return
		ENDIF &&!Thisform.lInit 
		
		llReplaceMode = Thisform.lReplaceViewMode AND INLIST(Thisform.nReplaceMode,2,3,4)
		
		loSourceColumn = This.ogrid.FindColumn("TrimmedMatchline")
		
		loColumn		 = This.ogrid.FindColumn("TrimmedReplaceline")
		loColumn.Visible = m.llReplaceMode
		loColumn.Width	 = m.loSourceColumn.Width
		IF m.llReplaceMode THEN
			loColumn.ColumnOrder = loSourceColumn.ColumnOrder+1
		ENDIF &&m.llReplaceMode 
		
		*!*	Do While m.loColumn.ColumnOrder # m.loSourceColumn.ColumnOrder + 1
		*!*		If m.loColumn.ColumnOrder < m.loSourceColumn.ColumnOrder
		*!*			loColumn.ColumnOrder = m.loColumn.ColumnOrder + 1
		*!*		Else
		*!*			loColumn.ColumnOrder = m.loColumn.ColumnOrder - 1
		*!*		Endif
		*!*	Enddo
		
		loColumn		 = This.ogrid.FindColumn("Process")
		loColumn.Visible = m.llReplaceMode&& and (Thisform.nReplaceMode # 3)
		loColumn.Width	 = 50
		
		IF m.llReplaceMode THEN
			loColumn.ColumnOrder = 1
		ENDIF &&m.llReplaceMode 
		*!*	Do While m.loColumn.ColumnOrder + 1 # m.loSourceColumn.ColumnOrder
		*!*		If m.loColumn.ColumnOrder < m.loSourceColumn.ColumnOrder
		*!*			loColumn.ColumnOrder = m.loColumn.ColumnOrder + 1
		*!*		Else
		*!*			loColumn.ColumnOrder = m.loColumn.ColumnOrder - 1
		*!*		Endif
		*!*	Enddo
		
		Thisform.oGrid.Refresh() && This is important to get the Grid to hide the above columns be next method call.
		
		* ================================================================================
		* ================================================================================
		
		
		*!* ******************** Removed 10/28/2015 *****************
		*!* *-- In Replace Mode, we will show the Replace checkboc column to the left of the Match column,
		*!* *-- and the Replace Line column to the right of it. Hide these 2 columns if we are not in Replace Mode
		
		*!* *-- Finf the Match Line Column ---
		*!* loColumn = This.oGrid.FindColumn("TrimmedMatchline")
		*!* lnOrder = loColumn.ColumnOrder
		*!* lnWidth = loColumn.Width
		
		
		*!* *-- Work on the the Replace Line column...
		*!* loColumn = This.oGrid.FindColumn("TrimmedReplaceline")
		*!* This.ShowGridColumn(llReplaceMode, loColumn, lnOrder + 1, lnWidth)
		
		*!* *-- Work on the Replace Checkbox column...
		*!* loColumn = This.oGrid.FindColumn("Process")
		*!* This.ShowGridColumn(llReplaceMode, loColumn, lnOrder, 50)
		
		*!* Thisform.oGrid.Refresh() && This is important to get the Grid to hide the above columns be next method call.
		
		*!* Thisform.oGrid.ArrangeColumns()
		
		
		     
	ENDPROC

	PROCEDURE formatprocesscolumn
		Local lcReplaceColumnDynamicBackgroundColor, lcReplaceColumnDynamicCurrentControl, loColumn
		
		*-- This method is called from the GRid.Init() *AND* must be called after every search becuase I had trouble where the Replace checkboxes
		*-- would quit working after a search, in certain situtations. Re-applying the DynamicCurrentControl setting here fixed the problem.
		
		loColumn = This.oGrid.FindColumn("Process")
		
		*Thisform.nReplaceRisk = 99
		
		lcReplaceColumnDynamicCurrentControl = [ICase(replaced = .t., "imageCheck", (replacerisk <= Thisform.nReplaceRisk) and (Thisform.nReplaceMode # 3), "check1", "label1")]
		*SF 20221016 added colour options
		*lcReplaceColumnDynamicBackgroundColor = "ICase(replacerisk = 2, RGB(255,255,128), replacerisk = 3 and Thisform.nReplaceRisk = 3, Rgb(255,192,0), Rgb(255,255,255))"
		
		lcReplaceColumnDynamicBackgroundColor = "ICase(" +;
			"replacerisk = 1, " + Padr(Thisform.nRisk1DynamicBackColour,8) + ", "
		
		If Thisform.nReplaceRisk > 1 Then
			lcReplaceColumnDynamicBackgroundColor = lcReplaceColumnDynamicBackgroundColor +;
				"replacerisk = 2, " + Padr(Thisform.nRisk2DynamicBackColour,8) + ", "
		Endif &&Thisform.nReplaceRisk > 1
		
		If Thisform.nReplaceRisk > 2 Then
			lcReplaceColumnDynamicBackgroundColor = lcReplaceColumnDynamicBackgroundColor +;
				"replacerisk = 3, " + Padr(Thisform.nRisk2DynamicBackColour,8) + ", "
		Endif &&Thisform.nReplaceRisk > 2
		
		
		lcReplaceColumnDynamicBackgroundColor = lcReplaceColumnDynamicBackgroundColor +;
			Padr(Thisform.nRiskExceededDynamicBackColour,8) + " )"
		*/ SF 20221016 added colour options
		
		If This.lInit
			Thisform.oGrid.SetFocus() && It's important for the grid to have focus as these next settings below are applied
		Endif
		
		loColumn.DynamicCurrentControl = lcReplaceColumnDynamicCurrentControl
		loColumn.DynamicBackColor = lcReplaceColumnDynamicBackgroundColor
		
	ENDPROC

	PROCEDURE getcurrentscope		&& Will return the Active Project, Browsed Project, Current Dir, or Browsed Dir depending on current setting of nSearchScope (Values: 1 through 4)
		Local lcScope, lnScope
		
		*   0 = Not set
		*	1 = Active Project
		*	2 = Browse Project
		*	3 = Current Dir
		*	4 = Browse Directory
		*	5 = A Selection from the Scope combo
		*	6 = All open projects
		
		lnScope = Thisform.oSearchOptions.nSearchScope
		
		Do Case
		
			Case m.lnScope = 1 && Active Project
				lcScope = Thisform.cActiveProject
		
			Case m.lnScope = 6 && All Open Projects
				lcScope = Thisform.cActiveProject
		
			Case m.lnScope = 2 && Browsed Project
				lcScope = This.oSearchOptions.cProject
		
			Case m.lnScope = 3 && Current Directory
				lcScope = Thisform.cCurrentDir
		
			Case m.lnScope = 4  && Browsed Directory
				lcScope = This.oSearchOptions.cPath
		
			Case m.lnScope = 0 Or m.lnScope = 5
				lcScope = Alltrim(Thisform.comboSearchScopeHistory.Text)
		
				If Empty(m.lcScope)
					lcScope = Thisform.cCurrentDir
				Endif
		
		Endcase
		
		lcScope	= Alltrim(m.lcScope)
		lcScope	= Rtrim(m.lcScope, '\')
		
		Return m.lcScope
	ENDPROC

	PROCEDURE getcustomcss
		Local laFoxOptions[1], laValue[1], lcBackColor, lcCssFile, lcCssText, lcForeColor, lcRGB
		Local lcReplacement, lcSetting, lnErrNum, lnPos, loReg
		
		*** JRN 2024-02-05 : 
		* Get custom CSS used for setting colors in the 'Code View' window in an
		* attempt to make it match (as much as possible) a user's normal code window
		* Note, that the color for "Variables" is not used, per recommandations in
		* gofish_registry.prg, as this presumably makes it run too slow (unverified)
		
		Dimension m.laFoxOptions[1, 2]
		
		If Not Isnull(Thisform.cCustomCss)
			Return Thisform.cCustomCss
		Endif
		
		Thisform.cCustomCss	= ''
		
		lcCssFile = _Screen._GoFish.cAppPath + 'CSS\GoFish_User.css'
		If Not File(m.lcCssFile)
			Return ''
		Endif
		
		loReg	 = Newobject('FoxReg', 'lib\gofish_registry.prg')
		lnErrNum = m.loReg.EnumFoxOptions(@m.laFoxOptions)
		Create Cursor Fox_Settings (Setting C(40), Value C(250))
		Append From Array m.laFoxOptions
		
		lcCssText = Filetostr(m.lcCssFile)
		Do While .T.
			lcSetting = Strextract(m.lcCssText, '<<', '>>', 1, 0)
			If Empty(m.lcSetting)
				Use In Fox_Settings
				Thisform.cCustomCss = m.lcCssText
				Return m.lcCssText
			Else
				Select  Trim(Value)									;
					From Fox_Settings								;
					Where Upper(Setting) = Upper(m.lcSetting)		;
					Into Array laValue
				If _Tally = 0
					laValue = 'RGB(0, 0, 0, 255, 255, 255)'
				Endif
				lcRGB = Strextract(m.laValue, 'RGB(', ')', 1, 1)
				lnPos = At(',', m.lcRGB, 3)
		
				lcReplacement = ''
				lcForeColor	= Left(m.lcRGB, m.lnPos - 1)
				If Rgb(&lcForeColor) # Rgb(0, 0, 0)
					lcReplacement = Textmerge('color: rgb(<<m.lcForeColor>>);')
				Endif
		
				lcBackColor	= Substr(m.lcRGB, m.lnPos + 1)
				If Rgb(&lcBackColor) # Rgb(255, 255, 255)
					lcReplacement = m.lcReplacement + Textmerge('background-color: rgb(<<m.lcBackColor>>);')
				Endif
		
				lcCssText = Strtran(m.lcCssText, '<<' + m.lcSetting + '>>', m.lcReplacement)
		
			Endif && Empty(lcSettings)
		Enddo && While .T.
		
		
	ENDPROC

	PROCEDURE getfilter		&& Read filter settings of the form
		Local lcFilter
		
		If This.lApplyFilter
			lcFilter = Evl(Thisform.cFilter, "")
		Else
			lcFilter = ""
		Endif
		
		Do Case
			Case Thisform.lCodeOnly = .F.
		
			Case Empty(m.lcFilter)
				lcFilter = [MatchType = "Code"]
			Otherwise
				lcFilter = [MatchType = "Code" and ] + m.lcFilter
		Endcase
		
		Return m.lcFilter
		
	ENDPROC

	PROCEDURE getlastsavedresultsfolder
		Local laDirs[1], lcDir, lcFolder, lcName, lcRoot, lnAlen
		
		lcName = Thisform.cSavedSearchResultsFolder
		*SF 20221017, Special local settings. 
		*lcRoot = Home(7) + lcName
		lcRoot = This.cCR_StoreLocal + lcName
		*/SF 20221017, Special local settings. 
		
		ADir(laDirs, Addbs(lcRoot) + "*","D",1)
		
		If Type("laDirs") $ "UL"
			Return ""
		EndIf
		
		lnAlen = Alen(laDirs) / 5
		
		*-- Get the last one in the list...
		lcDir = laDirs[lnAlen, 1]
		
		lcFolder = Addbs(lcRoot) + Addbs(lcDir)
		
		Return lcFolder
		
		
	ENDPROC

	PROCEDURE get_onodetag		&& Create object for node tag.
		Lparameters;
			tcLevel,;
			tcUni,;
			tcSearch,;
			tcScope,;
			tcExt,;
			tcFilter,;
			tcFilePath,;
			tcFileName,;
			tcFileExt,;
			tcClass,;
			tlNeedFill
		
		Local;
			loTag As "Empty"
		
		loTag = Createobject("Empty")
		
		AddProperty(m.loTag,"gcLevel"   ,m.tcLevel         )
		AddProperty(m.loTag,"gcUni"     ,m.tcUni           )
		AddProperty(m.loTag,"gcSearch"  ,m.tcSearch        )
		AddProperty(m.loTag,"gcScope"   ,m.tcScope         )
		AddProperty(m.loTag,"gcExt"     ,m.tcExt           )	&& *
		AddProperty(m.loTag,"gcFilter"  ,m.tcFilter        )
		AddProperty(m.loTag,"gcFilePath",LOWER(m.tcFilePath))
		AddProperty(m.loTag,"gcFileName",LOWER(m.tcFileName))
		AddProperty(m.loTag,"gcFileExt" ,LOWER(m.tcFileExt ))	&& *
		AddProperty(m.loTag,"gcClass"   ,LOWER(m.tcClass   ))
		AddProperty(m.loTag,"glNeedFill",m.tlNeedFill      )
		
		Return m.loTag
		
	ENDPROC

	PROCEDURE get_replaceid		&& Determine the next ID to create a backup replace folder.
		Lparameters;
			tlPreviewReplace
		
		Local;
			liID  As Integer,;
			lnSelect As Number
		
		liID = 0
		
		If Thisform.oSearchEngine.oSearchOptions.lBackup
			lnSelect = Select()
		
			Thisform.SaveDBC_Open()
		
			Select 0
			Use GF_ReplaceID
			liID = iID+Iif(m.tlPreviewReplace, 0, 1)
		    Replace;
		     iID With m.liID
			Use
		
			Thisform.SaveDBC_Close()
		
			Select(m.lnSelect)
		Endif &&Thisform.oSearchEngine.oSearchOptions.lBackup
		
		Return m.liID
		
	ENDPROC

	PROCEDURE get_resultorderby		&& Get the Order By clause for the reult cursor
		Local;
			lcField                 As String,;
			lcOrderBy               As String,;
			lcSearchEngineResultsAlias As String,;
			lcSortField             As String,;
			lcSortOrder             As String,;
			lnLen                   As Number,;
			lnPos                   As Number,;
			loColumn                As Object
		
		lcSearchEngineResultsAlias = Thisform.oSearchEngine.cSearchResultsAlias
		
		lcOrderBy = ""
		
		*** JRN 11/06/2015 : using !Empty(Field( to provide for case of changed field names in GF 5
		*-- Construct Order By clause for Select statement from stored form property
		If !Empty(Thisform.cSortField) And !Empty(Field(Thisform.cSortField, m.lcSearchEngineResultsAlias))
			lcSortField = Thisform.cSortField
			lcSortOrder = Thisform.cSortOrder
			If (Empty(m.lcSortOrder) Or ("ASC" $ Upper(m.lcSortOrder)))
				lcSortOrder = "ASC"
			Endif
			lcOrderBy = m.lcSortField + " " + m.lcSortOrder
		Endif
		
		If !Empty(Thisform.cSortFieldSecondary) And !Empty(Field(Thisform.cSortFieldSecondary, m.lcSearchEngineResultsAlias))
			lcSortField = Thisform.cSortFieldSecondary
			lcSortOrder = Thisform.cSortOrderSecondary
			If (Empty(m.lcSortOrder) Or ("ASC" $ Upper(m.lcSortOrder)))
				lcSortOrder = "ASC"
			Endif
			lcOrderBy = m.lcOrderBy + ", " + m.lcSortField + " " + m.lcSortOrder
		Endif
		
		If !Empty(Thisform.cSortFieldTertiary) And !Empty(Field(Thisform.cSortFieldTertiary, m.lcSearchEngineResultsAlias))
			lcSortField = Thisform.cSortFieldTertiary
			lcSortOrder = Thisform.cSortOrderTertiary
			If (Empty(m.lcSortOrder) Or ("ASC" $ Upper(m.lcSortOrder)))
				lcSortOrder = "ASC"
			Endif
			lcOrderBy = m.lcOrderBy + ", " + m.lcSortField + " " + m.lcSortOrder
		Endif
		
		If Empty(m.lcOrderBy)
			lcOrderBy           = "filename, filepath , class, name, methodname"
			Thisform.cSortField = Getwordnum(m.lcOrderBy, 1, ",")
		Else
			lcOrderBy = Alltrim(m.lcOrderBy, 1, ",")
		Endif
		
		Thisform.cOrderBy = m.lcOrderBy
		
		*-- Make header bold for primary sort column
		If Thisform.lInit
			For Each m.loColumn In Thisform.oGrid.Columns
				loColumn.header1.FontBold = .F.
				lcField                   = Getwordnum(m.loColumn.ControlSource, 2, ".")
				If Upper(m.lcField) = Upper(Getwordnum(m.lcOrderBy, 1, ", "))
					loColumn.header1.FontBold = .T.
				Endif
			Endfor
		Endif
		
		If !"filename "$Lower(m.lcOrderBy) Then
			lcOrderBy = m.lcOrderBy + ",filename ASC"
		Endif &&"filename "$Lower(m.lcOrderBy)
		If !"class "$Lower(m.lcOrderBy) Then
			lcOrderBy = m.lcOrderBy + ",class "
		Endif &&!"class "$Lower(m.lcOrderBy)
		If !"name "$Lower(m.lcOrderBy) Then
			lcOrderBy = m.lcOrderBy + ",name "
		Endif &&!"name "$Lower(m.lcOrderBy)
		If !"methodname "$Lower(m.lcOrderBy) Then
			lcOrderBy = m.lcOrderBy + ",methodname "
		Endif &&!"methodname "$Lower(m.lcOrderBy)
		If !"matchstart "$Lower(m.lcOrderBy) Then
			lcOrderBy = m.lcOrderBy + ",MatchStart "
		Endif &&!"matchstart "$Lower(m.lcOrderBy)
		
		If !"filepath "$Lower(m.lcOrderBy) Then
			lnPos = At("filename ", m.lcOrderBy)
			lnLen = At(",", Substr(m.lcOrderBy, m.lnPos))
			If Empty(m.lnLen) Then
				lcOrderBy = m.lcOrderBy + ", filepath ASC"
			Else  &&EMPTY(m.lnLen)
				lcOrderBy = Stuff(m.lcOrderBy, m.lnPos + m.lnLen,0," filepath ASC,")
			Endif &&EMPTY(m.lnLen)
		Endif &&"!filepath "$Lower(m.lcOrderBy)
		
		If !"datetime "$Lower(m.lcOrderBy) Then
			lnPos = At("filepath ", m.lcOrderBy)
			lnLen = At(",", Substr(m.lcOrderBy, m.lnPos))
			If Empty(m.lnLen) Then
				lcOrderBy = m.lcOrderBy + ", datetime ASC"
			Else  &&EMPTY(m.lnLen)
				lcOrderBy = Stuff(m.lcOrderBy, m.lnPos + m.lnLen,0," datetime ASC,")
			Endif &&EMPTY(m.lnLen)
		Endif &&"!datetime "$Lower(m.lcOrderBy)
		
		Return m.lcOrderBy
		
	ENDPROC

	PROCEDURE gridcolumnrightclick
		Local;
			lcChoice As String,;
			lcChoice1 As String,;
			lcChoice2 As String,;
			lcChoice3 As String,;
			lcClass As String,;
			lcFileName As String,;
			lcPath  As String,;
			lcScope As String,;
			lcSearch As String,;
			lcUni   As String,;
			lnBar   As Number,;
			lnI     As Number,;
			lnSelect As Number,;
			lnStart As Integer,;
			loNode  As Object,;
			loNodeRoot As Object,;
			loTag   As Object,;
			loTree  As Object
		
		lcUni      = cUni
		lcSearch   = Search
		lcScope    = Scope
		lcClass    = Lower(Trim(Class))
		lcFileName = Lower(Trim(FilePath))
		
		lcChoice  = ""
		lcChoice1 = ""
		lcChoice2 = ""
		lcChoice3 = ""
		lnBar     = 0
		
		If !Empty(m.lcFileName)
			loTree = This.oTree
		
			lcChoice1 = "Filter by this File"
		
			loNodeRoot  = loTree.Nodes[1]
		
			If !This.lCR_SimpleTree And Not Empty(m.lcClass) Then
				lcChoice2 = "Filter by this Class"
		
				loTag      = m.loNodeRoot.Tag
				If Vartype(m.loTag) = "O" And m.loTag.gcLevel == "ROOT" Then
					loNodeRoot = m.loNodeRoot.Child
				Endif && &&Vartype(m.loTag) = "O" And m.loTag.gcLevel == "ROOT"
		
				Do While !Isnull(m.loNodeRoot)
					loNodeRoot = m.loNodeRoot.Next
					loTag      = m.loNodeRoot.Tag
					If Vartype(m.loTag) = "O";
							And m.loTag.gcLevel == "HISTORY";
							And m.loTag.gcUni == m.lcUni
						Exit
		
					Endif
				Enddo &&!Isnull(m.loNodeRoot)
		
			Endif &&!This.lCR_SimpleTree And Not Empty(m.lcClass)
		
			If Isnull(m.loNodeRoot) Then
				lcChoice1 = ""
				lcChoice2 = ""
		
			Else  &&Isnull(loNodeRoot)
		
				loNodeRoot = m.loNodeRoot.Child
		
				If Isnull(m.loNodeRoot) Then
					lcChoice1 = ""
					lcChoice2 = ""
		
				Endif &&Isnull(loNodeRoot)
			Endif &&Isnull(loNodeRoot)
		
			lnStart = m.loNodeRoot.Index
		Endif &&!Empty(m.lcFileName)
		
		lnSelect = Select()
		Select (This.cSearchResultsAlias)
		If !Eof() And iReplaceFolder>0 Then
			lcChoice3 = "Open Backup Replace Folder"
		Endif &&!EOF() AND iReplaceFolder>0
		Select(m.lnSelect)
		
		If !Empty(m.lcChoice1+m.lcChoice2+m.lcChoice3) Then
			GF_CreateContextMenu("FilterByFile")
		
			If !Empty(m.lcChoice1) Then
				lnBar	  = m.lnBar + 1
				Define Bar (m.lnBar) Of FilterByFile Prompt (m.lcChoice1)
				On Selection Bar (m.lnBar) Of FilterByFile m.lcChoice = [&lcChoice1]
			Endif &&!EMPTY(m.lcChoice1)
		
			If !Empty(m.lcChoice2) Then
				lnBar	  = m.lnBar + 1
				Define Bar (m.lnBar) Of FilterByFile Prompt (m.lcChoice2)
				On Selection Bar (m.lnBar) Of FilterByFile m.lcChoice = [&lcChoice2]
			Endif &&!EMPTY(m.lcChoice2)
		
			If !Empty(m.lcChoice3) Then
				lnBar	  = m.lnBar + 1
				Define Bar (m.lnBar) Of FilterByFile Prompt (m.lcChoice3)
				On Selection Bar (m.lnBar) Of FilterByFile m.lcChoice = [&lcChoice3]
			Endif &&!EMPTY(m.lcChoice3)
		
			Activate Popup FilterByFile
			Release Popups FilterByFile
		
			Do Case
				Case m.lcChoice == ""
				Case m.lcChoice == m.lcChoice1
					For lnI = m.lnStart To m.loTree.Nodes.Count
						loNode = loTree.Nodes[m.lni]
						loTag  = m.loNode.Tag
						If "O" = Vartype(m.loTag);
								And m.loTag.gcLevel == "FILE";
								And m.loTag.gcUni == m.lcUni;
								And m.loTag.gcFilePath == m.lcFileName
							This.TreeView_NodeClick(m.loNode)
						Endif
					Endfor
		
				Case m.lcChoice == m.lcChoice2
					For lnI = m.lnStart To m.loTree.Nodes.Count
						loNode = loTree.Nodes[m.lni]
						loTag  = m.loNode.Tag
						If "O" = Vartype(m.loTag);
								And m.loTag.gcLevel == "LISTED_CLASS";
								And m.loTag.gcUni == m.lcUni;
								And m.loTag.gcFilePath == m.lcFileName;
								And m.loTag.gcClass == m.lcClass
							This.TreeView_NodeClick(m.loNode)
						Endif
					Endfor
		
				Case m.lcChoice == m.lcChoice3
					Select (This.cSearchResultsAlias)
					lcPath = Addbs(This.cCR_StoreLocal + "GF_ReplaceBackups") + Ltrim(Str(iReplaceFolder,12,0))
					Select(m.lnSelect)
		
					GF_OpenExplorerWindow(m.lcPath)
			Endcase
		Endif &&!EMPTY(m.lcChoice1+m.lcChoice2+m.lcChoice3)
		
	ENDPROC

	PROCEDURE gridheaderrightclick
		Local lcChoice, lnBar
		lcChoice = ""
		lnBar	 = 0
		GF_CreateContextMenu("GridHeaderMenu")
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of GridHeaderMenu Prompt "Sort by this column"
		On Selection Bar (m.lnBar) Of GridHeaderMenu m.lcChoice = "Sort by this column"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of GridHeaderMenu Prompt "Secondary sort by this column"
		On Selection Bar (m.lnBar) Of GridHeaderMenu m.lcChoice = "Secondary sort by this column"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of GridHeaderMenu Prompt "Reset sort order to default"
		On Selection Bar (m.lnBar) Of GridHeaderMenu m.lcChoice = "Reset sort order to default"
		
		
		Activate Popup GridHeaderMenu
		Release Popups GridHeaderMenu
		
		Do Case
			Case m.lcChoice = "Reset sort order to default"
				This.cSortField			 = "filename"
				This.cSortFieldSecondary = "class"
				This.cSortFieldTertiary	 = "name"
				This.cSortOrder			 = ""
				This.cSortOrderSecondary = ""
				This.cSortOrderTertiary	 = ""
									
				This.Fillsearchresultscursor()
		
			Case m.lcChoice = "Sort by this column"
				This.SortColumn()
		
			Case m.lcChoice = "Secondary sort by this column"
				This.Sortcolumnsecondary()
		
		Endcase
		
		This.Refresh()
		
		
		
	ENDPROC

	PROCEDURE Init
		Lparameters tcProject
		
		Local lcFolder As String
		Local lcSearchEnginerOptionsFile As String
		Local loColumn As Object
		Local loGrid As Object
		Local loSearchEngine As Object
		Local loSearchOptions As Object
		Local lnTop
		
		Set Talk Off
		Set Echo Off
		Set Century On
		
		_Screen._GoFish.oResultsForm = This
		
		This.LockScreen = .T.
		
		DoDefault(, .T.)
		
		If Atc('Beta', _Screen._GoFish.cVersion) # 0
			This.Caption = 'GoFish ' + _Screen._GoFish.cVersion
		Else
			This.Caption = 'GoFish ' + Juststem(_Screen._GoFish.cVersion)
		EndIf
		
		This.oBrowser = Thisform.Containerright.Container2.containerWebControl.oBrowser
		
		loSearchEngine	= This.oSearchEngine
		loSearchOptions	= m.loSearchEngine.oSearchOptions
		loGrid			= Thisform.Containerright.Container1.gridFiles
		
		tcProject = Evl(m.tcProject, '')
		
		Thisform.UpdateSearchScopeVariables()
		
		*-- Create a local GF results cursor from GFSE cursor, then bind the grid to it
		loGrid.ColumnCount	= Fcount(Thisform.cSearchResultsAlias)
		loGrid.RecordSource	= (Thisform.cSearchResultsAlias)
		Thisform.Refresh()
		
		If This.lRestorePreviousSearchResultsOnStartup
			lcFolder = Thisform.GetSavedResultsFolder()
		Else
			lcFolder = ''
		Endif
		
		*SF 20221018 -> local storage
		*lcSearchEnginerOptionsFile = Evl(lcFolder, Home(7)) + This.cSearchOptionsXMLFile
		lcSearchEnginerOptionsFile = Evl(m.lcFolder, This.cCR_StoreLocal) + This.cSearchOptionsXMLFile
		*/SF 20221018 -> local storage
		
		m.loSearchEngine.LoadOptions(m.lcSearchEnginerOptionsFile) && Load search settings from previous session
		Thisform.nOriginalSearchScope					   = m.loSearchOptions.nSearchScope
		loSearchEngine.oSearchOptions.lIncludeAllFileTypes = .F. && Deprecated feature. Set to .f. to handle old XML files
		loSearchEngine.oProgressBar						   = This.ProgressBar
		
		*ThisForm.RestoreIndex() && Must be called AFTER saved search options are loaded in from XML file
		With m.loSearchOptions
			.lStoreCode				  = .T.
			.lCreateResultsCollection = .F.
		Endwith
		
		*-- Load some default setting from form properties, then load stored settings from XML file
		loGrid.FontSize											 = Thisform.nGridFontSize
		This.oTree.Font.Size									 = Thisform.nGridFontSize
		This.Containerright.Container2.containerWebControl.nZoom = This.nBrowserZoom
		
		Thisform.FormatGrid()
		
		This.LoadFilterSettings()
		*Thisform.FillSearchResultsCursor() && This will cause bold to be applied on the sort column header.
		
		*-- Add previous stored project...
		If Not Empty(m.loSearchOptions.cProject) And File(m.loSearchOptions.cProject)
			m.loSearchEngine.SetProject(m.loSearchOptions.cProject)
		Endif
		
		*SF 20221019 5.2.000
		*Start like CodeRefernces: Active Project or Folder
		If Empty(m.tcProject) And This.lCR_AllowEd And This.lCR_OpenMode Then
			If Type('_VFP.ActiveProject') = 'O' Then
				tcProject = _vfp.ActiveProject.Name
			Else  &&TYPE("_VFP.ActiveProject")="O"
				tcProject = Fullpath('', '')
			Endif &&TYPE("_VFP.ActiveProject")="O"
		Endif &&Empty(tcProject) AND THIS.lCR_Allowed AND THIS.lCR_OpenMode
		*/SF 20221019 5.2.000
		
		If Upper(m.tcProject) == '-P'
			tcProject = _vfp.ActiveProject.Name
		Endif &&Upper(m.tcProject) == "-p"
		
		If Upper(m.tcProject) == '-F'
			tcProject = Fullpath('', '')
		Endif &&Upper(m.tcProject) == "-p"
		
		If Upper(m.tcProject) == '-CLEAR'
			This.deletesearchresults(.F., .F., .F., .F., .F., .T.)
			tcProject = ''
		Endif &&Upper(m.tcProject) == "-p"
		
		If Not Empty(m.tcProject)
			*-- Add passed in Project...
			If 'PJX' $ Upper(Justext(m.tcProject))
				loSearchOptions.nSearchScope = 2
				If File(m.tcProject)
					m.loSearchEngine.SetProject(Fullpath(m.tcProject))
					This.comboSearchScopeHistory.Refresh
				Else
					Messagebox('Passed project [' + m.tcProject + '] cannot be found.', 0, 'GoFish')
				Endif
			Else
				loSearchOptions.nSearchScope		= 4
				loSearchEngine.oSearchOptions.cPath	= m.tcProject
			Endif
			*SF 20221019 5.2.000, issue #21
			tcProject = Thisform.GetCurrentScope()
			Thisform.comboSearchScopeHistory.LoadRows()
			Thisform.comboSearchScopeHistory.SaveSearchScope(m.tcProject)
			Thisform.comboSearchScopeHistory.Value = Lower(m.tcProject)
			*SF 20221019 5.2.000, issue #21
		
		Endif
		
		Thisform.ApplyFilter()
		
		*SF 20221023 move to end
		*Thisform.PopulateTreeview()
		*/SF 20221023 move to end
		
		*SF 20221019
		*Does not fire ACTIVATE, because the Form has the focus set somewhere deep in LoadFormSettings,
		*as a side effect, but ACTIVATE restores combosearchscopehistory.value
		Thisform.oBrowser.SetFocus() && A trick to make the web control appear on the page,
		&& otherwise, it's doesn't appear properly at startup.
		Thisform.SetCaption(Thisform.Containerright.Container1.lblResults, '')
		
		For Each m.loColumn In Thisform.oGrid.Columns
			Bindevent(m.loColumn.Header1, 'Click', Thisform, 'SortColumn')
			Bindevent(m.loColumn.Header1, 'RightClick', Thisform, 'GridHeaderRightClick')
			Bindevent(m.loColumn.Text1, 'RightClick', Thisform, 'GridColumnRightClick')
			Bindevent(m.loColumn.Text1, 'DblClick', Thisform, 'EditFile')
		Endfor
		
		Thisform.editSearch.SetFocus()
		Thisform.editSearch.InteractiveChange()
		
		*-- Ensure that the current scope is in the SearchScopeHistory table
		With Thisform.comboSearchScopeHistory
			.LoadProjects(This.oSearchEngine.oProjects)
			.SaveSearchScope(Lower(Thisform.GetCurrentScope()))
		Endwith
		
		Thisform.CaptureResizingProperties()
		
		Thisform.Refresh()
		
		This.LockScreen = .F.
		
		DoDefault()
		
		If m.loSearchOptions.lShowAdvancedFormOnStartup
			Thisform.timerShowAdvancedForm.Interval = 100
		Endif
		
		This.ButtonContainer.cmdSAVE.Move(This.ButtonContainer.cmdHistory.Left, This.ButtonContainer.cmdHistory.Top)
		
		This.lblReplaceHistory.Move(1, 10, This.Width - 2)
		This.lblReplaceHistory.Anchor = 10
		
		This.lInit = .T.
		
		Thisform.formatgridforreplacemode()
		
		Thisform.oGrid.Columns(1).SetFocus()
		If Thisform.lRestorePreviousSearchResultsOnStartup
			If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
				Thisform.populatetreefromhistory()
		
			Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
				Thisform.restoreprevioussearch()
		
			Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
		Else &&Thisform.lRestorePreviousSearchResultsOnStartup
			If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
				Thisform.PopulateTreeview(, 'Results')
		
			Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
				Thisform.PopulateTreeview()
		
			Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
		Endif &&Thisform.lRestorePreviousSearchResultsOnStartup
		
		*!*	Changed By SF 18.3.2023
		*!*	<pdm>
		*!*	<change date="{^2023-03-18,12:02:00}">Changed By SF<br />
		*!*	issue #66
		*!*	</change>
		*!*	</pdm>
		
		This.FixColumnHeadings()
		
		This.editSearch.SetFocus()
		
		*!*	/Changed By SF 18.3.2023
		
	ENDPROC

	PROCEDURE KeyPress
		Lparameters nKeyCode, nShiftAltCtrl
		
		Do Case
			Case !Thisform.lSearching And m.nKeyCode = 27
				Thisform.Release()
			Case m.nKeyCode = 137 And Inlist(m.nShiftAltCtrl, 2, 3, 6, 7) && Ctrl + F11
				This.lMaximizeCodeView = Not This.lMaximizeCodeView
				This.Refresh()
		Endcase
		
		
	ENDPROC

	PROCEDURE lmaximizecodeview_assign
		Lparameters tlmaximizecodeview
		Local lnHeight, lnWidth, loActiveControl
		
		If This.lMaximizeCodeView = m.tlmaximizecodeview
			Return
		Endif
		
		This.lMaximizeCodeView = m.tlmaximizecodeview
		
		Try 
			loActiveControl = This.ActiveControl
		Catch to loException
			
		EndTry
		
		With This.Containerright
		
			If m.tlmaximizecodeview
				lnWidth	 = .Width
				lnHeight = .Height
		
				.Container1.Visible	= .F.
				.Splitter1.Visible	= .F.
				.Splitter3.Visible	= .F.
		
				With .Container2
					.Anchor	= 0
					.Top	= 0
					.Left	= 0
					.Width	= m.lnWidth
					.Height	= m.lnHeight
					.Anchor	= 15
				Endwith
		
			Else
				Thisform.nCodeWindowPosition = Thisform.nCodeWindowPosition
			Endif
		
		Endwith
		
		Try 
			This.oBrowser.SetFocus()
		Catch to loException
			
		EndTry
		
		This.editSearch.SetFocus()
	ENDPROC

	PROCEDURE Load
		Local;
			lcFile              As String,;
			lnChange_TableStructur As Number,;
			loMy                As "My" Of "My.vcx",;
			loSettings          As Object
		
		DoDefault()
		
		Thisform.lAutoYield = _vfp.AutoYield
		_vfp.AutoYield      = .T.
		
		* SF 20221017
		* we first got storage location of settings
		lcFile = This.cCR_StoreLocal + This.cUISettingsFile
		
		loMy       = Newobject("My", "My.vcx")
		loSettings = m.loMy.Settings
		
		If File(m.lcFile)
			loSettings.Load(m.lcFile)
		
		* SF 20221017
		* Special local settings.GF_RemoveFolder
			If loSettings.Exists("lCR_Allow") And m.loSettings.lCR_Allow Then
		*Search local settings, procedure because Go1Fish.prg needs this as well.
				This.lCR_Allow = m.loSettings.lCR_Allow
		
				GF_Get_LocalSettings(@loSettings,@lcFile)
		
				This.lCR_Allowed = m.loSettings.lCR_Allowed
				If m.loSettings.lCR_Allowed Then
					This.cCR_StoreLocal  = Addbs(Justpath(m.lcFile))
				Endif &&loSettings.lCR_Allowed
		
			Endif &&loSettings.Exists("lCR_Allow") And m.loSettings.lCR_Allow
		Endif
		
		*This.cUISettingsFile = m.lcFile
		
		Thisform.cfilteroptionsxmlfile = Thisform.cCR_StoreLocal + Thisform.cfilteroptionsxmlfile
		
		
		*/ SF 20221017
		
		This.Top = -2000 && See comments in LoadFormSettings() for explanation of this...
		
		This.cInitialDefaultDir = Addbs(Sys(5) + Sys(2003))
		This.oSearchEngine      = Createobject("GoFishSearchEngine",,Thisform.cCR_StoreLocal)
		This.oSearchOptions     = This.oSearchEngine.oSearchOptions
		
		lnChange_TableStructur = GF_Change_TableStruct(Thisform, Thisform.cCR_StoreLocal, Thisform.cSavedSearchResultsFolder)
		Do Case
			Case m.lnChange_TableStructur=0
		*new structrure found
			Case m.lnChange_TableStructur=2
		*new structrure failed
				Messagebox("Failed to update history storage." + 0h0D0A + "Delete storage folder." +;
				 0h0D0A0D0A +'"' + ADDBS(Thisform.cCR_StoreLocal) + 'GF_Saved_Search_Results"', 0, "Gofish")
				Return .F.
			Case m.lnChange_TableStructur=3
		* database newer then GoFish
				MESSAGEBOX("Setting data stored fit to a version of GoFish newer then this." +;
				 0h0D0A0D0A +'"' + Thisform.cCR_StoreLocal + '"', 0, "Gofish")
				Return .F.
			Case m.lnChange_TableStructur=4
		*update failed
				Messagebox("Failed to update settings storage." + 0h0D0A + "Delete settings folder." +;
				 0h0D0A0D0A +'"' + Thisform.cCR_StoreLocal + '"', 0, "Gofish")
				Return .F.
			Otherwise
		*storage history changed
				This.oSearchEngine  = .Null.
				This.oSearchEngine  = Createobject("GoFishSearchEngine",,Thisform.cCR_StoreLocal)
				This.oSearchOptions = This.oSearchEngine.oSearchOptions
		
		Endcase
		
		This.cActiveProject = Thisform.oSearchEngine.GetActiveProject()
		
		This.FillSearchResultsCursor()
		
		This.cHtmlCodeViewFilename = Addbs(Sys(2023)) + This.cSearchResultsAlias + ".html"
		
		*!* ******** JRN Removed 2024-03-02 ********
		*!* If This.Top < 0 && Just in case the above -2000 didn't get reset properly in LoadFormSettings()
		*!* 	This.Top = 0
		*!* Endif
		
		This.lDesktop = This.Desktop
		
	ENDPROC

	PROCEDURE loadfiltersettings
		This.oFilter = Createobject(This.cFilterOptionsClass)
		This.oFilter.LoadFromFile(This.cFilterOptionsXMLFile)
	ENDPROC

	PROCEDURE loadformsettings
		Lparameters tlForceLoadFromHome7, tcForceRebuild
		
		*?	This.oGrid.column(1).Width ,This.oGrid.column(1).controlsource,'X'
		
		*-- tlForceLoadFromHome7 will force us to load from settings from Home(7) instead of the last search history folder.
		
		Local;
			lcDockWindow          As String,;
			lcFolder              As String,;
			lcSettingsFile        As String,;
			llDocked              As Boolean,;
			llRestoreSizeAndPosition As Boolean,;
			lnDockPosition        As Number,;
			lnHeight              As Integer,;
			lnLeft                As Integer,;
			lnRow                 As Integer,;
			lnScreenBottom        As Integer,;
			lnScreenLeft          As Integer,;
			lnScreenRight         As Integer,;
			lnScreenTop           As Integer,;
			lnTop                 As Integer,;
			lnWidth               As Integer,;
			lnX                   As Number,;
			loControl             As Object,;
			loMonitor             As Empty,;
			loMy                  As "My" Of "My.vcx",;
			loMyDefault           As "My" Of "My.vcx",;
			loSettings            As Object,;
			loSettingsDefault     As Object
		
		*SF 20221017
		*new settings
		*first, check if we have the settings in oSearchOptions, then we must move them
		If Pemstatus(This.oSearchOptions,"lMoveNewCodeToTopLeft",5) Then
			This.lMoveNewCodeToTopLeft          = This.oSearchOptions.lMoveNewCodeToTopLeft
		
			Removeproperty(This.oSearchOptions,"lMoveNewCodeToTopLeft")
		Endif &&PEMSTATUS(THIS.oSearchOptions,"lMoveNewCodeToTopLeft",5)
		If Pemstatus(This.oSearchOptions,"nContainerFrameColour",5) Then
			This.nContainerFrameColour          = This.oSearchOptions.nContainerFrameColour
			This.nFileSCXDynamicForeColour      = This.oSearchOptions.nFileSCXDynamicForeColour
			This.nFileVCXDynamicForeColour      = This.oSearchOptions.nFileVCXDynamicForeColour
			This.nFilePRGDynamicForeColour      = This.oSearchOptions.nFilePRGDynamicForeColour
			This.nFileDefaultDynamicForeColour  = This.oSearchOptions.nFileDefaultDynamicForeColour
			This.nReplacedDynamicBackColour     = This.oSearchOptions.nReplacedDynamicBackColour
			This.nRiskExceededDynamicBackColour = This.oSearchOptions.nRiskExceededDynamicBackColour
			This.nRisk1DynamicBackColour        = This.oSearchOptions.nRisk1DynamicBackColour
			This.nRisk2DynamicBackColour        = This.oSearchOptions.nRisk2DynamicBackColour
			This.nRisk3DynamicBackColour        = This.oSearchOptions.nRisk3DynamicBackColour
			This.nTreeSearchColour              = This.oSearchOptions.nTreeSearchColour
			This.nTreeUpdateColour              = This.oSearchOptions.nTreeUpdateColour
			This.nCSS_tr_even_Colour            = This.oSearchOptions.nCSS_tr_even_Colour
			This.nCSS_tr_odd_Colour             = This.oSearchOptions.nCSS_tr_odd_Colour
		
			Removeproperty(This.oSearchOptions,"nContainerFrameColour")
			Removeproperty(This.oSearchOptions,"nFileSCXDynamicForeColour")
			Removeproperty(This.oSearchOptions,"nFileVCXDynamicForeColour")
			Removeproperty(This.oSearchOptions,"nFilePRGDynamicForeColour")
			Removeproperty(This.oSearchOptions,"nFileDefaultDynamicForeColour")
			Removeproperty(This.oSearchOptions,"nReplacedDynamicBackColour")
			Removeproperty(This.oSearchOptions,"nRiskExceededDynamicBackColour")
			Removeproperty(This.oSearchOptions,"nRisk1DynamicBackColour")
			Removeproperty(This.oSearchOptions,"nRisk2DynamicBackColour")
			Removeproperty(This.oSearchOptions,"nRisk3DynamicBackColour")
			Removeproperty(This.oSearchOptions,"nTreeSearchColour")
			Removeproperty(This.oSearchOptions,"nTreeUpdateColour")
			Removeproperty(This.oSearchOptions,"nCSS_tr_even_Colour")
			Removeproperty(This.oSearchOptions,"nCSS_tr_odd_Colour")
		Endif &&PEMSTATUS(THIS.oSearchOptions,"nContainerFrameColour",5)
		*/ SF 20221017
		
		*-- Note: In the Load() event, Form.Top is set to -2000 to prevent the form from appearing in the
		*-- visible screen area and then being moved to the restored position. This caused an annoying
		*-- flashing behavior than can be avoided with this trick.
		*-- Therefore, we must be sure to bring the form back into the view area before we leave this method.
		
		* SF 20221017
		* Special local settings. Should only happen in gf_resultsform
		If This.nFirstLoad=0 Then
			This.nFirstLoad = 1
		
		*common settings file
		*we have the right file from LOAD anyway, but we must restore lCR_Allow from global setting
		*do we load it twice
		*	This.cUISettingsFile = This.cUISettingsFile
			lcSettingsFile       = Addbs(Home(7) + "GoFish_") + This.cUISettingsFile
		
			If Not File(m.lcSettingsFile)
				This.Top = 0 && See note above
				Return
			Endif
		
			loMy       = Newobject("My", "My.vcx")
			loSettings = m.loMy.Settings
		
			loSettings.Load(m.lcSettingsFile)
		
			This.lCR_Local         = GF_PropNvl(m.loSettings, "lCR_Local"        ,This.lCR_Local        ,.T.)
			This.lCR_Local_Default = GF_PropNvl(m.loSettings, "lCR_Local_Default",This.lCR_Local_Default,.T.)
		
			If loSettings.Exists("lCR_Allow") And m.loSettings.lCR_Allow Then
		*Search local settings, procedure because Go1Fish.prg needs this as well.
				This.lCR_Allow = m.loSettings.lCR_Allow
		
				GF_Get_LocalSettings(@loSettings,@lcSettingsFile)
		
				This.lCR_Allowed = m.loSettings.lCR_Allowed
				If m.loSettings.lCR_Allowed Then
					This.nFirstLoad = 2
		*			This.cUISettingsFile = m.lcSettingsFile
					This.cCR_StoreLocal  = Addbs(Justpath(m.lcSettingsFile))
				Endif &&loSettings.lCR_Allowed
		
			Endif &&loSettings.Exists("lCR_Allow") And m.loSettings.lCR_Allow
		
			llRestoreSizeAndPosition = .T.
		Else  &&This.nFirstLoad=0
			lcSettingsFile       = This.cCR_StoreLocal + This.cUISettingsFile
		
			If Not File(m.lcSettingsFile)
				This.Top = 0 && See note above
				Return
			Endif
		
			loMy       = Newobject("My", "My.vcx")
			loSettings = m.loMy.Settings
		
			loSettings.Load(m.lcSettingsFile)
		
		Endif &&This.nFirstLoad=0
		
		*we keep a copy of the real settings, so we restore not all from previous search, if we use that
		loMyDefault       = m.loMy
		loSettingsDefault = m.loSettings
		
		This.lRestorePreviousSearchResultsOnStartup	= GF_PropNvl(m.loSettingsDefault, "lRestorePreviousSearchResultsOnStartup ", This.lRestorePreviousSearchResultsOnStartup, .T.)
		*/ SF 20221017
		
		If Not m.tlForceLoadFromHome7 And Thisform.lRestorePreviousSearchResultsOnStartup
			lcFolder = Thisform.GetLastSavedResultsFolder()
		
			lcSettingsFile = m.lcFolder + This.cUISettingsFile
			If File(m.lcSettingsFile)
				loMy       = Newobject("My", "My.vcx")
				loSettings = m.loMy.Settings
		
				loSettings.Load(m.lcSettingsFile)
			Endif
		Endif
		
		If m.llRestoreSizeAndPosition
		*-- Restore Docking settings (Code provided by Jim Nelson) -----------------
		*-- Important note: Dock settings MUST be restored before Lett and Top are restored in next step
			Try
					This.Dockable  = m.loSettingsDefault.nDockable
					llDocked       = m.loSettings.lDocked
					lnDockPosition = m.loSettings.nDockPosition
					If This.Dockable = 1 And m.llDocked
						lcDockWindow = m.loSettings.cDockWindow
						Do Case
							Case Not Empty (m.lcDockWindow)
								Try
										Dock Name Thisform Position 4 Window &lcDockWindow
									Catch
		
								Endtry
							Case  Between (m.lnDockPosition, 0, 3)
								This.Dock (m.lnDockPosition)
						Endcase
					Endif
				Catch
			Endtry
		
		*-- Resize form size and position--------------------
			If loSettings.Exists("FormTop")
				With m.loSettings
					lnTop    = 0
					lnHeight = This.Height
					lnLeft   = 0
					lnWidth  = This.Width
		
					lnScreenTop    = 0
					lnScreenBottom = _Screen.Height
					lnScreenLeft   = 0
					lnScreenRight  = _Screen.Width
		
					If This.Desktop Or This.Dockable=1 Then
						loMonitor = GF_GetMonitorStatistics()
		
						lnTop  = _Screen.Top
						lnLeft = _Screen.Left
		
						lnScreenTop    = m.loMonitor.gnVirtualTop
						lnScreenBottom = m.loMonitor.gnVirtualBottom
						lnScreenLeft   = m.loMonitor.gnVirtualLeft
						lnScreenRight  = m.loMonitor.gnVirtualRight
		
					Endif &&This.Desktop Or This.Dockable=1
		
					If Between(.FormTop , m.lnScreenTop, m.lnScreenBottom) Then
						lnTop    = .FormTop
						lnHeight = .FormHeight
					Endif &&Between(.FormTop , m.lnScreenTop, m.lnScreenBottom)
		
					If Between(.FormLeft, m.lnScreenLeft, m.lnScreenRight) Then
						lnLeft  = .FormLeft
						lnWidth = .FormWidth
					Endif &&Between(.FormLeft, m.lnScreenLeft, m.lnScreenRight)
		
					*!* ** { JRN -- 03/02/2024 05:54:53 PM - Begin
					*!* Thisform.Move(m.lnLeft, m.lnTop, m.lnWidth, m.lnHeight)
					*!* Thisform.Resize()
					Thisform.Move(m.lnLeft, -20000, m.lnWidth, m.lnHeight)
					Thisform.Resize()
					*!* ** } JRN -- 03/02/2024 05:54:53 PM - End
		
					Try
							This.Containerright.Splitter1.MoveSplitterToPosition(.Splitter1Position)
						Catch
					Endtry
					Try
							This.Containerright.Splitter3.MoveSplitterToPosition(.Splitter3Position)
						Catch
					Endtry
					Try
							This.splitter2.MoveSplitterToPosition(.Splitter2Position)
						Catch
					Endtry
					This.Top = m.lnTop && Do this one last to finally bring the form into view.
				Endwith
			Else
				This.Top = 0
			Endif
		
			With Thisform
				.nBrowserZoom       = GF_PropNvl(m.loSettingsDefault, "nBrowserZoom", 1, .T.)
				.nSearchBoxFontSize = GF_PropNvl(m.loSettings, "nSearchBoxFontSize", Thisform.editSearch.FontSize, .T.)
				.nGridFontSize      = GF_PropNvl(m.loSettingsDefault, "nGridFontSize", Thisform.oGrid.FontSize, .T.)
				.nTreeViewFontSize  = GF_PropNvl(m.loSettingsDefault, "nTreeViewFontSize", Thisform.oGrid.FontSize, .T.)
				.nReplaceMode       = GF_PropNvl(m.loSettings, "nReplaceMode", 1)
		
				.Containerright.Container2.containerWebControl.nZoom = .nBrowserZoom
			Endwith
		
		Endif
		
		*-- Load other Form properties from My Settings ------------------------------------
		With Thisform
		*.lIncludeSubDirectoriesCurrent = GF_PropNvl(loSettings, "lIncludeSubDirectoriesCurrent", .t.)
		*.lIncludeSubDirectoriesBrowsed = GF_PropNvl(loSettings, "lIncludeSubDirectoriesBrowsed", .t.)
			.lApplyFilter      = GF_PropNvl(m.loSettings, "lApplyFilter", .F., .T.)		&&controlsource
			.lClearApplyFilter = GF_PropNvl(m.loSettingsDefault, "lClearApplyFilter", .T., .T.)
			.cFilter           = GF_PropNvl(m.loSettings, "cFilter", "", .T.)
		
		*.cSortFields = GF_PropNvl(loSettings, "cSortFields", "") && This one has been deprecated. See cSortField.
			If Pemstatus(m.loSettings, "cSortFields", 5)
				.cSortField = Getwordnum(m.loSettings.cSortFields, 1, ",")
			Else
				.cSortField = GF_PropNvl(m.loSettings, "cSortField")
			Endif
		
			.cSortOrder          = GF_PropNvl(m.loSettings, "cSortOrder", "")
			.cSortFieldSecondary = GF_PropNvl(m.loSettings, "cSortFieldSecondary", "")
			.cSortOrderSecondary = GF_PropNvl(m.loSettings, "cSortOrderSecondary", "")
			.cSortFieldTertiary  = GF_PropNvl(m.loSettings, "cSortFieldTertiary", "")
			.cSortOrderTertiary  = GF_PropNvl(m.loSettings, "cSortOrderSecondary", "")
		
			.nReplaceRisk        = Evl(GF_PropNvl(m.loSettingsDefault, "nReplaceRisk", 1), 1)
			.cReplaceUDFFilename = GF_PropNvl(m.loSettings, "cReplaceUdfFilename", "")
		
			.nDropDownDisplayCount = GF_PropNvl(m.loSettingsDefault, "nDropDownDisplayCount", 20, .T.)
			.nDropDownMaxMRU       = GF_PropNvl(m.loSettingsDefault, "nDropDownMaxMRU", 7, .T.)
		
			.lWarnWholeWord     = GF_PropNvl(m.loSettingsDefault, "lWarnWholeWord", .F., .T.)
			.lSaveSearchResults = GF_PropNvl(m.loSettingsDefault, "lSaveSearchResults", .T., .T.)
			.lCodeOnly          = GF_PropNvl(m.loSettings, "lCodeOnly", .F., .T.)
			.lCommentsOnly      = GF_PropNvl(m.loSettings, 'lCommentsOnly', .F., .T.)
			
			.nPreviousSessionTreeviewindex = GF_PropNvl(m.loSettings, "nSelectedTreeviewNode", 1, .T.)
			.lOnlyFirstMatchInStatement    = GF_PropNvl(m.loSettings, "lOnlyFirstMatchInStatement", .F., .T.)
			
			.lShowRelativePath			   = GF_PropNvl(m.loSettings,'lShowRelativePath', .F., .T.)
			.lSortScopeDropdown			   = GF_PropNvl(m.loSettings,'lSortScopeDropdown', .F., .T.)
			.lCodeViewSingleLine	   = GF_PropNvl(m.loSettings,'lCodeViewSingleLine', .F., .T.)
			.lIDEColorsInCodeView		   = GF_PropNvl(m.loSettings,'lIDEColorsInCodeView', .T., .T.)
			.lOldSearchHistoryStructure	   = GF_PropNvl(m.loSettings,'lOldSearchHistoryStructure', .F., .T.)
		
			.nCodeWindowPosition = 	GF_PropNvl(m.loSettings, "CodeWindowPosition", 1, .T.)
		
			.nJanitorSearchHistoryDays  = GF_PropNvl(m.loSettingsDefault, "nJanitorSearchHistoryDays ", 10000, .T.)
			.nJanitorReplaceHistoryDays = GF_PropNvl(m.loSettingsDefault, "nJanitorReplaceHistoryDays", 10000, .T.)
			.lRunJanitorDaily           = GF_PropNvl(m.loSettingsDefault, "lRunJanitorDaily", .F., .T.)
			.nTabsToSpaces              = GF_PropNvl(m.loSettingsDefault, "nTabsToSpaces", 0, .T.)
		
		* Dates are stored as datetime!
			.dLastJanitorRunDate		= Ttod(GF_PropNvl(m.loSettingsDefault, "dLastJanitorRunDate", Dtot(Date() - 1), .T.))
		
		*SF 20221017
		*new settings
		* loSettingsDefault is the same as loSettings, if no previous search is loaded
			.nContainerFrameColour          = GF_PropNvl(m.loSettingsDefault, "nContainerFrameColour"         ,.nContainerFrameColour         ,.T.)
			.nFileSCXDynamicForeColour      = GF_PropNvl(m.loSettingsDefault, "nFileSCXDynamicForeColour"     ,.nFileSCXDynamicForeColour     ,.T.)
			.nFileVCXDynamicForeColour      = GF_PropNvl(m.loSettingsDefault, "nFileVCXDynamicForeColour"     ,.nFileVCXDynamicForeColour     ,.T.)
			.nFilePRGDynamicForeColour      = GF_PropNvl(m.loSettingsDefault, "nFilePRGDynamicForeColour"     ,.nFilePRGDynamicForeColour     ,.T.)
			.nFileDefaultDynamicForeColour  = GF_PropNvl(m.loSettingsDefault, "nFileDefaultDynamicForeColour" ,.nFileDefaultDynamicForeColour ,.T.)
			.nReplacedDynamicBackColour     = GF_PropNvl(m.loSettingsDefault, "nReplacedDynamicBackColour"    ,.nReplacedDynamicBackColour    ,.T.)
			.nRiskExceededDynamicBackColour = GF_PropNvl(m.loSettingsDefault, "nRiskExceededDynamicBackColour",.nRiskExceededDynamicBackColour,.T.)
			.nRisk1DynamicBackColour        = GF_PropNvl(m.loSettingsDefault, "nRisk1DynamicBackColour"       ,.nRisk1DynamicBackColour       ,.T.)
			.nRisk2DynamicBackColour        = GF_PropNvl(m.loSettingsDefault, "nRisk2DynamicBackColour"       ,.nRisk2DynamicBackColour       ,.T.)
			.nRisk3DynamicBackColour        = GF_PropNvl(m.loSettingsDefault, "nRisk3DynamicBackColour"       ,.nRisk3DynamicBackColour       ,.T.)
			.nTreeSearchColour              = GF_PropNvl(m.loSettingsDefault, "nTreeSearchColour"             ,.nTreeSearchColour             ,.T.)
			.nTreeUpdateColour              = GF_PropNvl(m.loSettingsDefault, "nTreeUpdateColour"             ,.nTreeUpdateColour             ,.T.)
			.nCSS_tr_even_Colour            = GF_PropNvl(m.loSettingsDefault, "nCSS_tr_even_Colour"           ,.nCSS_tr_even_Colour           ,.T.)
			.nCSS_tr_odd_Colour             = GF_PropNvl(m.loSettingsDefault, "nCSS_tr_odd_Colour"            ,.nCSS_tr_odd_Colour            ,.T.)
			.lMoveNewCodeToTopLeft          = GF_PropNvl(m.loSettingsDefault, "lMoveNewCodeToTopLeft"         ,.lMoveNewCodeToTopLeft         ,.T.)
		*/SF 20221017
		
		*SF 20221019 5.2.000
			.lCR_OpenMode            = GF_PropNvl(m.loSettingsDefault, "lCR_OpenMode"           ,.lCR_OpenMode           ,.T.)
			.lCR_HistoryPerScope     = GF_PropNvl(m.loSettingsDefault, "lCR_HistoryPerScope"    ,.lCR_HistoryPerScope    ,.T.)
			.lCR_SearchComboPerScope = GF_PropNvl(m.loSettingsDefault, "lCR_SearchComboPerScope",.lCR_SearchComboPerScope,.T.)
			.lCR_HistoryTree         = GF_PropNvl(m.loSettingsDefault, "lCR_HistoryTree"        ,.lCR_HistoryTree        ,.T.)
			.lCR_HistoryTreeAuto     = GF_PropNvl(m.loSettingsDefault, "lCR_HistoryTreeAuto"    ,.lCR_HistoryTreeAuto    ,.T.)
			.lCR_SimpleTree          = GF_PropNvl(m.loSettingsDefault, "lCR_SimpleTree"         ,.lCR_SimpleTree         ,.T.)
			.lCR_SortTreeByExt       = GF_PropNvl(m.loSettingsDefault, "lCR_SortTreeByExt"      ,.lCR_SortTreeByExt      ,.T.)
			.lCR_SortTreeAlpha       = GF_PropNvl(m.loSettingsDefault, "lCR_SortTreeAlpha"      ,.lCR_SortTreeAlpha      ,.T.)
		
		*/SF 20221019 5.2.000
		
		*SF 20221020 5.2.000
			.lOtherHistory           = GF_PropNvl(m.loSettingsDefault, "lOtherHistory"          ,.lOtherHistory          ,.T.)
		
		*/SF 20221020 5.2.000
		
		*SF 20230211 6.0.000
			.lReplacePreview         = GF_PropNvl(m.loSettingsDefault, "lReplacePreview"        ,.lReplacePreview        ,.T.)
		
		*/SF 20230211 6.0.000
		
		Endwith
		
		*-- These fields were removed in version 4.3.015 and 4.3.041, so if they are used in the SortOrder, we have to reset it
		If Inlist(Lower(Thisform.cSortFields), "objectclass", "objectbaseclass", "objectname", "containingclassbaseclass")
			Thisform.cSortFields = ""
			Thisform.cSortOrder  = ""
		Endif
		
		This.oGrid.FontSize  = Thisform.nGridFontSize
		This.oTree.Font.Size = Thisform.nTreeViewFontSize
		
		This.comboSearchExpressionHistory.DisplayCount = Thisform.nDropDownDisplayCount
		This.comboSearchExpressionHistory.nMaxMRU      = This.nDropDownMaxMRU
		This.comboSearchExpressionHistory.LoadRows()
		
		This.comboSearchScopeHistory.DisplayCount = Thisform.nDropDownDisplayCount
		This.comboSearchScopeHistory.nMaxMRU      = This.nDropDownMaxMRU
		This.comboSearchScopeHistory.LoadRows()
		
		*--- Restore Width, ColumnOrder, and Visible state to Grid columns ----------------
		*lnX = 1
		
		For Each m.loControl In Thisform.oGrid.Columns
			loControl.Width       = GF_PropNvl(m.loSettings, Evl(m.loControl.Header1.Tag,m.loControl.Name) + "_width",   m.loControl.gnWidth, .T.)
			loControl.ColumnOrder = GF_PropNvl(m.loSettings, Evl(m.loControl.Header1.Tag,m.loControl.Name) + "_order",   m.loControl.ColumnOrder, .T.)
			loControl.Visible     = GF_PropNvl(m.loSettings, Evl(m.loControl.Header1.Tag,m.loControl.Name) + "_visible", m.loControl.Visible, .T.)
			lnRow                 = Ascan(This.gaFields, Proper(Getwordnum(m.loControl.ControlSource, 2, ".")), -1, -1, 1, 15)
			If !Empty(m.lnRow) Then
				This.gaFields(m.lnRow,6) = m.loControl.Visible
			Endif &&!Empty(m.lnRow)
		
		*loControl.Header1.FontBold = GF_PropNvl(loSettings, loControl.name + "_BoldHeader", .f., .t.)
		*	lnX = m.lnX + 1
		Endfor
		
		
		*SF 20221017
		*stored the settings to the wrong place, lets remove from oSearchOptions an put into this settings
		*
		
		*SF 20221015
		* --- colours used for showing informations ---
		* should be set in settings dialog
		This.ButtonContainer.Container1.BorderColor = Thisform.nContainerFrameColour
		This.ButtonContainer.Container2.BorderColor = Thisform.nContainerFrameColour
		This.ButtonContainer.Container3.BorderColor = Thisform.nContainerFrameColour
		
		This.Containerright.Container1.Container1.BorderColor = Thisform.nContainerFrameColour
		This.Containerright.Container1.Container2.BorderColor = Thisform.nContainerFrameColour
		
		This.Containerright.Container1.containerReplaceText.BackColor = Thisform.nReplacedDynamicBackColour
		
		This.lblReplaceHistory.BackColor = Thisform.nReplacedDynamicBackColour
		
		This.Set_GridColour()
		Thisform.FormatGridForReplaceMode()
		
		This.ButtonContainer.cmdHistory.Visible = !(Thisform.lCR_HistoryTree And Thisform.lRestorePreviousSearchResultsOnStartup)
		This.ButtonContainer.cmdSave.Visible = !This.ButtonContainer.cmdHistory.Visible And !Thisform.lSaveSearchResults
		
		If m.tcForceRebuild Then
		*all stuff stored cleared, fresh interface
			If Thisform.lRestorePreviousSearchResultsOnStartup
				If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
					Thisform.PopulateTreeFromHistory()
		
				Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
					Thisform.RestorePreviousSearch()
		
				Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
			Else &&Thisform.lRestorePreviousSearchResultsOnStartup
				If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
					Thisform.PopulateTreeview(,"Results")
		
				Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
					Thisform.PopulateTreeview()
		
				Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
			Endif &&Thisform.lRestorePreviousSearchResultsOnStartup
		Else  &&m.tcForceRebuild
			If This.lCR_RefreshTree And Used(Thisform.cSearchResultsAlias) And !Eof(Thisform.cSearchResultsAlias) Then
				If Thisform.lCR_HistoryTree Then
					Thisform.PopulateTreeFromHistory()
		
				Else  &&Thisform.lCR_HistoryTree
					Thisform.RestorePreviousSearch()
		
				Endif &&Thisform.lCR_HistoryTree
				Thisform.oGrid.SetFocus()
		
				This.lCR_RefreshTree = .F.
			Endif &&THIS.lCR_RefreshTree AND USED(Thisform.cSearchResultsAlias) And !Eof(Thisform.cSearchResultsAlias)
		Endif &&m.tcForceRebuild
		
		This.Top = m.lnTop 
		
	ENDPROC

	PROCEDURE loadreplaceline
		Local lcCursor, lcMatchLine, llReplaced
		
		lcCursor = This.cSearchResultsAlias
		
		lcMatchLine = &lcCursor..matchline
		lnMatchLength = &lcCursor..matchlen
		llReplaced = &lcCursor..replaced
		
		If !llReplaced
			Thisform.cReplaceLine = Left(lcMatchLine, lnMatchLength)
		Else
			Thisform.cReplaceLine = ""
		Endif
		
	ENDPROC

	PROCEDURE loadsavedresults
		Lparameters;
			tcFilter,;
			tlNoFormupdate,;
			tnMode,;
			tlOldStyle
		
		Local;
			lcCurrentDatabase       As String,;
			lcDBF                   As String,;
			lcDbc                   As String,;
			lcDbcAndTable           As String,;
			lcFolder                As String,;
			lcInfoFile              As String,;
			lcMacro                 As String,;
			lcMakroField            As String,;
			lcMakroOrder            As String,;
			lcName                  As String,;
			lcRoot                  As String,;
			lcScope                 As String,;
			lcSearchEngineResultsAlias As String,;
			lcSearchEnginerOptionsFile As String,;
			lcSearchExpression      As String,;
			lcSortMacro             As String,;
			loException             As Object,;
			loSearchEngine          As Object,;
			loSearchOptions         As Object
		
		Local Array;
			laInfo(1)
		
		loSearchEngine = Thisform.oSearchEngine
		
		If !m.tlOldStyle Then
			lcSearchEngineResultsAlias = Thisform.oSearchEngine.cSearchResultsAlias
		
			This.SaveDBC_Open()
		
			lcDBF = Juststem(Thisform.cUISettingsFile)
			This.UseTable(m.lcDBF, m.lcDBF)
		
			tnMode = Evl(m.tnMode, 0)
		
			lcMacro = ""
		
		*search / show replaced mode
			If This.lReplace_History
				lcMacro = m.lcMacro + " AND Cur1.Replaced"
			Else  &&This.lReplace_History
				lcMacro = m.lcMacro + " AND !Cur1.lJustReplace"
			Endif &&This.lReplace_History
		
		
			Do Case
				Case m.tnMode > 1
				Case Empty(m.tcFilter)
		*get latest Result
					Go Botto
					lcMacro = m.lcMacro + [ AND cUni == "] + cUni + ["]
				Case Empty(m.tnMode)
					lcMacro = m.lcMacro + " AND cUni == m.tcFilter"
				Case m.tnMode = 1
					lcMacro = m.lcMacro + " AND Scope == m.tcFilter"
				Otherwise
		
			Endcase
		
			lcMacro = Strtran(m.lcMacro, " AND", " WHERE", 1, 1)
		
		*show replaced mode
		*!*	IF glReplace
		*!*			lcMacro = m.lcMacro + " AND Cur1.lReplaced"
		*!*	ENDIF &&glReplace
		
			lcSortMacro  = Iif(Thisform.lCR_SortTreeAlpha,"Cur1.Search ASC,","")
		
			Select;
				Cur1.*;
				From (m.lcDBF) As Cur1;
				&lcMacro;
				Order By &lcSortMacro Cur1.Datetime Asc, Cur1.filename, Cur1.Class, Cur1.Name, Cur1.methodname;
				Into Cursor (m.lcSearchEngineResultsAlias) NoFilter Readwrite
		
		*!*			Order By Cur1.Datetime, Cur1.filename, Cur1.Class, Cur1.Name, Cur1.methodname;
		
			Use In Select(m.lcDBF)
		
			This.SaveDBC_Close()
		
			Go Bottom
		
			lcFolder = Addbs(This.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder)
		
			lcInfoFile = m.lcFolder + Trim(cUni) + Trim(Substr(Thisform.cSavedSearchResultsFolder,3)) + ".txt"
		
			lcSearchEnginerOptionsFile = m.lcFolder + Trim(cUni) + Trim(Substr(Thisform.cSearchOptionsXMLFile,3))
		
		Else  &&!m.tlOldStyle
		
		***** old style
		
			lcSearchEngineResultsAlias = Thisform.oSearchEngine.cSearchResultsAlias
		
			lcName = Thisform.cSavedSearchResultsFolder
		
			If !Empty(m.tcFilter)
				If Atc("\", m.tcFilter) > 0
					lcFolder = m.tcFilter
				Else
					lcName = Thisform.cSavedSearchResultsFolder
		*SF 20221018 -> local storage
		*		lcRoot = Home(7) + lcName
					lcRoot = This.cCR_StoreLocal + m.lcName
		*/SF 20221018 -> local storage
					lcFolder = Addbs(m.lcRoot) + m.tcFilter
				Endif
			Else
				lcFolder = Thisform.GetLastSavedResultsFolder()
			Endif
		
			If Empty(m.lcFolder)
				Return .F.
			Endif
		
			lcDbc         = m.lcFolder + m.lcName + ".dbc"
			lcDBF         = m.lcFolder + m.lcName + ".dbf"
			lcDbcAndTable = m.lcDbc + "!" + m.lcName
			lcInfoFile    = m.lcFolder + m.lcName + ".txt"
		
			lcMakroField = ""
			lcMakroOrder = ""
		
			If File(m.lcDbc) And File(m.lcDBF) And File(m.lcInfoFile)
				Try
						Use (m.lcDbcAndTable) Alias (m.lcName) In Select(m.lcName)
						lcCurrentDatabase = Set("Database")
						Select(m.lcName)
		
						If Empty(Field("Datetime")) Then
							lcMakroField = m.lcMakroField + "SPACE(24) AS Datetime,"
						Else  &&Empty(Field("Datetime"))
							lcMakroOrder = "Datetime, " + m.lcMakroOrder
						Endif &&Empty(Field("Datetime"))
						If Empty(Field("Search")) Then
							lcMakroField = m.lcMakroField + [CAST("" AS V(254)) AS Search,]
						Endif &&Empty(Field("Search"))
						If Empty(Field("Scope")) Then
							lcMakroField = m.lcMakroField + [CAST("" AS V(254)) AS Scope,]
						Endif &&Empty(Field("Scope"))
		
						Select;
							&lcMakroField *;
							From (m.lcName);
							Order By &lcMakroOrder filename, Class, Name, methodname;
							Into Cursor (m.lcSearchEngineResultsAlias) NoFilter Readwrite
		
		*Thisform.comboSearchScopeHistory.Value = lcScope
						Use In Select(m.lcName)
						Set Database To (m.lcDbc)
						Close Database
						Set Database To (m.lcCurrentDatabase)
					Catch To m.loException
				Endtry
			Endif
		
		*-- Load Search Engine Options for saved search results
			lcSearchEnginerOptionsFile = Addbs(m.lcFolder) + "\" + This.cSearchOptionsXMLFile
		
		*-- Load Form Settings for saved search results
		*** JRN 10/15/2015 : REMOVED   This.LoadFormSettings(.t., lcFolder) && Form size and position, as well as a few custom properties that are store on the form
		Endif &&!m.tlOldStyle
		
		loSearchEngine.nMatchLines = Reccount(m.lcSearchEngineResultsAlias)
		
		If Type("loSearchEngine.oSearchErrors") = "O" And !Isnull(loSearchEngine.oSearchErrors) Then
			loSearchEngine.oSearchErrors.Remove(-1)
		Endif &&TYPE("loSearchEngine.oSearchErrors") = "O" AND !ISNULL(loSearchEngine.oSearchErrors)
		
		If This.ButtonContainer.cmdHistory.Visible Then
		*we skip this.Activate e history should not fiddle with actual search settings. RefreshResultsset while refreshing results, but not here
		*!*	If !This.lReplace_History And m.loSearchEngine.nMatchLines > 0
			loSearchOptions              = m.loSearchEngine.oSearchOptions
			loSearchEngine.LoadOptions(m.lcSearchEnginerOptionsFile) && Load search settings from previous session
			Thisform.nOriginalSearchScope = m.loSearchOptions.nSearchScope
		
		*!*		Alines(laInfo, Filetostr(m.lcInfoFile))
		*!*	*lcSearchExpression = laInfo[2]
		*!*		lcScope = laInfo[3]
		*!*	*Thisform.editSearch.Value = lcSearchExpression
		*!*		If !m.tlNoFormupdate Then
		*!*			Thisform.comboSearchScopeHistory.SaveSearchScope(m.lcScope)
		*!*		Endif &&!m.tlNoFormupdate
		
		*!*	Endif &&!This.lReplace_History And m.loSearchEngine.nMatchLines > 0
		Endif &&This.ButtonContainer.cmdHistory.Visible
		
		Select (m.lcSearchEngineResultsAlias)
		
	ENDPROC

	PROCEDURE lockwindow
		Lparameters tlLock, tnHWnd
		
		* From Doug Hennig's Win32API session at SW Fox 2012
		
		Local lnHWnd
		
		Declare Integer LockWindowUpdate In Win32API		;
			Integer nHandle
		
		Do Case
			Case Not tlLock
				lnHWnd = 0
			Case Pcount() = 1
				Declare Integer GetDesktopWindow In Win32API
				lnHWnd = GetDesktopWindow()
			Otherwise
				lnHWnd = tnHWnd
		Endcase
		
		LockWindowUpdate(lnHWnd)
		
		
	ENDPROC

	PROCEDURE LostFocus
		*no default
		
	ENDPROC

	PROCEDURE lreplaceviewmode_assign
		Lparameters;
			tlReplaceViewMode
		
		Local;
			llEnteringReplaceMode As Boolean,;
			llLeavingReplaceMode As Boolean
		
		llEnteringReplaceMode =  m.tlReplaceViewMode And !Thisform.lReplaceViewMode
		llLeavingReplaceMode  = !m.tlReplaceViewMode And  Thisform.lReplaceViewMode
		
		Thisform.lReplaceViewMode = m.tlReplaceViewMode
		
		Do Case
			Case !Thisform.lInit
		*pre thisform init
				llEnteringReplaceMode = .F.
				llLeavingReplaceMode  = .F.
		
			Case Thisform.oSearchEngine.oSearchOptions.lEnableReplaceMode And Thisform.nReplaceMode = 0
		*default as old system
				Thisform.nReplaceMode = 2
		
			Case Thisform.nReplaceMode = 0
		*default (replace disabled)
				Thisform.nReplaceMode = 1
		
			Case !Thisform.oSearchEngine.oSearchOptions.lEnableReplaceMode And Inlist(Thisform.nReplaceMode,2,3,4)
		*turn off (replace disabled)
				Thisform.nReplaceMode = 1
		
			Case Thisform.oSearchEngine.oSearchOptions.lEnableReplaceMode And Inlist(Thisform.nReplaceMode,5)
		*turn off, show Replace Mode is not the start, default as old system
				Thisform.nReplaceMode = 2
		
			Case Inlist(Thisform.nReplaceMode,5)
		*turn off, show Replace Mode is not the start,  (replace disabled)
				Thisform.nReplaceMode = 1
		
			Otherwise
		*just call, ASSIGN will do more switching
				Thisform.nReplaceMode = Thisform.nReplaceMode
		
		Endcase
		
		Thisform.Refresh()
		
		If m.llEnteringReplaceMode And Thisform.nReplaceMode = 4
			Do Form gofish_advaccedreplacehelp With Thisform
		Endif
		
		Do Case
			Case m.llEnteringReplaceMode
		*turn on replace colour
				Try
						lcDynamicBackColor = "IIF(" +;
							"replaced, " + Padr(Thisform.nReplacedDynamicBackColour, 8) + ", " +;
							"Rgb(255,255,255))"
		
						loColumn = Thisform.oGrid.FindColumn("FileName")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("TrimmedMatchLine")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("Class")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("Name")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("MethodName")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("ContainingClass")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
		*/ SF 20230213 replace colour for normal fields, just to make it visible if not in replace mode
					Catch
		*grid not instantiated yet
				Endtry
				Thisform.FormatGridForReplaceMode()
		
		* &&m.llEnteringReplaceMode
			Case m.llLeavingReplaceMode
		*turn off replace colour
				Try
						loColumn = Thisform.oGrid.FindColumn("FILEPATH")
						lcDynamicBackColor = m.loColumn.DynamicBackColor
		
						loColumn = Thisform.oGrid.FindColumn("FileName")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("TrimmedMatchLine")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("Class")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("Name")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("MethodName")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
						loColumn = Thisform.oGrid.FindColumn("ContainingClass")
						loColumn.DynamicBackColor = m.lcDynamicBackColor
					Catch
				Endtry
				Thisform.FormatGridForReplaceMode()
		
		* &&m.llLeavingReplaceMode
		Endcase
		
	ENDPROC

	PROCEDURE lreplace_history_assign
		Lparameters;
			tlNewValue
		
		Local;
			llOldValue As Boolean
		
		llOldValue            = This.lReplace_History
		This.lReplace_History = m.tlNewValue
		
		*switch modus Show Replace
		Do Case
			Case m.llOldValue And  !m.tlNewValue
		*turn off
				This.lblSearch.Visible                                 = .T.
				This.comboSearchExpressionHistory.Visible              = .T.
				This.editSearch.Visible                                = .T.
				This.comboSearchScopeHistory.Visible                   = .T.
				This.lblScope.Visible                                  = .T.
				This.comboSearchExpressionHistoryDropDownArrow.Visible = .T.
				This.imgScopeIcon.Visible                              = .T.
				This.imgProj_Pick.Visible                              = .T.
				This.imgFolder_Pick.Visible                            = .T.
				This.ButtonContainer.Visible                           = .T.
		
				This.lblReplaceHistory.Visible                         = .F.
		
		*restore normal search view, from scratch
				If Thisform.lRestorePreviousSearchResultsOnStartup
					If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
						Thisform.PopulateTreeFromHistory()
		
					Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
		?				Thisform.RestorePreviousSearch()
		
					Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
				Else &&Thisform.lRestorePreviousSearchResultsOnStartup
					If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
		?				Thisform.PopulateTreeview(,"Results")
		
					Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
		?				Thisform.PopulateTreeview()
		
					Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
				Endif &&Thisform.lRestorePreviousSearchResultsOnStartup
		
		*/turn off
			Case !m.llOldValue And m.tlNewValue
		*turn on
				This.lblSearch.Visible                                 = .F.
				This.comboSearchExpressionHistory.Visible              = .F.
				This.editSearch.Visible                                = .F.
				This.comboSearchScopeHistory.Visible                   = .F.
				This.lblScope.Visible                                  = .F.
				This.comboSearchExpressionHistoryDropDownArrow.Visible = .F.
				This.imgScopeIcon.Visible                              = .F.
				This.imgProj_Pick.Visible                              = .F.
				This.imgFolder_Pick.Visible                            = .F.
				This.ButtonContainer.Visible                           = .F.
		
				This.lblReplaceHistory.Visible                         = .T.
		
		*show replace history, full size
				Thisform.PopulateTreeFromHistory()
		
		*/turn on
		Endcase
		*/switch modus Show Replace
		
		
		
	ENDPROC

	PROCEDURE mhelpnotes
	ENDPROC

	PROCEDURE navigatetomasterrecord
		Lparameters tnId
		
		Local lcFullSearchResults, lcMessage
		
		lcFullSearchResults = Thisform.oSearchEngine.cSearchResultsAlias
		
		Select (lcFullSearchResults)
		Locate for id = tnId
		
		If !Found()
			lcMessage = "Error locating selected record in master table. Id = [" + Alltrim(Str(tnId)) + "]"
			MessageBox(lcMessage, 0, "GoFish Error")
			Return .f.
		EndIf
		  
	ENDPROC

	PROCEDURE ncodewindowposition_assign
		Lparameters tnCodeWindowPosition
		Local llLockScreen, lnHeight, lnSplitterLeft, lnSplitterTop, lnWidth
		This.nCodeWindowPosition = m.tnCodeWindowPosition
		
		llLockScreen = Thisform.LockScreen = .F.
		If m.llLockScreen
			Thisform.LockScreen = .T.
		Endif
		
		With This.Containerright
			lnWidth	 = .Width
			lnHeight = .Height
		
			.Container1.Visible	= .T.
			.Splitter1.Visible	= .T.
			.Splitter3.Visible	= .T.
		
			Do Case
				Case m.tnCodeWindowPosition = 1
					With .Splitter1
						lnSplitterTop = .Top
						.Visible	  = .T.
					Endwith
					With .Container1
						.Anchor	= 0
						.Top	= 0
						.Left	= 0
						.Width	= m.lnWidth
						.Height	= m.lnSplitterTop
						.Anchor	= 10
					Endwith
		
					With .Container2
						.Anchor	= 0
						.Top	= m.lnSplitterTop + 10
						.Left	= 0
						.Width	= m.lnWidth
						.Height	= Max(10, m.lnHeight - .Top)
						.Anchor	= 15
					Endwith
					.Splitter3.Visible = .F.
		
				Case m.tnCodeWindowPosition = 2
					With .Splitter3
						lnSplitterLeft = .Left
						.cObject1Name  = "Container1"
						.cObject2Name  = "Container2"
						.Visible	   = .T.
					Endwith
					With .Container1
						.Anchor	= 0
						.Top	= 0
						.Left	= 0
						.Width	= m.lnSplitterLeft
						.Height	= m.lnHeight
						.Anchor	= 5
					Endwith
		
					With .Container2
						.Anchor	= 0
						.Top	= 0
						.Left	= m.lnSplitterLeft + 10
						.Width	= Max(10, m.lnWidth - .Left)
						.Height	= m.lnHeight
						.Anchor	= 15
					Endwith
					.Splitter1.Visible = .F.
		
				Case m.tnCodeWindowPosition = 3
					With .Splitter3
						lnSplitterLeft = .Left
						.cObject1Name  = "Container2"
						.cObject2Name  = "Container1"
						.Visible	   = .T.
					Endwith
					With .Container2
						.Anchor	= 0
						.Top	= 0
						.Left	= 0
						.Width	= m.lnSplitterLeft
						.Height	= m.lnHeight
						.Anchor	= 5
					Endwith
		
					With .Container1
						.Anchor	= 0
						.Top	= 0
						.Left	= m.lnSplitterLeft + 10
						.Width	= Max(10, m.lnWidth - .Left)
						.Height	= m.lnHeight
						.Anchor	= 15
					Endwith
					.Splitter1.Visible = .F.
		
		
				Otherwise
		
			Endcase
		
		Endwith
		
		Thisform.Refresh()
		
		If m.llLockScreen
			Thisform.LockScreen = .F.
		Endif
		
		Thisform.oBrowser.SetFocus()
		
		
	ENDPROC

	PROCEDURE nreplacemode_assign
		Lparameters tnReplaceMode
		
		Local;
			loColumn     As Object,;
			loReplaceColumn As Object
		
		If Thisform.lInit And m.tnReplaceMode = 4 And m.tnReplaceMode <> Thisform.nReplaceMode
			Do Form gofish_advaccedreplacehelp With Thisform
		Endif
		
		*switch modus Show Replace
		Do Case
			Case m.tnReplaceMode#5 And !This.lblSearch.Visible;
					Or !Thisform.lReplaceViewMode
		*turn off
		*.<<@N>>.VISIBLE =
				This.lReplace_History = .F.
		
			Case m.tnReplaceMode=5 And This.lblSearch.Visible
		*turn on
				This.lReplace_History = .T.
		
		Endcase
		*/switch modus Show Replace
		
		If Inlist(This.nReplaceMode,1,5) = Inlist(m.tnReplaceMode,2,3,4) Then
		*switch mode (off, show replaced)
			This.nReplaceMode                   = m.tnReplaceMode
			Thisform.oSearchEngine.nReplaceMode = m.tnReplaceMode-1
			Thisform.FormatGridForReplaceMode()
		
		Else  &&Inlist(This.nReplaceMode,1,5) = Inlist(m.tnReplaceMode,2,3,4)
		*keep mode (off, show replaced)
			This.nReplaceMode                   = m.tnReplaceMode
			Thisform.oSearchEngine.nReplaceMode = m.tnReplaceMode-1
		
		Endif &&Inlist(This.nReplaceMode,1,5) = Inlist(m.tnReplaceMode,2,3,4)
		
		Thisform.AdjustFormForReplacePanel()
		
		*-- Need to refresh the grid with new Replace Line values from the selected mode
		* only if not off or show replace records mode
		If This.lInit And !Thisform.lSearching And Inlist(m.tnReplaceMode,2,3,4)
			Thisform.DoReplace(.T.) && .t. means do a "Preview" Replace
		Endif
		
		*-- Adjust header caption of Replace column
		loColumn                 = This.oGrid.FindColumn("Process")
		loColumn.Header1.Caption = Iif(INLIST(Thisform.nReplaceMode, 1, 5), "Replaced", "Replace")
		
	ENDPROC

	PROCEDURE populatenewsearch		&& Populate / Add a new search to the Treeview.
		*******************************************************************************
		*                                                                             *
		*  Abstract                                                                   *
		*  Fill the search treeview with results                                      *
		*  - a single node naming the result scope                                    *
		*  - a search result branch for a single result                               *
		*                                                                             *
		*  called by                                                                  *
		*  - PopulateTreeFromHistory                                                  *
		*  - PopulateTreeView                                                         *
		*                                                                             *
		*  directly controlled by                                                     *
		*  - lCR_HistoryTree                                                          *
		*                                                                             *
		*  indirectly controlled by                                                   *
		*  - lCR_SimpleTree                                                           *
		*  - lCR_SortTreeByExt                                                        *
		*  - search form internal filters                                             *
		*                                                                             *
		* depending on lCR_HistoryTree                                                *
		* - create a result node                                                      *
		*   - if empty(tcRoot) topmost                                                *
		*   - else as child of tcRoot                                                 *
		*                                                                             *
		* Parameters                                                                  *
		* ==========                                                                  *
		* tcRoot                                                                      *
		*  Root for search branch, optional                                           *
		*  if lCR_HistoryTree                                                         *
		*    if !empty defines parent for scope node to create                        *
		*    if empty scope node will become topmost                                  *
		*  else the just the result (w/o scope) will under tcRoot                     *
		*                                                                             *
		* tcUni                                                                       *
		*  unique ID of the search                                                    *
		*                                                                             *
		* tcSearch                                                                    *
		*  Search expression, for storage purposes                                    *
		*                                                                             *
		* tcScope                                                                     *
		*  Scope expression, for storage purposes                                     *
		*                                                                             *
		* tcText                                                                      *
		*  Text of node to create, see tcRoot, optional                               *
		*                                                                             *
		* tcNFilter                                                                   *
		*  Filter expression for node, for storage purposes                           *
		*                                                                             *
		* tlFill                                                                      *
		*  the branch will be filled with the information                             *
		*                                                                             *
		* tlExpand                                                                    *
		*  the node will expanded                                                     *
		*                                                                             *
		* Return                                                                      *
		* ======                                                                      *
		* Top node of the result branch                                               *
		*                                                                             *
		* SF 2022/11/13                                                               *
		*                                                                             *
		*******************************************************************************
		Lparameters tcRoot, tcUni, tcSearch, tcScope, tcText, tcNFilter, tlFill, tlExpand
		
		Local lcAlias, lcRoot
		Local loNode
		Local loTree, lnSelect0, llExpand
		
		lnSelect0 = Select()
		
		*	Thisform.LockWindow(.t.)
		
		lcAlias = This.cSearchResultsAlias
		loTree  = Thisform.containerLeft.oTreeView
		loNode = .Null.
		
		With m.loTree.Nodes
		
			lcRoot   = m.tcRoot
			llExpand = .T.
		
			If This.lReplace_History Or Thisform.lCR_HistoryTree Then
				lcRoot  = m.tcRoot + "_" + m.tcUni
		
				If Empty(m.tcRoot) Then
					loNode = .Add(, 2, m.lcRoot, m.tcText, ,)
				Else  &&Empty(m.tcRoot)
					loNode = .Add(m.tcRoot, 4, m.lcRoot, m.tcText, ,)
				Endif &&Empty(m.tcRoot)
		
				loNode.Tag      = Thisform.Get_oNodeTag("HISTORY", m.tcUni, m.tcSearch, m.tcScope, "",;
					[ cUni = "] + m.tcUni + ["],;
					"", "", "", "",!m.tlFill)
				loNode.Bold	    = .T.
				loNode.Expanded = tlExpand
				llExpand        = tlExpand
		
			Else  &&This.lReplace_History Or Thisform.lCR_HistoryTree
				If !Empty(m.tcRoot) Then
					loNode	= m.loTree.Nodes(m.lcRoot)
		
				Endif &&!Empty(m.tcRoot)
			Endif &&This.lReplace_History Or Thisform.lCR_HistoryTree
		
			If m.tlFill Then
				If Reccount(m.lcAlias)>0 Then
					Thisform.PopulateNode(m.lcRoot, m.tcUni, m.tcSearch, m.tcScope, m.tcNFilter)
		
				Endif &&Reccount(m.lcAlias)>0
			Endif &&m.tlFill
		Endwith
		
		Select (m.lnSelect0)
		
		Return m.loNode
		
	ENDPROC

	PROCEDURE populatenode		&& Populate / Expand a single Node.
		*******************************************************************************
		*                                                                             *
		*  Abstract                                                                   *
		*  Fill the search scape node with the files classes etc                      *
		*  - in a more or less complex pattern                                        *
		*                                                                             *
		*  called by                                                                  *
		*  - PopulateNewSearch                                                        *
		*  - TreeView_NodeExpand                                                      *
		*                                                                             *
		*  directly controlled by                                                     *
		*  - lCR_SimpleTree                                                           *
		*  - lCR_SortTreeByExt                                                        *
		*                                                                             *
		*  indirectly controlled by                                                   *
		*  - search form internal filters                                             *
		*                                                                             *
		* depending on lCR_SimpleTree                                                 *
		* - branch will just hold filenames                                           *
		* - branch will hold complex structure with file types, classes etc           *
		*                                                                             *
		* depending on lCR_SortTreeByExt                                              *
		* only when lCR_SimpleTree                                                    *
		* - sort filenames by extension first                                         *
		*                                                                             *
		* Parameters                                                                  *
		* ==========                                                                  *
		* tcRoot                                                                      *
		*  Root to place the branch to                                                *
		*                                                                             *
		* tcUni                                                                       *
		*  unique ID of the search                                                    *
		*                                                                             *
		* tcSearch                                                                    *
		*  Search expression, for storage purposes                                    *
		*                                                                             *
		* tcScope                                                                     *
		*  Scope expression, for storage purposes                                     *
		*                                                                             *
		* tcNFilter                                                                   *
		*  Filter expression for node, for storage purposes                           *
		*  - used to create result set of nodes                                       *
		*                                                                             *
		* tlExpand                                                                    *
		*  the node will expanded                                                     *
		*                                                                             *
		* Return                                                                      *
		* ======                                                                      *
		* n/a                                                                         *
		*                                                                             *
		* SF 2022/11/13                                                               *
		*                                                                             *
		*******************************************************************************
		Lparameters tcRoot, tcUni, tcSearch, tcScope, tcNFilter
		
		Local lcAlias, lcClass, lcFileName, lcFileType, lcFilePath
		Local lcNFilter, lcWhere, lnSelect, loNode
		Local loTree, lcRoot, lnSelect0
		
		Local Array;
			laOthers[1]
		
		lnSelect0 = Select()
		
		*	Thisform.LockWindow(.t.)
		
		lcAlias	= This.cSearchResultsAlias
		loTree	= Thisform.containerLeft.oTreeView
		lcWhere	= Iif(Empty(m.tcNFilter), "", "Where ") + m.tcNFilter
		
		lcNFilter = Iif(Empty(m.tcNFilter), "", "(" + m.tcNFilter + ") And ")
		
		If This.lCR_SimpleTree And This.lCR_SortTreeByExt Then
			Select;
				UPPER(FileType) As cExt,;
				*  From (m.lcAlias);
				&lcWhere;
				Order By 1, FileName, FilePath;
				Into Cursor "curFiles"
		
		Else  &&This.lCR_SimpleTree AND This.lCR_SortTreeByExt
			Select;
				*  From (m.lcAlias);
				&lcWhere;
				Order By FileName, FilePath;
				Into Cursor "curFiles"
		
		Endif &&This.lCR_SimpleTree AND This.lCR_SortTreeByExt
		
		If Reccount("curFiles")>0 Then
			With m.loTree.Nodes
		
				If !This.lCR_SimpleTree Then
		*-- Create main category nodes if present in the filtered results -
		* ================================================================================
		* new code for classes
					Locate For Not Empty(Class)
					If Found() Then
						loNode	= .Add(m.tcRoot, 4, m.tcUni + "Root_Classes", "Classes", ,)
		
						loNode.Tag  = Thisform.Get_oNodeTag("LISTCLASS", m.tcUni, m.tcSearch, m.tcScope, "",;
							m.lcNFilter + "(not Empty(class) and (Upper(Filetype) $ [ VCX PRG ]))",;
							"", "", "", "", .F.)
						lnSelect	= Select()
						lcWhere	    = "Where " + m.tcNFilter + Iif(Empty(m.tcNFilter), "", " and") + [ InList(filetype, "PRG", "VCX") and Not Empty(Class)]
		
						loNode.Bold	    = .T.
						loNode.Expanded = .T.
		
						Select  Lower(Class)       As  Class,			;
							FileType,								;
							FileName,								;
							Lower(FilePath)    As  FilePath,		;
							Min(Id)            As  Id				;
							From curFiles									;
							&lcWhere								;
							Group By Class, FileType, FileName, FilePath			;
							Order By 1, 2, 3, 4							; && 2021-03-21 Change submmited by JRN
						Into Cursor crsr_Classes Readwrite
		
						Scan
							lcFilePath = Trim(FilePath)
							lcFileName = Trim(FileName)
							lcFileType = Trim(FileType)
							lcClass	   = Trim(Class)
		
							Select * From crsr_Classes Where Class = m.lcClass And FileName # m.lcFileName Into Array laOthers
							If _Tally # 0
								loNode = .Add(m.tcUni + "Root_Classes", 4, m.tcUni + "Class_" + Alltrim(Str(Id)) + "_X", m.lcClass + " (" + Justfname(m.lcFileName) + ")", ,)
							Else
								loNode = .Add(m.tcUni + "Root_Classes", 4, m.tcUni + "Class_" + Alltrim(Str(Id)) + "_X", m.lcClass, ,)
							Endif
		
							loNode.Tag = Thisform.Get_oNodeTag("LISTED_CLASS", m.tcUni, m.tcSearch, m.tcScope, "",;
								m.lcNFilter + "(filepath = [" + m.lcFilePath + "]" + " and " + [lower(class) = "] + m.lcClass + [")],;
								m.lcFilePath, m.lcFileName, m.lcFileType, m.lcClass, .F.)
		
						Endscan
						Select(m.lnSelect)
					Endif
		* ================================================================================
		
					Locate For Upper(FileType) = "VCX"
					If Found()
						loNode			 = .Add(m.tcRoot, 4, m.tcUni + "Root_VCX", "ClassLibs", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "VCX",;
							m.lcNFilter + "Upper(Filetype) = [VCX]",;
							"", "", "", "", .F.)
					Endif
		
					Locate For Upper(FileType) = "SCX"
					If Found()
						loNode			 = .Add(m.tcRoot, 4, m.tcUni + "Root_SCX", "Forms", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "SCX",;
							m.lcNFilter + "Upper(Filetype) = [SCX]",;
							"", "", "", "", .F.)
					Endif
		
					Locate For Upper(FileType) = "PRG"
					If Found()
						loNode		   = .Add(m.tcRoot, 4, m.tcUni + "Root_PRG", "Programs", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "PRG",;
							m.lcNFilter + "Upper(Filetype) = [PRG]",;
							"", "", "", "", .F.)
					Endif
		
					Locate For Upper(FileType) = "FRX"
					If Found()
						loNode		   = .Add(m.tcRoot, 4, m.tcUni + "Root_FRX", "Reports", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "FRX",;
							m.lcNFilter + "Upper(Filetype) = [FRX]",;
							"", "", "", "", .F.)
					Endif
		
					Locate For Inlist(Upper(FileType), "MNX", "MPR")
					If Found()
						loNode		   = .Add(m.tcRoot, 4, m.tcUni + "Root_MPX", "Menus", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "MNX",;
							m.lcNFilter + "(Upper(Filetype) = [MNX] or Upper(Filetype) = [MPR])",;
							"", "", "", "", .F.)
					Endif
		
					Locate For Upper(FileType) = "DBF"
					If Found()
						loNode		   = .Add(m.tcRoot, 4, m.tcUni + "Root_DBF", "Tables", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "DBF",;
							m.lcNFilter + "Upper(Filetype) = [DBF]",;
							"", "", "", "", .F.)
					Endif
		
					Locate For Upper(FileType) = "PJX"
					If Found()
						loNode		   = .Add(m.tcRoot, 4, m.tcUni + "Root_PJX", "Projects", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "PJX",;
							m.lcNFilter + "Upper(Filetype) = [PJX]",;
							"", "", "", "", .F.)
					Endif
		
					Locate For Not (Upper(FileType) $ " SCX VCX PRG FRX DBF PJX MNX MPR ")
					If Found()
						loNode			 = .Add(m.tcRoot, 4, m.tcUni + "Root_OTHER", "Other", ,)
						loNode.Expanded = .T.
						loNode.Tag = Thisform.Get_oNodeTag("TYPE", m.tcUni, m.tcSearch, m.tcScope, "OTHER",;
							m.lcNFilter + "!(Upper(Filetype) $ [ SCX VCX PRG FRX DBF PJX MNX MPR])",;
							"", "", "", "", .F.)
					Endif
		
				Endif &&!This.lCR_SimpleTree
		
		*-- Now populate each category node -------------------------------
				Scan
					lcFilePath = Trim((FilePath))
					lcFileName = Trim(FileName)
					lcFileType = Trim(FileType)
		
					Do Case
						Case This.lCR_SimpleTree
							lcRoot = m.tcRoot
						Case "_" + m.lcFileType + "_" $ "_SCX_VCX_PRG_FRX_DBF_PJX_"
							lcRoot = m.tcUni + "Root_" + m.lcFileType
						Case "_" + m.lcFileType + "_" $ "_MNX_MPR_"
							lcRoot = m.tcUni + "Root_MPX"
						Otherwise
							lcRoot = m.tcUni + "Root_OTHER"
					Endcase
		
					loNode			   = .Add(m.lcRoot, 4, m.tcUni + "File_" + Alltrim(Str(Id)) + "_" + lcFilePath, m.lcFileName, ,)
					loNode.Parent.Bold = .T.
					loNode.Expanded	   = .T.
					loNode.Tag = Thisform.Get_oNodeTag("FILE", m.tcUni, m.tcSearch, m.tcScope, "m.lcFileType",;
						m.lcNFilter + "filepath = [" + m.lcFilePath + "]",;
						m.lcFilePath, m.lcFileName,  "", "", .F.)
		
					If !This.lCR_SimpleTree And m.lcFileType = "VCX"
						loNode.Expanded = .F.
						Thisform.AddClassesToTreeView(m.loNode, m.tcUni, m.tcSearch, m.tcScope, m.lcNFilter + "filepath = [" + m.lcFilePath + "]")
					Endif
		
					Locate For Trim(FilePath) # m.lcFilePath Rest && Jump To next FileName
		
					If Not Eof()
						Skip - 1
					Endif
		
				Endscan
			Endwith
		Endif &&Reccount("curFiles")>0
		
		Use In Select("curFiles")
		Select (m.lnSelect0)
		
	ENDPROC

	PROCEDURE populatetreefromhistory		&& Populate Tree with all previeous searches (per scope filter)
		*******************************************************************************
		*                                                                             *
		*  Abstract                                                                   *
		*  Fill the search history / treeview with history                            *
		*                                                                             *
		*  called when                                                                *
		*  - lCR_Allow                                                                *
		*  - lCR_HistoryTree                                                          *
		*                                                                             *
		*  directly controlled by                                                     *
		*  - lCR_HistoryTreeAuto                                                      *
		*                                                                             *
		*  indirectly controlled by                                                   *
		*  - lCR_HistoryPerScope                                                      *
		*  - lCR_SimpleTree                                                           *
		*  - lCR_SortTreeByExt                                                        *
		*  - search form internal filters                                             *
		*                                                                             *
		* Clears the Tree                                                             *
		*                                                                             *
		* depending on lCR_HistoryTreeAuto                                            *
		* - Creates Common root node if lCR_HistoryTreeAuto                           *
		*   else some data will not exist and code fail                               *
		* - Fill all result nodes with children                                       *
		* - or just the last recent search                                            *
		*                                                                             *
		* Parameters                                                                  *
		* ==========                                                                  *
		* n/a                                                                         *
		*                                                                             *
		* Return                                                                      *
		* ======                                                                      *
		* n/a                                                                         *
		*                                                                             *
		* SF 2022/11/13                                                               *
		*                                                                             *
		*******************************************************************************
		Local;
			lcFolder     As String,;
			lcAlias      As String,;
			lcAlias2     As String,;
			lcRootText   As String,;
			lcUni        As String,;
			lcSearch     As String,;
			lcScope      As String,;
			lcFilePath   As String,;
			lcRoot       As String,;
			lcFilter     As String,;
			lcNFilter    As String,;
			lcWhere      As String,;
			lcText       As String,;
			lcMakro      As String,;
			lcSetEscape  As String,;
			lnResult     As Integer,;
			lnResults    As Integer,;
			lnSelect     As Integer,;
			lnLastRec    As Integer,;
			lnColor      As Integer,;
			lnLastIndex  As Integer,;
			llLockScreen As Boolean,;
			llReturn     As Boolean,;
			llFillSearch As Boolean,;
			llEscaped    As Boolean,;
			loTree       As Object,;
			loNode       As Object
		
		lnSelect = Select()
		
		lcFolder  = ""
		lnResult  = 0
		
		lnResults = Thisform.BuildSearchHistoryCursor()
		
		If m.lnResults # 0 Then
			Thisform.oSearchEngine.oProgressBar = Thisform.ProgressBar
			Thisform.ProgressBar.Start(5 + m.lnResults, "Loading history results...")
			Thisform.ProgressBar.nValue = 5
			Thisform.Refresh()
		
			Thisform.ClearSearchResultsCursor() && Go ahead and blank out the cursor so the grid will be empty during the search
			Thisform.ClearTreeView()
		
			Select gf_SearchHistory
			If Thisform.lCR_SortTreeAlpha Then
				Set Order To
		
			Else  &&Thisform.lCR_SortTreeAlpha
				Set Order To _DateT Ascending
		
			Endif &&Thisform.lCR_SortTreeAlpha
		
			Go Bottom
			lnLastRec = Recno()
		
			lcAlias			 ="gf_SearchHistory"
			loTree			 = Thisform.containerLeft.oTreeView
			loTree.LabelEdit = 1
		
			This.lSearching = .T.
			This.LockScreen = .F.
		
			llLockScreen = loTree.Visible
		
			If m.llLockScreen
				loTree.Visible = .F.
			Endif
		
			lcSetEscape = Set("Escape")
			Set Escape Off
		
			lcRootText = "Results"
			lnColor    = 0
		
			With m.loTree.Nodes
		
				lcUni    = ""
				lcSearch = ""
				lcScope  = ""
				If This.lCR_HistoryPerScope Then
					lcScope  = Scope
				Endif &&This.lCR_HistoryPerScope
				lcRoot   = ""
				lcFilter = Filter(m.lcAlias)
		
				.Clear()
		
		*without "Results"
				If Thisform.lCR_HistoryTreeAuto Then
		*-- Add topmost and first "Results" node  ----------------------------
		* If we like to show a topmost single node
					lcRoot = "Results"
		
					loNode           = .Add(, 2, m.lcRoot, m.lcRootText, ,)
					loNode.Tag       = Thisform.Get_oNodeTag("ROOT", m.lcUni, m.lcSearch, m.lcScope, "", "", "", "", "", "", .F.)
					loNode.Expanded	 = .T.
					loNode.Bold		 = (Reccount(m.lcAlias) > 0) Or Pcount() > 0
					loNode.ForeColor = m.lnColor
		
				Endif &&Thisform.lCR_HistoryTreeAuto
		
				If !This.lReplace_History And This.lCR_HistoryPerScope Then
					llReturn = This.LoadSavedResults(m.lcScope, , 1)
		
				Else  &&!This.lReplace_History And This.lCR_HistoryPerScope
					llReturn = This.LoadSavedResults("", , 2)
		
				Endif &&!This.lReplace_History And This.lCR_HistoryPerScope
		
		
				If Inkey() = 27 Then
		*!* ** } JRN -- 07/11/2016 08:11 AM - End
					Clear Typeahead
					llEscaped = .T.
				Else  &&Inkey() = 27
		
		*?			Thisform.ApplyFilter()
		*			Thisform.GetFilter()
		
					If Inkey() = 27 Then
		*!* ** } JRN -- 07/11/2016 08:11 AM - End
						Clear Typeahead
						llEscaped = .T.
					Else  &&Inkey() = 27
		
						llReturn = Thisform.FillSearchResultsCursor(m.llFillSearch) && Pulls records from the search engine's results cursor.
						lcAlias2 = This.cSearchResultsAlias
		
						If Inkey() = 27 Then
		*!* ** } JRN -- 07/11/2016 08:11 AM - End
							Clear Typeahead
							llEscaped = .T.
						Endif &&Inkey() = 27
					Endif &&Inkey() = 27
				Endif &&Inkey() = 27
		
				Select (m.lcAlias)
		
				Scan For !m.llEscaped
					lcUni     = cUni
					lcSearch  = Search
					lcScope   = Scope
					lcText    = Search
					lcWhere   = Iif(Empty(m.lcFilter), "", m.lcFilter + " AND ")+ [cUni == "] + m.lcUni+["]
					lcNFilter = [cUni == "] + m.lcUni+["]
		
					llFillSearch = m.lnLastRec=Recno(m.lcAlias) Or Thisform.lCR_HistoryTreeAuto
					If m.llFillSearch Then
		*Last search, we expand
						lnLastIndex = .Count
						lcFilePath  = Trim(m.lcUni)
		
						Select (m.lcAlias2)
		
						THIS.Set_SearchResultsAlias_Filter(m.lcWhere)
						Go Top
		
						llReturn = !Eof(m.lcAlias2)
		*				If !Eof(m.lcAlias2) Then
		
						Select (m.lcAlias2)
		
						Do Case
							Case !m.llReturn
		*No record (result) found
		*create node, add child with info
								loNode          = Thisform.PopulateTreeview(m.lcRoot, m.lcText, , Thisform.nTreeUpdateColour)
								loNode.Tag      = Thisform.Get_oNodeTag("HELP", m.lcUni, ".F.", "", "", ".F.", "", "", "", "", .F.)
								loNode.Expanded = .T.
		
								loNode     = Thisform.PopulateTreeview(loNode.Key, "No Result found", , Thisform.nTreeUpdateColour)
								loNode.Tag = Thisform.Get_oNodeTag("HELP", "HELP" + m.lcUni, ".F.", "", "", ".F.", "", "", "", "", .F.)
							Case m.lnLastRec=Recno(m.lcAlias)
		*Last recent search, populate
								This.PopulateNewSearch(m.lcRoot, m.lcUni, m.lcSearch, m.lcScope, m.lcText, m.lcNFilter, m.llFillSearch,.T.)
		
							Otherwise
		*Not last recent search,
		*create node, add dummy child so it looks expandable (will be filled when expanded)
								loNode     = This.PopulateNewSearch(m.lcRoot, m.lcUni, m.lcSearch, m.lcScope, m.lcText, m.lcNFilter, .F., .F.)
								If !Isnull(m.loNode)
									loNode     = .Add(m.loTree.Nodes(.Count).Key, 4, "HELP_" + m.lUni, "", ,)
									loNode.Tag = Thisform.Get_oNodeTag("HELP", "HELP" + m.lcUni, m.lcSearch, m.lcScope, "", "", "", "", "", "", .F.)
								Endif &&!Isnull(m.loNode)
		
						Endcase
		
						If Inkey() = 27
		*!* ** } JRN -- 07/11/2016 08:11 AM - End
							Clear Typeahead
							llEscaped = .T.
							Exit
						Endif
		*				Endif &&!EOF(m.lcAlias2)
					Else  &&m.llFillSearch
		*search for node not filled
						loNode     = This.PopulateNewSearch(m.lcRoot, m.lcUni, m.lcSearch, m.lcScope, m.lcText, m.lcNFilter, .F., .F.)
		
						If !Isnull(m.loNode)
							loNode     = .Add(m.loTree.Nodes(.Count).Key, 4, "HELP_" + m.lcUni, "", ,)
							loNode.Tag = Thisform.Get_oNodeTag("HELP", m.lcUni, m.lcSearch, m.lcScope, "", "", "", "", "", "", .F.)
						Endif &&!Isnull(m.loNode)
		
					Endif &&m.llFillSearch
					lnResult = m.lnResult+1
					Thisform.ProgressBar.nValue = 5 + m.lnResult
					Thisform.ProgressBar.Refresh
		
				Endscan &&All
			Endwith &&m.loTree.Nodes
		
			This.lSearching = .F.
		
			If !m.llEscaped Then
				If m.loTree.Nodes.Count >1 Then
					loTree.LineStyle = 1
		
					Thisform.ShowCodeForCurrentRow()
		
		*		IF m.llReturn AND
					This.FormatProcessColumn()
		
					If !Empty(m.lnLastIndex) Then
						loNode = m.loTree.Nodes(m.lnLastIndex+1)
						If Vartype(m.loNode)="O" Then
							loTree.SelectedItem	= m.loNode
		
							loNode.Selected = .T.
							loNode.ENSUREVISIBLE()
						Endif &&VARTYPE(m.loNode)="O"
		
					Endif &&!EMPTY(m.lnLastIndex)
		
				Else  &&m.loTree.Nodes.Count >1
					loTree.LineStyle = 0
		
				Endif &&m.loTree.Nodes.Count >1
			Endif &&!m.llEscaped
		
			If m.llLockScreen
				loTree.Visible = .T.
			Endif
			Set Escape &lcSetEscape
		
		*	Thisform.UpdateFormAfterSearch()
			This.FormatProcessColumn()
		
			Thisform.ProgressBar.Stop()
			Thisform.Containerright.Container2.Visible = .T.
		
		Else  &&m.lnResults # 0
		
			lcRootText = "Results"
			lnColor    = 0
		
			Thisform.ClearSearchResultsCursor()
		
			With Thisform.containerLeft.oTreeView.Nodes
		
				lcUni    = ""
				lcSearch = ""
				lcScope  = ""
				lcRoot   = ""
				lcFilter = ""
		
				.Clear()
		
		*without "Results"
				lcRoot = "Results"
		
				loNode           = .Add(, 2, m.lcRoot, m.lcRootText, ,)
				loNode.Tag       = Thisform.Get_oNodeTag("ROOT", m.lcUni, m.lcSearch, m.lcScope, "", "", "", "", "", "", .F.)
		
			Endwith &&Thisform.containerLeft.oTreeView.Nodes
			Thisform.containerLeft.oTreeView.SelectedItem	= m.loNode
		
			loNode.Selected = .T.
			loNode.ENSUREVISIBLE()
		
			This.TreeView_NodeClick(m.loNode)
		
			Thisform.ShowCodeForCurrentRow()
		
		Endif &&m.lnResults # 0
		
		Select(m.lnSelect)
		
		Return m.llReturn
		
	ENDPROC

	PROCEDURE populatetreeview		&& Fill the Treeview.
		*******************************************************************************
		*                                                                             *
		*  Abstract                                                                   *
		*  Fill the search treeview                                                   *
		*  - a single node                                                            *
		*  - a search result branch for a single result                               *
		*                                                                             *
		*  called by                                                                  *
		*  - PopulateTreeFromHistory                                                  *
		*  - UpdateTreeView                                                           *
		*  - LoadFormSettings                                                         *
		*  - DoSearch                                                                 *
		*  - Init                                                                     *
		*                                                                             *
		*  directly controlled by                                                     *
		*  - lCR_HistoryTree                                                          *
		*                                                                             *
		*  indirectly controlled by                                                   *
		*  - lCR_HistoryPerScope                                                      *
		*  - lCR_SimpleTree                                                           *
		*  - lCR_SortTreeByExt                                                        *
		*  - search form internal filters                                             *
		*                                                                             *
		* Removes search notification from tree                                       *
		*                                                                             *
		* depending on lCR_HistoryTree                                                *
		* - if not set, clear the tree                                                *
		* - if set, define search criteria                                            *
		*                                                                             *
		* Parameters                                                                  *
		* ==========                                                                  *
		* tcRoot                                                                      *
		*  Root for Node, optional                                                    *
		*  defines parent for node to create                                          *
		*  if not found, node will become topmost                                     *
		*                                                                             *
		* tcText                                                                      *
		*  Text of Node, optional                                                     *
		*  if given only a node with this text will be created                        *
		*  else, a branch with the search defined by cursor will be created           *
		*                                                                             *
		* tcKey                                                                       *
		*  the key for the node, optional, only for !EMPTY(tcText)                    *
		*  if empty, sys(2015)                                                        *
		*                                                                             *
		* tnForeColor                                                                 *
		*  Forcolor of the node, optional                                             *
		*                                                                             *
		* tlSearchResult                                                              *
		*  Output the Result of a recent search                                       *
		*                                                                             *
		* Return                                                                      *
		* ======                                                                      *
		* top node of the result branch / node created                                *
		*                                                                             *
		* SF 2022/11/13                                                               *
		*                                                                             *
		*******************************************************************************
		Lparameters tcRoot, tcText, tcKey, tnForeColor, tlSearchResult
		
		Local lcAlias, lcRootText, lcNFilter
		Local lnForeColor, loNode
		Local loTree, lcRoot, lcUni, lcSearch, lcScope, lnSelect0, lcText, lcSetEscape, lcKey
		
		Local;
			lnLastRec    As Integer,;
			llLockScreen As Boolean,;
			llSubNode    As Boolean,;
			llClear      As Boolean
		
		* ================================================================================
		*** JRN 2024-03-04 : If not doing special CR style, do it the old way
		*** which filters
		If not This.lCR_Allow 
			This.PopulateTreeViewSimple(tcText, tnForeColor)
			Return
		EndIf 
		* ================================================================================
		
		lnSelect0 = Select()
		
		*	Thisform.LockWindow(.t.)
		
		lcAlias = This.cSearchResultsAlias
		loTree	= Thisform.containerLeft.oTreeView
		loNode  = .Null.
		
		loTree.LabelEdit = 1
		
		lcRootText  = Evl(m.tcText, "Results")
		lcKey       = Evl(m.tcKey, Sys(2015))
		lnForeColor = Evl(m.tnForeColor, 0)
		
		llSubNode   = .T.
		
		llLockScreen = loTree.Visible = .F.
		If m.llLockScreen
			loTree.Visible = .F.
		Endif
		lcSetEscape = Set("Escape")
		Set Escape Off
		
		Select (m.lcAlias)
		
		With m.loTree.Nodes
		
		*-- Add topmost 'Results' node  ----------------------------
			lcUni     = ""
			lcSearch  = ""
			lcScope   = ""
			lcRoot    = Evl(m.tcRoot,"Results")
			lcNFilter = ""
		
			If .Count = 1 And Thisform.lCR_HistoryTree And !Thisform.lCR_HistoryTreeAuto
		*empty tree in History tree - remove root
				loNode = .Item(.Count)
				If m.loNode.Key == m.lcRoot
		*no Parent, no root above us, we need to work as topmost
					loNode = .Null.
					.Remove(m.lcRoot)
					lcRoot = ""
				Endif &&m.loNode.Key == m.lcRoot
				loNode  = .Null.
			Endif &&.Count = 1 And Thisform.lCR_HistoryTree And !Thisform.lCR_HistoryTreeAuto
		
			If .Count > 0 Then
				loNode = .Item(.Count)
				If m.loNode.Key == "Searching..." Then
					loNode = m.loNode.Parent
					If Vartype(m.loNode) = "X" Then
		*no Parent, no root above us, we need to work as topmost
						lcRoot = ""
					Endif &&VARTYPE(m.loNode) = "X"
		
					loNode = .Null.
					.Remove("Searching...")
				Endif &&m.loNode.Key == "Searching..."
				loNode  = .Null.
			Endif &&.Count > 0
		
			If (Empty(m.tcRoot) And !Thisform.lCR_HistoryTree);
					Or (m.loTree.Nodes.Count = 0  And Thisform.lCR_HistoryTreeAuto);
					Or ((m.loTree.Nodes.Count = 0  And !Thisform.lRestorePreviousSearchResultsOnStartup And Thisform.lCR_HistoryTree))
					*;
					*AND !m.tlSearchResult) THEN 
		*create topmost and first node
		* If we like to show a topmost single node
				.Clear()
		
				loNode           = .Add(, 2, Evl(m.lcRoot, m.lcKey), m.lcRootText, ,)
				loNode.Tag       = Thisform.Get_oNodeTag("ROOT", m.lcUni, m.lcSearch, m.lcScope, "", "", "", "", "", "", .F.)
				loNode.Expanded	 = .T.
				loNode.Bold		 = (Reccount(m.lcAlias) > 0) Or Pcount() > 0
				loNode.ForeColor = m.lnForeColor
				loNode           = .Null.
		
				llSubNode = !(m.loTree.Nodes.Count = 1 And !Thisform.lRestorePreviousSearchResultsOnStartup And Thisform.lCR_HistoryTree) OR m.tlSearchResult
		        llClear   = .T.  
		
		
			Endif &&(Empty(m.tcRoot) And !Thisform.lCR_HistoryTree) Or (m.loTree.Nodes.Count = 0 And Thisform. ...
		
			If m.llSubNode Then
				If Empty(m.tcText) Then
		*if no message is given, create a search result branch
					lcText   = ""
		
					If (Thisform.lRestorePreviousSearchResultsOnStartup And Thisform.lCR_HistoryTree);
							OR m.tlSearchResult THEN 
						lnLastRec = Recno()
						Go Bottom && Search moves to top, but we need something on the end
						lcUni     = cUni
						lcSearch  = Search
						lcScope   = Scope
						lcNFilter = [cUni == "] + m.lcUni+["]
		
						lcText    = Search
						Goto (m.lnLastRec)
		
					Endif &&(Thisform.lRestorePreviousSearchResultsOnStartup And Thisform.lCR_HistoryTree) OR m.tlSearchResult
		
					loNode = This.PopulateNewSearch(m.lcRoot, m.lcUni, m.lcSearch, m.lcScope, m.lcText, m.lcNFilter, .T., .T.)
		
					If Vartype(m.loNode)="O" Then
						loTree.SelectedItem	= m.loNode
		*move search area in visible focus
		*show last node 
						m.loNode = loTree.nodes.Item(loTree.nodes.count)
						loNode.ENSUREVISIBLE()
		
		*show search node 
						loTree.SelectedItem.Selected = .T.
						loTree.SelectedItem.ENSUREVISIBLE()
		
					Endif &&VARTYPE(m.loNode)="O"
		
				Else  &&Empty(m.tcText)
		*if message is given, create just a single node
		
		*is the lcRoot is node, has a tag object and if this is of a certain flag like ROOT
		*if yes attach to this
		*else we are topmost
					Try
							loNode = .Null.
							loNode = m.loTree.Nodes(m.lcRoot)
		
						Catch
		*node not found  (lcRoot is not valid)
						Finally
							If Vartype(m.loNode)="X" And .Count > 0
		*not found (if found, lcRoot is valid)
								loNode = m.loTree.Nodes(1)
								If Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" And Inlist(m.loNode.Tag.gcLevel,"ROOT") Then
		*there is a common root, we use this as parent
									m.lcRoot = m.loNode.Key
		
								Else &&Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" And Inlist(m.loNode.Tag.gcLevel,"ROOT")
		*there is no common root (i.e. tree without common root)
									loNode = .Null.
								Endif &&Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" And Inlist(m.loNode.Tag.gcLevel,"ROOT")
							Endif &&VARTYPE(m.loNode)="X" And .Count > 0
		*
					Endtry
		
					If Vartype(m.loNode)="X" Then
		*no parent, create a new top most node at the end
						loNode = .Add(, 2, m.lcKey, m.tcText, ,)
		
					Else  &&Vartype(m.loNode)="X"
		*we have a parent, we attach to this
						loNode = .Add(m.lcRoot, 4, m.lcKey, m.tcText, ,)
		
					Endif &&Vartype(m.loNode)="X"
					loNode.Expanded	 = .F.
					loNode.ForeColor = m.lnForeColor
		
				Endif &&Empty(m.tcText)
			Endif &&m.llSubNode
			loTree.LineStyle = Iif(m.loTree.Nodes.Count >1 , 1, 0)
			
			IF m.llClear AND m.loTree.Nodes.Count=1 THEN
				This.containerRight.container2.ContainerWebControl.ShowHTML("")
		
			ENDIF &&m.llClear AND m.loTree.Nodes.Count=1 
		Endwith
		
		If m.llLockScreen
			loTree.Visible = .T.
		Endif
		Set Escape &lcSetEscape
		
		m.loTree.Refresh()
		
		Select (m.lnSelect0)
		
		Return m.loNode
		
	ENDPROC

	PROCEDURE populatetreeviewsimple
		Lparameters tcMessage, tnColor
		
		Local laOthers[1], lcAlias, lcClass, lcExt, lcFileName, lcFilePath, lcFilter, lcRoot, lcWhere
		Local lcWhere2, lnColor, lnSelect, loClassLibsNode, loClassNode, loDbfNode, loFormsNode, loNode
		Local loOtherNode, loPJXNode, loPrgNode, loReportsNode, loTreeView, loItemNode
		
		lnSelect = Select()
		
		*	Thisform.LockWindow(.t.)
		
		lcAlias				 = This.cSearchResultsAlias
		loTreeView			 = Thisform.containerLeft.oTreeView
		loTreeView.LabelEdit = 1
		
		lcRoot	= Evl(m.tcMessage, 'Results')
		lnColor	= Evl(m.tnColor, 0)
		
		loTreeView.Visible = .F.
		
		With m.loTreeView.Nodes
		
			.Clear()
		
			*-- Add topmost 'Results' node  ----------------------------
			loNode				 = .Add(, , 'Results', m.lcRoot, ,)
			loNode.Expanded		 = .T.
			loNode.Bold			 = (Reccount(m.lcAlias) > 0) Or Pcount() > 0
			loTreeView.LineStyle = Iif(Eof(m.lcAlias), 0, 1)
		
			loNode.ForeColor = m.lnColor
		
			lcFilter = Filter(m.lcAlias)
			lcWhere	 = Iif(Not Empty(m.lcFilter), 'Where ' + m.lcFilter, '')
		
			Select *  From (m.lcAlias) &lcWhere Order By FileName, FilePath Into Cursor 'Files'
		
			*-- Create main category nodes if present in the filtered results -
			* ================================================================================
			* new code for classes
			Locate For Not Empty(Class)
			If Found()
				loClassNode	= .Add('Results', 4, 'Root_Classes', 'Classes', ,)
				lnSelect	= Select()
				lcWhere2	= Iif(Not Empty(m.lcWhere), m.lcWhere + ' and', 'Where') + [ InList(filetype, 'PRG', 'VCX') and Not Empty(Class)] 
		
				Select  Lower(Class)       As  Class,			;
						FileName,								;
						Lower(FilePath)    As  FilePath,		;
						Min(Id)            As  Id				;
					From Files									;
						&lcWhere2								;
					Group By Class, FileName, FilePath			;
					Order By 1, 2, 3							; && 2021-03-21 Change submmited by JRN
					Into Cursor crsr_Classes Readwrite
		
				Scan
					lcClass	   = Class
					lcFileName = FileName
					Select * From crsr_Classes Where Class = m.lcClass And FileName # m.lcFileName Into Array laOthers
					If _Tally # 0
						loItemNode = .Add('Root_Classes', 4, 'Class_' + Alltrim(Str(Id)) + '_X', Trim(Class) + ' (' + Justfname(Trim(FileName)) + ')', ,)
					Else
						loItemNode = .Add('Root_Classes', 4, 'Class_' + Alltrim(Str(Id)) + '_X', Trim(Class), ,)
					EndIf
					
					loTag = CreateObject('Empty')
					AddProperty(loTag, 'Filename', Trim(FileName))
					AddProperty(loTag, 'FilePath', Trim(FilePath))
					AddProperty(loTag, 'Class', Trim(Class))
					loItemNode.tag = loTag
					
				Endscan
				loClassNode.Bold	 = .T.
				loClassNode.Expanded = .T.
				Select(m.lnSelect)
			Endif
			* ================================================================================
		
			Locate For Upper(FileType) = 'VCX'
			If Found()
				loClassLibsNode			 = .Add('Results', 4, 'Root_VCX', 'ClassLibs', ,)
				loClassLibsNode.Expanded = .T.
			Endif
		
			Locate For Upper(FileType) = 'SCX'
			If Found()
				loFormsNode			 = .Add('Results', 4, 'Root_SCX', 'Forms', ,)
				loFormsNode.Expanded = .T.
			Endif
		
			Locate For Upper(FileType) = 'PRG'
			If Found()
				loPrgNode		   = .Add('Results', 4, 'Root_PRG', 'Programs', ,)
				loPrgNode.Expanded = .T.
			Endif
		
			Locate For Upper(FileType) = 'FRX'
			If Found()
				loReportsNode		   = .Add('Results', 4, 'Root_FRX', 'Reports', ,)
				loReportsNode.Expanded = .T.
			Endif
		
			Locate For InList(Upper(FileType), 'MNX', 'MPR')
			If Found()
				loReportsNode		   = .Add('Results', 4, 'Root_MPX', 'Menus', ,)
				loReportsNode.Expanded = .T.
			Endif
		
			Locate For Upper(FileType) = 'DBF'
			If Found()
				loDbfNode		   = .Add('Results', 4, 'Root_DBF', 'Tables', ,)
				loDbfNode.Expanded = .T.
			Endif
		
			Locate For Upper(FileType) = 'PJX'
			If Found()
				loPJXNode		   = .Add('Results', 4, 'Root_PJX', 'Projects', ,)
				loPJXNode.Expanded = .T.
			Endif
		
			Locate For Not (Upper(FileType) $ ' SCX VCX PRG FRX DBF PJX MNX MPR ')
			If Found()
				loOtherNode			 = .Add('Results', 4, 'Root_OTHER', 'Other', ,)
				loOtherNode.Expanded = .T.
			Endif
		
			*-- Now populate each category node -------------------------------
			Scan
				lcFilePath = Alltrim(Upper(FilePath))
				lcExt	   = Upper(Justext(FilePath))
		
				Do Case
					Case '_' + m.lcExt + '_' $ '_SCX_VCX_PRG_FRX_DBF_PJX_'
						lcRoot = 'Root_' + m.lcExt
					Case '_' + m.lcExt + '_' $ '_MNX_MPR_'
						lcRoot = 'Root_MPX'
					Otherwise 
						lcRoot = 'Root_OTHER'
				Endcase
		
				loNode			   = .Add(m.lcRoot, 4, 'File_' + Alltrim(Str(Id)) + '_' + Alltrim(FilePath), Lower(Justfname(m.lcFilePath)), ,)
				loNode.Parent.Bold = .T.
				loNode.Expanded	   = .T.
		
				If m.lcExt = 'VCX'
					loNode.Expanded = .F.
					Thisform.AddClassesToTreeViewSimple(m.loNode, FilePath)
				Endif
		
				Locate For Alltrim(Upper(FilePath)) # m.lcFilePath Rest && Jump To next FileName
		
				If Not Eof()
					Skip - 1
				Endif
		
			Endscan
		
		Endwith
		
		loTreeView.Visible = .T.
		*	Thisform.LockWindow(.f.)
		
		m.loTreeView.Refresh()
		
		Select (m.lnSelect)
	ENDPROC

	PROCEDURE Refresh
		Thisform.nBrowserZoom = Thisform.containerRight.container2.containerWebControl.nZoom
		
		DoDefault()
	ENDPROC

	PROCEDURE refreshresults		&& Refresh (re-search) a result
		Lparameters;
			toNode
		
		Local;
			lcFolder         As String,;
			lcScope          As String,;
			lcSearch         As String,;
			lcSearchOptionsFile As String,;
			lcTempFile       As String,;
			lcUni            As String,;
			lcUniSearch      As String,;
			lnSelect         As Number,;
			llSearched       As Boolean,;
			loSearchEngine   As Object,;
			loSearchOptions  As Object,;
			loNode           As Object,;
			loTree           As Object
		
		If Used("gf_SearchHistory") Then
		
			lnSelect = Select()
		
			loTree         = Thisform.containerLeft.oTreeView
			loSearchEngine = Thisform.oSearchEngine
		
			lcTempFile = Addbs(Getenv("TEMP")) + "GoFish_Setting.xml"
			loSearchEngine.SaveOptions(m.lcTempFile)
		
			lcFolder            = Addbs(This.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder)
		
			If Isnull(m.toNode)
				lcUniSearch = .Null.
			Else  &&Isnull(m.toNode)
				lcUniSearch = m.toNode.Tag.gcUni
			Endif &&Isnull(m.toNode)
		
			Select("gf_SearchHistory")
			Scan For Nvl(cUni==m.lcUniSearch, .T.)
				lcUni               = Trim(cUni)
				lcSearch            = Search
				lcScope             = Scope
				lcSearchOptionsFile = m.lcFolder + m.lcUni + Trim(Substr(Thisform.cSearchOptionsXMLFile,3))
		
				If loSearchEngine.LoadOptions(m.lcSearchOptionsFile)
					This.DeleteSearchResults(m.lcUni, .F., .T., .F., .F., .F.)
					Select("gf_SearchHistory")
					This.Search(.F., Ctot(Datetime), m.lcUni)
		
					llSearched = .T.	&& only used for single item
				Endif &&loSearchEngine.LoadOptions(m.lcSearchOptionsFile)
		
			Endscan &&Nvl(cUni==m.lcUniSearch, .T.)
		
			If Isnull(m.toNode) Then
		
				This.PopulateTreeFromHistory()
				loNode = m.loTree.Nodes(1)
		
			Else  &&Isnull(m.toNode)
				If m.llSearched And !m.toNode.Tag.glNeedFill
					loNode = m.toNode.Child
					Do While Vartype(m.loNode)="O"
						loTree.Nodes.Remove(m.loNode.Key)
						loNode = m.toNode.Child
					Enddo &&Vartype(m.loNode)="O"
		
					This.PopulateNode(m.toNode.Key, m.toNode.Tag.gcUni, m.lcSearch, m.lcScope, [cUni == "] + m.lcUniSearch + ["])
				Endif &&m.llSearched And !m.toNode.Tag.glNeedFill
				loNode = m.toNode
			Endif &&Isnull(m.toNode)
		
			loTree.SelectedItem	= m.loNode
		
			loNode.Selected = .T.
			loNode.ENSUREVISIBLE()
		
			This.TreeView_NodeClick(m.loNode)
			Thisform.ShowCodeForCurrentRow()
			
			loSearchEngine.LoadOptions(m.lcTempFile)
		
			Delete File (m.lcTempFile)
			Select(m.lnSelect)
		
		Endif &&USED("gf_SearchHistory")
		
	ENDPROC

	PROCEDURE replace
		*--- Make sure at least one record is selected before calling Replace() method
		Local laSelectedCount[1]
		
		Select Count(id) from (thisform.cSearchResultsAlias);
		 Where process = .t. and replaced = .f.;
		 Into Array laSelectedCount
		 
		If laSelectedCount = 0 
			MessageBox("No eligible records are selected for replace.", 0, "Notice:")
			Return .f.
		EndIf
		
		Thisform.DoReplace(.F., laSelectedCount)
		
		If Thisform.oSearchEngine.oSearchOptions.lShowErrorMessages
			ThisForm.ShowReplaceErrors()
		EndIf 
		
	ENDPROC

	PROCEDURE replaceline
		Local lcGFSECursor, lcReplaceLine, llResult, llReturn, lnId, lnReplaceId
		
		If Evaluate(Thisform.cSearchResultsAlias + ".replaced") or !ThisForm.ConfirmReplace()
			Return .f.
		Endif
		
		lnId = Evaluate(Thisform.cSearchResultsAlias + ".id")
		lnReplaceId = this.Get_ReplaceID(.F.)
		
		*lcGFSECursor = Thisform.oSearchEngine.cSearchResultsAlias
		lcGFSECursor = Thisform.cSearchResultsAlias
		lcReplaceLine = Thisform.cReplaceLine
		
		Thisform.oSearchEngine.oSearchOptions.lPreviewReplace = .f.
		
		llResult = Thisform.oSearchEngine.ReplaceLine(lcGFSECursor, lnId, lcReplaceLine, m.lnReplaceId)
		
		If llResult
			Thisform.UpdateFormAfteReplace(lnId)
		
			Thisform.SaveReplaceResults()
		
			llReturn = .t. 
		Else	
			Thisform.containerRight.Container1.containerReplaceText.cmdReplaceErrors.Refresh() && To make sure the icon is visible before we show dialog box
			MessageBox("Error performing Replace. View Error list for more details.", 0, "Error:")
			llReturn = .f.
		Endif
		
		If Thisform.oSearchEngine.oSearchOptions.lShowErrorMessages
			ThisForm.ShowReplaceErrors()
		EndIf 
		
		Return llReturn
		
	ENDPROC

	PROCEDURE Resize
		Local lnFormWidth, loControl
		
		DoDefault()
		
		* Captures resizing properties for a few controls on the top of the form
		* so that they do not skitter all the way to the far right when form is wide
		
		lnFormWidth = Min(Thisform.Width, 1400)
		
		For Each m.loControl In This.Controls FoxObject
			Do Case
				Case Pemstatus(m.loControl, 'nWidthDifference', 5)
					loControl.Width = m.lnFormWidth - loControl.nWidthDifference
		
				Case Pemstatus(m.loControl, 'nLeftDifference', 5)
					loControl.Left = m.lnFormWidth - loControl.nLeftDifference
		
			Endcase
		Endfor
		
		loControl = Null
		
		
	ENDPROC

	PROCEDURE resizecodepage
		Local lnBrowserAnchor, lnButtonContainerAnchor, loContainer
		
		loContainer = This.Containerright.Container2.containerWebControl
		With m.loContainer
			lnButtonContainerAnchor	= .ButtonContainer.Anchor
			lnBrowserAnchor			= .oBrowser.Anchor
		
			.ButtonContainer.Anchor	= 0
			.oBrowser.Anchor		= 0
		
			If m.loContainer.Width > 800
				.ButtonContainer.Top   = 0
				If Thisform.nCodeWindowPosition = 1
					.ButtonContainer.Left = 28 + .cmdCompressCodeview.Left
				Else
					.ButtonContainer.Left = 28 + .cmdMaximizeCodeview.Left
				Endif
				.ButtonContainer.Width = .Width - .ButtonContainer.Left
				.oBrowser.Top		   = 23
			Else
				.ButtonContainer.Top   = 23
				.ButtonContainer.Left  = 0
				.ButtonContainer.Width = .Width
				.oBrowser.Top		   = 46
			Endif
			.oBrowser.Height = Max(.Height - .oBrowser.Top - 1, 60)
			.oBrowser.Width	 = Max(.Width - 6, 60)
		
			.ButtonContainer.Anchor	= m.lnButtonContainerAnchor
			.oBrowser.Anchor		= m.lnBrowserAnchor
		
			.ButtonContainer.Refresh()
		
		Endwith
		
	ENDPROC

	PROCEDURE restoredefaultdir
		Cd (This.cInitialDefaultDir)
		
	ENDPROC

	PROCEDURE restorelastsearch
		*!*	Local lcFolder, lnResults
		
		*!*	lcFolder = Thisform.GetLastSavedResultsFolder()
		
		*!*	If !Empty(lcFolder)
		*!*		Thisform.RestorePreviousSearch(lcFolder)
		*!*	Endif
		
		
	ENDPROC

	PROCEDURE restoreprevioussearch
		Lparameters tcUni
		
		Local lacUni[1], lcFilter, llLockScreen, llReturn, lnResults
		
		Thisform.oSearchEngine.oProgressBar = Thisform.ProgressBar
		Thisform.ProgressBar.Start(100, 'Loading search results...')
		Thisform.ProgressBar.nValue = 25
		Thisform.Refresh()
		
		Thisform.ClearSearchResultsCursor() && Go ahead and blank out the cursor so the grid will be empty during the search
		Thisform.ClearTreeView()
		
		If Empty(m.tcUni) Then
			lnResults = Thisform.BuildSearchHistoryCursor()	
			If m.lnResults > 0 Then
				Goto top in gf_SearchHistory
				lcFilter = gf_SearchHistory.cUni
		
			Else  &&m.lnResults > 0
				lcFilter = 'Nothing'
		
			Endif &&m.lnResults > 0
		
		Else  &&Empty(m.tcUni)
			lcFilter = m.tcUni
		
		Endif &&Empty(m.tcUni)
		
		llLockScreen = Thisform.LockScreen = .F.
		If m.llLockScreen
			Thisform.LockScreen = .T.
		Endif
		
		llReturn = This.LoadSavedResults(m.lcFilter)
		
		If Not m.llReturn
			If m.llLockScreen
				Thisform.LockScreen = .F.
			Endif
			Return
		Endif
		
		Thisform.Search(.T.)
		
		If m.llLockScreen
			Thisform.LockScreen = .F.
		Endif
		
		Thisform.ProgressBar.Stop()
		Thisform.Containerright.Container2.Visible = .T.
		
	ENDPROC

	PROCEDURE restoresavedsearch
		Local lcFolder, lcRoot
		
		*SF 20221018 -> local storage
		*lcRoot = Home(7) + Thisform.cSavedSearchResultsFolder
		lcRoot = This.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder
		*/SF 20221018 -> local storage
		
		lcFolder = GetDir(lcRoot, "Select previous search to restore:", "Select previous search to restore:", 64)
		
		If !Empty(lcFolder)
			Thisform.RestorePreviousSearch(lcFolder)
		Endif
		
	ENDPROC

	PROCEDURE restoresearchengineoptions
	ENDPROC

	PROCEDURE restoresearchfromhistory
		Local;
			lcScope As String,;
			lcUni  As String,;
			lnResults As Number
		
		lcFolder  = ""
		lnResults = Thisform.BuildSearchHistoryCursor()
		
		If m.lnResults = 0
			Messagebox("No search history results to restore. Ensure option is enabled.", 0, "GoFish")
			Return
		Else
			lcScope = ""
			If This.lCR_Allowed And This.lCR_HistoryPerScope Then
				lcScope = Lower(Thisform.GetCurrentScope())
			Endif &&This.lCR_Allowed And This.lCR_HistoryPerScope
		
			Do Form GoFish_SearchHistory With Thisform, m.lcScope To m.lcUni
		Endif
		
		If !Empty(m.lcUni)
			Thisform.RestorePreviousSearch(m.lcUni)
		Endif
		
	ENDPROC

	PROCEDURE restoretreeviewonstartup
		Local loNode, loTree
		
		loTree = Thisform.containerLeft.oTreeView
		
		If Thisform.nPreviousSessionTreeviewIndex > loTree.Nodes.Count 
			Return
		Endif
		
		loNode = loTree.Nodes.Item[Thisform.nPreviousSessionTreeviewIndex]
		
		loTree.NodeClick(loNode)
		
		*loTree.SelectedItem = loNode
		*loNode.EnsureVisible()
		
		
	ENDPROC

	PROCEDURE runjanitor
		Local ldCutOff As Date
		Local lcDeleted
		
		Wait 'GF Janitor' Window At 20, 30 Nowait
		
		lcDeleted = Set('Deleted')
		Set Deleted Off
		
		*replace history
		ldCutOff = Date() - Thisform.nJanitorReplaceHistoryDays
		
		Thisform.SaveDBC_Open()
		
		This.DeleteSearchResults(.Null., m.ldCutOff, .F., .T., .F., .F.)
		
		*search history
		ldCutOff = Date() - Thisform.nJanitorSearchHistoryDays
		
		This.DeleteSearchResults(.Null., m.ldCutOff, .F., .F., .F., .F.)
		
		Thisform.SaveDBC_Close()
		
		This.Check2GBLimit()
		
		Set Deleted &lcDeleted
		
		Return
		
	ENDPROC

	PROCEDURE savedbc_open
		Local;
			lcDbc    As String,;
			lnMode   As Number,;
			llReturn As Boolean
		
		lcDbc = This.cCR_StoreLocal + This.cSaveDBC
		
		llReturn = DoDefault()
		
		If !m.llReturn Then
			This.cSavedDBC = Set("Database")
		
			Create Database (m.lcDbc)
			Set Database To (m.lcDbc)
			DBSetProp(Justfname(m.lcDbc),'DATABASE','COMMENT',_Screen._GoFish.cVersion)
		
		*-- Create the table to save the search results main info
			Create Table (This.cCR_StoreLocal + "GF_Search_History");
				(cUni c(11), Datetime c(24), Search c(40), Results c(10), Scope c(150),;
				lSaved L, lReplace L)
		
			Use In GF_Search_History
		
		*-- Create the table to save the running ID of replace backup folder
			Create Table (This.cCR_StoreLocal + "GF_ReplaceID");
				(iID I)
		
			Append Blank
			Replace;
				iID With 1000
			Use In GF_ReplaceID
		
		*temp use of var ...
			lcDbc  = "README.md"
			lnMode = 1
			If Upper(This.cCR_StoreLocal)==Upper(Home(7) + "GoFish_\") Then
				lcDbc  = "GF_" + m.lcDbc
				lnMode = 2
			Endif &&Upper(This.cCR_StoreLocal)==Upper(Home(7) + "GoFish_\")
		
			GF_Write_Readme_Text(m.lnMode, This.cCR_StoreLocal + m.lcDbc)
		
			lcDbc = This.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder
			If !Directory(m.lcDbc) Then
				Mkdir (m.lcDbc)
				GF_Write_Readme_Text(3, Addbs(m.lcDbc) + 'README.md')
		
			Endif &&!Directory(m.lcDir)
		Endif &&!m.llReturn
		
		Return
		
	ENDPROC

	PROCEDURE saveformsettings
		Lparameters;
			tcFolder,;
			tcFile,;
			tlJustChange
		
		Local loMy As "My" Of "My.vcx"
		Local lcFile
		
		If Empty(m.tcFolder) Then
			lcFile = This.cCR_StoreLocal
		Else  &&EMPTY(m.tcFolder)
			lcFile = m.tcFolder
		Endif &&EMPTY(m.tcFolder)
		
		If Empty(m.tcFile) Then
			lcFile = m.lcFile + This.cUISettingsFile
		Else  &&Empty(m.tcFile)
			lcFile = m.lcFile + m.tcFile
		Endif &&Empty(m.tcFile)
		
		loMy = Newobject("My", "My.vcx")
		
		loSettings = loMy.Settings
		With loSettings
		
			If m.tlJustChange And File(m.lcFile) Then
		*just store this flag to the global settings
				.Load(m.lcFile)
				.Add("lCR_Allow"         ,This.lCR_Allow)
				.Add("lCR_Local"         ,This.lCR_Local)
				.Add("lCR_Local_Default" ,This.lCR_Local_Default)
		
			Else  &&m.tlJustChange AND FILE(m.lcFile)
		
		*-- Form Size and Position -----------------------------
				.Add("FormTop",    This.Top)
				.Add("FormLeft",   This.Left)
				.Add("FormHeight", This.Height)
				.Add("FormWidth",  This.Width)
				.Add("Splitter1Position", This.containerRight.splitter1.Top)
				.Add("Splitter2Position", This.splitter2.Left)
				.Add("Splitter3Position", This.containerRight.splitter3.Left)
				.Add("CodeWindowPosition", This.nCodeWindowPosition)
		
		*SF 20221017
		*new settings
				.Add("nContainerFrameColour"         ,This.nContainerFrameColour         )
				.Add("nFileSCXDynamicForeColour"     ,This.nFileSCXDynamicForeColour     )
				.Add("nFileVCXDynamicForeColour"     ,This.nFileVCXDynamicForeColour     )
				.Add("nFilePRGDynamicForeColour"     ,This.nFilePRGDynamicForeColour     )
				.Add("nFileDefaultDynamicForeColour" ,This.nFileDefaultDynamicForeColour )
				.Add("nReplacedDynamicBackColour"    ,This.nReplacedDynamicBackColour    )
				.Add("nRiskExceededDynamicBackColour",This.nRiskExceededDynamicBackColour)
				.Add("nRisk1DynamicBackColour"       ,This.nRisk1DynamicBackColour       )
				.Add("nRisk2DynamicBackColour"       ,This.nRisk2DynamicBackColour       )
				.Add("nRisk3DynamicBackColour"       ,This.nRisk3DynamicBackColour       )
				.Add("nTreeSearchColour"             ,This.nTreeSearchColour             )
				.Add("nTreeUpdateColour"             ,This.nTreeUpdateColour             )
				.Add("nCSS_tr_even_Colour"           ,This.nCSS_tr_even_Colour           )
				.Add("nCSS_tr_odd_Colour"            ,This.nCSS_tr_odd_Colour            )
				.Add("lMoveNewCodeToTopLeft"         ,This.lMoveNewCodeToTopLeft         )
		*globals
				.Add("lCR_Allow"                     ,This.lCR_Allow                     )
				.Add("lCR_Local"                     ,This.lCR_Local                     )
				.Add("lCR_Local_Default"             ,This.lCR_Local_Default             )
		*/SF 20221017
		
		*SF 20221020 5.2.000
				.Add("lOtherHistory"                 ,This.lOtherHistory           )
		
		*/SF 20221020 5.2.000
		
		*SF 20221019 5.2.000
				If This.lCR_Allow  Then
					.Add("lCR_OpenMode"             ,This.lCR_OpenMode           )
					.Add("lCR_HistoryPerScope"      ,This.lCR_HistoryPerScope    )
					.Add("lCR_SearchComboPerScope"  ,This.lCR_SearchComboPerScope)
					.Add("lCR_HistoryTree"          ,This.lCR_HistoryTree        )
					.Add("lCR_HistoryTreeAuto"      ,This.lCR_HistoryTreeAuto    )
					.Add("lCR_SimpleTree"           ,This.lCR_SimpleTree         )
					.Add("lCR_SortTreeByExt"        ,This.lCR_SortTreeByExt      )
					.Add("lCR_SortTreeAlpha"        ,This.lCR_SortTreeAlpha      )
		
				Endif &&This.lCR_Allow
		*/SF 20221019 5.2.000
		
		*SF 20230211 6.0.000
					.Add("lReplacePreview"          ,This.lReplacePreview        )
		
		*/SF 20230211 6.0.000
		
		*-- Persist the docking information.
				.Add("nDockable", This.Dockable)
				If This.Dockable # 0
					.Add("lDocked", This.Docked)
		
					If This.Docked
						Adockstate (laDock)
						lnRow = Ascan (laDock, This.Caption, -1, -1, 1, 15)
						lcDockWindow = ""
						If lnRow > 0
							.Add("nDockPosition", laDock[lnRow, 3])
							If laDock[lnRow, 4] # _Screen.Caption And Not Empty (laDock[lnRow, 4])
								lcDockWindow = laDock[lnRow, 4]
							Else
								lnRowDocked = Ascan (laDock, This.Caption, -1, -1, 4, 15)
								If lnRowDocked > 0
									lcDockWindow = laDock[lnRowDocked, 1]
								Endif
							Endif
						Endif lnRow > 0
		
						.Add("cDockWindow", lcDockWindow)
					Endif
				Endif
		
		*--- Save other custom form properties that to restore next session ----------------
		*.Add("lIncludeSubDirectoriesCurrent", Thisform.lIncludeSubDirectoriesCurrent)
		*.Add("lIncludeSubDirectoriesBrowsed", Thisform.lIncludeSubDirectoriesBrowsed)
				.Add("nBowserZoom", Thisform.containerRight.container2.containerWebControl.nZoom)
				.Add("nSearchBoxFontSize", Thisform.nSearchBoxFontSize)
				.Add("nGridFontSize", Thisform.nGridFontSize)
				.Add("nTreeViewFontSize", Thisform.nTreeViewFontSize)
				.Add("lApplyFilter", Thisform.lApplyFilter)
				.Add("lClearApplyFilter", Thisform.lClearApplyFilter)
				.Add("cFilter", Thisform.cFilter)
				.Add("nReplaceRisk", Evl(Thisform.nReplaceRisk, 1))
				.Add("cReplaceUdfFilename", Thisform.cReplaceUDFFilename)
				.Add("nReplaceMode", Evl(Thisform.nReplaceMode, 1))
		
		*.Add("cSortFields", Thisform.cSortFields)&& This one has been deprecated. See cSortField.
				.Add("cSortField", Thisform.cSortField)
				.Add("cSortOrder", Thisform.cSortOrder)
				.Add("cSortFieldSecondary", Thisform.cSortFieldSecondary)
				.Add("cSortOrderSecondary", Thisform.cSortOrderSecondary)
				.Add("cSortFieldTertiary", Thisform.cSortFieldTertiary)
				.Add("cSortOrderTertiary", Thisform.cSortOrderTertiary)
		
				.Add("nDropDownDisplayCount", Thisform.nDropDownDisplayCount)
				.Add("nDropDownMaxMRU", Thisform.nDropDownMaxMRU)
				.Add("lWarnWholeWord", Thisform.lWarnWholeWord)
				.Add("lSaveSearchResults", Thisform.lSaveSearchResults)
				.Add("lCodeOnly", Thisform.lCodeOnly)
				.Add('lCommentsOnly', Thisform.lCommentsOnly)
		
				.Add("nJanitorSearchHistoryDays", Thisform.nJanitorSearchHistoryDays)
				.Add("nJanitorReplaceHistoryDays", Thisform.nJanitorReplaceHistoryDays)
				.Add("lRunJanitorDaily", Thisform.lRunJanitorDaily)
				.Add("dLastJanitorRunDate", Thisform.dLastJanitorRunDate)
				.Add("nTabsToSpaces", Thisform.nTabsToSpaces)
				.Add("lOnlyFirstMatchInStatement", Thisform.lOnlyFirstMatchInStatement)
				.Add("nBrowserZoom", Thisform.nBrowserZoom)
		
				.Add("lShowRelativePath", 			Thisform.lShowRelativePath)
				.Add("lSortScopeDropdown", 			Thisform.lSortScopeDropdown)
				.Add("lCodeViewSingleLine", 	Thisform.lCodeViewSingleLine)
				.Add("lIDEColorsInCodeView", 		Thisform.lIDEColorsInCodeView)
				.Add("lOldSearchHistoryStructure",	Thisform.lOldSearchHistoryStructure)
		
		*-- Grid Settings -----------------------------
				For Each loControl In Thisform.oGrid.Columns
					.Add(Evl(loControl.Header1.Tag,loControl.Name) + "_width",    loControl.Width)
					.Add(Evl(loControl.Header1.Tag,loControl.Name) + "_order",    loControl.ColumnOrder)
					.Add(Evl(loControl.Header1.Tag,loControl.Name) + "_visible",  loControl.Visible)
		*.Add(loControl.Name + "_BoldHeader", loControl.Header1.FontBold)
				Endfor
		
				loTree = Thisform.containerLeft.oTreeView
				If Vartype(loTree.SelectedItem) = "O"
					lnNodeIndex = loTree.SelectedItem.Index
				Else
					lnNodeIndex = 1
				Endif
		
				.Add("nSelectedTreeviewNode", lnNodeIndex)
				.Add("lRestorePreviousSearchResultsOnStartup", Thisform.lRestorePreviousSearchResultsOnStartup)
		
				.Add("lDesktop", Thisform.lDesktop)
		
		
		
			Endif &&m.tlJustChange AND FILE(m.lcFile)
		
			.Save(m.lcFile)
		Endwith
		
	ENDPROC

	PROCEDURE savereplaceresults
		Local;
			lcDBF             As String,;
			lcDatetime        As String,;
			lcRecCount        As String,;
			lcScope           As String,;
			lcSearch          As String,;
			lcSearchResultsAlias As String,;
			lcUni             As String,;
			lnSelect          As Number
		
		lcSearchResultsAlias = This.cSearchResultsAlias
		
		lnSelect = Select()
		
		Select (m.lcSearchResultsAlias)
		
		lcUni      = cUni
		lcDatetime = Datetime
		lcSearch   = Search
		lcScope    = Scope
		Calculate Cnt() For cUni==m.lcUni To m.lcRecCount
		lcRecCount = Transform(m.lcRecCount)
		
		Select (m.lcSearchResultsAlias)
		
		This.SaveDBC_Open()
		
		lcDBF = This.cCR_StoreLocal + Forceext(Thisform.cUISettingsFile, "DBF")
		
		*"Parent" of storage, the record with the settings per search
		
		If File(m.lcDBF)
		*store existing History, just the fields
		*the flag lJustReplace is untouched, because it's saved records
		*the info that it is replaced and stored is in iReplaceFolder,
		* replaced in any of the others not empty
			lcDBF = Juststem(m.lcDBF)
		
			Update Cur1 Set;
			 Replaced           = Cur2.Replaced,;
			 TrimmedReplaceLine = Cur2.TrimmedReplaceLine,;
			 ReplaceLine        = Cur2.ReplaceLine,;
			 ReplaceRisk        = Cur2.ReplaceRisk,;
			 Replace_DT         = Cur2.Replace_DT,;
			 iReplaceFolder     = Cur2.iReplaceFolder;
			 From (m.lcDBF)                      As Cur1;
			 Inner Join (m.lcSearchResultsAlias) As Cur2;
			 On Cur1.cUni==m.lcUni;
			  And Cur2.cUni_File==Cur1.cUni_File;
			  And Cur2.ReplaceRisk<100;
			  And Cur2.lSaved;
			  And Cur2.Replaced
		
			If Thisform.oSearchEngine.oSearchOptions.lBackup
		*"Parent" of storage, the record with the settings per search
				This.Save_Search_History(;
					 m.lcUni, m.lcDatetime,;
					 m.lcSearch, m.lcScope,;
					 m.lcRecCount,;
					 .F., .T.)
		
		* if we backup replaced files, we need to store the result even if history auto storage is off
		* check if unsaved (not saved by search or replace) records are found
				Select;
				 Cur1.*;
				 From (m.lcSearchResultsAlias) As Cur1;
				 Into Cursor curCreate NoFilter Readwrite;
				 Where Cur1.cUni==m.lcUni;
				  And Cur1.ReplaceRisk<100;
				  And !Cur1.lSaved;
				  And !Cur1.lJustReplace;
				  And Cur1.Replaced;
				  And Cur1.cUni_File Not In(;
				   Select;
					Cur2.cUni_File;
					From (m.lcDBF) As Cur2;
					Where Cur2.cUni==m.lcUni)
		
				If Reccount('curCreate')>0
		*save, if
					Insert Into (m.lcDBF);
						(cUni,cUni_File,Datetime,;
						 Scope,Search,lMemLoaded,;
						 Process,FilePath,FileName,;
						 TrimmedMatchLine,BaseClass,ParentClass,;
						 Class,Name,MethodName,;
						 ContainingClass,ClassLoc,MatchType,;
						 Timestamp,FileType,Type,;
						 Recno,ProcStart,procend,;
						 statement,statementstart,firstmatchinstatement,;
						 firstmatchinprocedure,MatchStart,MatchLen,;
						 lIsText,Column,Id,;
						 MatchLine,Replaced,TrimmedReplaceLine,;
						 ReplaceLine,ReplaceRisk,Replace_DT,;
						 iReplaceFolder,;
						 lJustReplace;
						 );
						Select;
						 cUni,;
						 cUni_File,;
						 Datetime,;
						 Scope,;
						 Search,;
						 .F.,;
						 Process,;
						 FilePath,;
						 FileName,;
						 TrimmedMatchLine,;
						 BaseClass,;
						 ParentClass,;
						 Class,;
						 Name,;
						 MethodName,;
						 ContainingClass,;
						 ClassLoc,;
						 MatchType,;
						 Timestamp,;
						 FileType,;
						 Type,;
						 Recno,;
						 ProcStart,;
						 procend,;
						 statement,;
						 statementstart,;
						 firstmatchinstatement,;
						 firstmatchinprocedure,;
						 MatchStart,;
						 MatchLen,;
						 lIsText,;
						 Column,;
						 Id,;
						 MatchLine,;
						 Replaced,;
						 TrimmedReplaceLine,;
						 ReplaceLine,;
						 ReplaceRisk,;
						 Replace_DT,;
						 iReplaceFolder,;
						 .T.;
						 From curCreate
		
		*lJustReplace is set from SearchEngine
		
				Endif &&Reccount('curCreate')>0
		
			Endif &&Thisform.oSearchEngine.oSearchOptions.lBackup
		Else  &&File(m.lcDBF)
		* create the file, if
			If Thisform.oSearchEngine.oSearchOptions.lBackup
		* if we backup replaced files, we need to store the result even if history auto storage is off
		* check if unsaved (not saved by search or replace) records are found
				Select;
				 Cur1.*;
				 From (m.lcSearchResultsAlias) As Cur1;
				 Into Cursor curCreate NoFilter Readwrite;
				 Where Cur1.cUni==m.lcUni;
				  And Cur1.ReplaceRisk<100;
				  And Cur1.Replaced;
				  And !Cur1.lSaved;
				  And !Cur1.lJustReplace
		
				Copy To (m.lcDBF)  Database Juststem(Dbc())
		
				lcDBF = Juststem(m.lcDBF)
		
				Use In Select (m.lcDBF)
				Select 0
				Use (m.lcDBF) Exclusive
		        *!* ** { JRN -- 2/23/2024 3:09:01 PM - Begin
		        *!* Replace All;
		        *!*  ProcCode     With "",;
		        *!*  Code         With "",;
		        *!*  lMemLoaded   With .F.,;
		        *!*  ReplaceRisk  With 100,;
		        *!*  lJustReplace With .T.
		        Replace All;
		         ProcCode     With "",;
		         Code         With "",;
		         lMemLoaded   With .F.,;
		         lJustReplace With .T.
		        *!* ** } JRN -- 2/23/2024 3:09:01 PM - End
		
				Pack
		
			Endif &&Thisform.oSearchEngine.oSearchOptions.lBackup
		Endif &&File(m.lcDBF)
		
		If Used('curCreate') And Reccount('curCreate')>0 Then
		* we saved backup records that are not saved as a search,
		* so now we store the code memo for later use
			Select curCreate
			This.Save_ResultMemo(Trim(m.lcUni) + "_")
		
		*set info that the memo is saved for possible later save of search.
			Update Cur1 Set;
			 lMemSaved    = .T.,;
			 lJustReplace = .T.;
			 From  (m.lcSearchResultsAlias) As Cur1;
			 Inner Join curCreate           As Cur2;
			 On Cur1.cUni==m.lcUni;
			  And Cur1.ReplaceRisk<100;
			  And !Cur1.lSaved;
			  And Cur1.Replaced;
			  And Cur1.cUni_File==Cur2.cUni_File
		*write the memo save state back to the cursor
			Use In curCreate
		
		Endif &&Used('curCreate') And Reccount('curCreate')>0
		
		Use In Select(m.lcDBF)
		This.SaveDBC_Close()
		
		Select(m.lnSelect)
		
	ENDPROC

	PROCEDURE savesearchinfo
		Lparameters;
			ttSearchTime,;
			tcUni
		
		Local lcDateTime, lcFileContents, lcFilename, lcFolder, lcScope, lcSearchExpression
		Local lnHours, lnResults
		
		lnHours = Set("Hours")
		Set Hours To 24
		lcDateTime = Ttoc(Evl(m.ttSearchTime,Datetime()))
		Set Hours To &lnHours
		
		lcSearchExpression = Thisform.oSearchEngine.oSearchOptions.cSearchExpression
		lcScope            = Alltrim(Lower(Thisform.comboSearchScopeHistory.Text))
		lnResults          = Reccount(Thisform.oSearchEngine.cSearchResultsAlias)
		
		lcFileContents = ;
			m.lcDateTime + CRLF + ;
			m.lcSearchExpression + CRLF + ;
			m.lcScope + CRLF + ;
			Transform(m.lnResults)
		
		lnSelect = Select()
		*SF 20221018 -> local storage
		*lcRoot = Home(7) + lcName
		lcFolder = ADDBS(This.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder)
		
		lcFilename = m.lcFolder + m.tcUni + Trim(Substr(Thisform.cSavedSearchResultsFolder,3)) + ".txt"
		Strtofile(m.lcFileContents, m.lcFilename)
		
	ENDPROC

	PROCEDURE savesearchresults
		Lparameters;
			ttSearchTime,;
			tcUni,;
			tlSaveParent
		
		Local;
			lSave,;
			lcDBF                   As String,;
			lcDatetime              As String,;
			lcFilterSettingsFilename As String,;
			lcRecCount              As String,;
			lcScope                 As String,;
			lcSearch                As String,;
			lcSearchEngineResultsAlias As String,;
			lcSourceFile            As String,;
			lcTable                 As String,;
			lcTargetFile            As String,;
			lcUni                   As String,;
			llReplaced              As Boolean,;
			llReplaceSaved          As Boolean,;
			llReturn                As Boolean,;
			lnSelect                As Number
		
		lcSearchEngineResultsAlias = Thisform.oSearchEngine.cSearchResultsAlias
		
		lnSelect = Select()
		
		This.SaveDBC_Open()
		
		lcDBF = This.cCR_StoreLocal + Forceext(Thisform.cUISettingsFile, "DBF")
		
		If Pcount()=0 Then
		*save search via command, not auto.
		*This is we should save the cursor from display rather then that from the search engine
		*but first: the data to search is to be found in the last record of the search engine cursor
			Select (m.lcSearchEngineResultsAlias)
			Locate
			If Eof() Then
				Select(m.lnSelect)
				Return .F.
		
			Endif &&EOF()
		
			ttSearchTime = Ctot(Datetime)
			tcUni        = cUni
			tlSaveParent = .T.
		
			If Used("gf_SearchHistory") Then
				Select gf_SearchHistory
				Locate;
					For cUni==m.tcUni;
					And lSaved
		
				If Found() Then
		*already saved
					Select(m.lnSelect)
					Return .F.
		
				Endif &&FOUND()
			Endif &&Used("gf_SearchHistory")
		
			Select (m.lcSearchEngineResultsAlias)
		
			lcDatetime = Datetime
			lcSearch   = Search
			lcScope    = Scope
		
			lcSearchEngineResultsAlias =  This.cSearchResultsAlias
		
		*lets count the records - and the replaces
			Select;
			 Count(*)                          As iRec,;
			 Sum(Iif(Cur1.Replaced, 1, 0))     As iReplaced,;
			 Sum(Iif(Cur1.lJustReplace, 1, 0)) As iReplaceSaved;
			 From (m.lcSearchEngineResultsAlias) As Cur1;
			 Into Cursor curSum;
			 Where Cur1.cUni==m.tcUni
		
			lcRecCount     = Transform(iRec)
			llReplaced     = iReplaced>0		&& replaced
			llReplaceSaved = iReplaceSaved>0	&& replaced and backed up
		
			Use In curSum
			Select (m.lcSearchEngineResultsAlias)
		
			If m.llReplaceSaved
		*just alter records safed by replace, now they are safed and not only replaced
		
		*we don't need to check for the file here, it must exist if we have replace records
				lcDBF = Juststem(m.lcDBF)
				This.UseTable(m.lcDBF, m.lcDBF)
		
				Update Cur1 Set;
				 lJustReplace = .F.,;
				 lSaved       = .T.;
				 From (m.lcDBF)                            As Cur1;
				 Inner Join (m.lcSearchEngineResultsAlias) As Cur2;
				 On Cur2.cUni==m.tcUni;
				  And Cur2.cUni_File==Cur1.cUni_File
		
		*get records not touched
				Select;
				 Cur1.*;
				 From (m.lcSearchEngineResultsAlias) As Cur1;
				 Into Cursor curResultHelp NoFilter Readwrite;
				 Where Cur1.cUni==m.tcUni;
				  And Cur1.cUni_File Not In(;
				   Select;
					Cur2.cUni_File;
					From (m.lcDBF) As Cur2;
					Where Cur2.cUni==m.tcUni)
		
		*below, we just create for the unsaved set
				lcSearchEngineResultsAlias = "curResultHelp"
		
			Endif &&m.llReplaceSaved
		
		Else &&Pcount()=0
		*directly save after search
			SELECT (Thisform.oSearchEngine.cSearchResultsAlias)
			lcDatetime = Datetime
			lcSearch   = Search
			lcScope    = Scope
			lcRecCount = Transform(Reccount(Thisform.oSearchEngine.cSearchResultsAlias))
		
		* must be false, never touched
			llReplaced     = .F.
			llReplaceSaved = .F.
		Endif &&Pcount()=0
		
		This.Save_ResultMemo(Trim(m.tcUni) + "_")
		
		If m.tlSaveParent
		*"Parent" of storage, the record with the settings per search
		
		*Replaced
		
			This.Save_Search_History(;
				 m.tcUni, m.lcDatetime,;
				 m.lcSearch, m.lcScope,;
				 m.lcRecCount,;
				 .T., m.llReplaced)
		Endif &&m.tlSaveParent
		
		If !Used(m.lcDBF) AND !File(m.lcDBF) 
			Select (m.lcSearchEngineResultsAlias)
			Copy To (m.lcDBF)  Database Juststem(Dbc())
		
			lcDBF = Juststem(m.lcDBF)
		
			Use In Select (m.lcDBF)
			Select 0
			Use (m.lcDBF) Exclusive
		    *!* ** { JRN -- 2/23/2024 3:09:24 PM - Begin
		    *!* Replace All;
		    *!*  ProcCode    With "",;
		    *!*  Code        With "",;
		    *!*  lMemLoaded  With .F.,;
		    *!*  ReplaceRisk With 100,;
		    *!*  lSaved      With .T.
		    Replace All;
		     lMemLoaded  With .F.,;
		     lSaved      With .T.
		    *!* ** } JRN -- 2/23/2024 3:09:24 PM - End
		
			Pack
			Select (m.lcSearchEngineResultsAlias)
		
		Else  &&!Used(m.lcDBF) AND !File(m.lcDBF)
			If !Used(m.lcDBF)
		*probaly open because of replaced records
				lcDBF = Juststem(m.lcDBF)
		
				This.UseTable(m.lcDBF, m.lcDBF)
			Endif &&!Used(m.lcDBF)
		
		*safe records not
			Insert Into (m.lcDBF);
				(cUni,cUni_File,Datetime,;
				 Scope,Search,lMemLoaded,;
				 Process,FilePath,FileName,;
				 TrimmedMatchLine,BaseClass,ParentClass,;
				 Class,Name,MethodName,;
				 ContainingClass,ClassLoc,MatchType,;
				 Timestamp,FileType,Type,;
				 Recno,ProcStart,procend,;
				 statement,statementstart,firstmatchinstatement,;
				 firstmatchinprocedure,MatchStart,MatchLen,;
				 lIsText,Column,Id,;
				 MatchLine,Replaced,TrimmedReplaceLine,;
				 ReplaceLine,ReplaceRisk,Replace_DT,;
				 code, lSaved;
				 );
				Select;
				 cUni,;
				 cUni_File,;
				 Datetime,;
				 Scope,;
				 Search,;
				 .F.,;
				 Process,;
				 FilePath,;
				 FileName,;
				 TrimmedMatchLine,;
				 BaseClass,;
				 ParentClass,;
				 Class,;
				 Name,;
				 MethodName,;
				 ContainingClass,;
				 ClassLoc,;
				 MatchType,;
				 Timestamp,;
				 FileType,;
				 Type,;
				 Recno,;
				 ProcStart,;
				 procend,;
				 statement,;
				 statementstart,;
				 firstmatchinstatement,;
				 firstmatchinprocedure,;
				 MatchStart,;
				 MatchLen,;
				 lIsText,;
				 Column,;
				 Id,;
				 MatchLine,;
				 Replaced,;
				 TrimmedReplaceLine,;
				 ReplaceLine,;
				 ReplaceRisk,;
				 Replace_DT,;
				 Code,;
				 .T.;
				 From (m.lcSearchEngineResultsAlias);
				 Where cUni==m.tcUni
		
		*	Update Cur1 Set;
			 lSaved    = .T.,;
			 lMemSaved = .T.;
			 From (This.cSearchResultsAlias) As Cur1;
			 Where Cur1.cUni==m.tcUni
			Update Cur1 Set;
			 lSaved    = .T.,;
			 lMemSaved = .T.;
			 From (m.lcSearchEngineResultsAlias) As Cur1;
			 Where Cur1.cUni==m.tcUni
		
		Endif &&!Used(m.lcDBF) AND !File(m.lcDBF)
		
		If Pcount()=0 And m.llReplaceSaved
		*copy memo save status to summary cursor
			lcSearchEngineResultsAlias =  This.cSearchResultsAlias
		
			Update Cur1 Set;
			 lMemSaved = .T.;
			 From (m.lcSearchEngineResultsAlias) As Cur1;
			 Inner Join curResultHelp            As Cur2;
			 On Cur1.cUni==m.tcUni;
			  And Cur1.cUni_File==Cur2.cUni_File;
			  And Cur2.lMemSaved
		
		*close the help cursor
			Use In Select("curResultHelp")
		Endif &&Pcount()=0 AND m.llReplaceSaved
		
		Use In (m.lcDBF)
		This.SaveDBC_Close()
		
		Select(m.lnSelect)
		*-- Copy the Filter form settings XML file to our new folder
		* SF 20221104 this never worked
		Try
				lcFilterSettingsFilename = "GF_Filter_Settings.xml"
		*SF 20221018 -> local storage
		*	lcSourceFile = Home(7) + lcFilterSettingsFilename
				lcSourceFile = This.cCR_StoreLocal + m.lcFilterSettingsFilename
		*/SF 20221018 -> local storage
				lcTargetFile = Addbs(lcNewDir) + m.lcFilterSettingsFilename
				Copy File (m.lcSourceFile) To (m.lcTargetFile)
			Catch
		Endtry
		
		*-- Save a textfile with information about the saved search
		Thisform.SaveSearchInfo(m.ttSearchTime, m.tcUni)
		
		Select(m.lnSelect)
		
	ENDPROC

	PROCEDURE save_resultmemo		&& Save the code snippets from memo to file, to stop the memo file to overgrow
		Lparameters			;
			tcUni
		
		*lcTable = JustStem(This.cSaveResultsDbc)
		Local lcName, lcRoot
		
		lcName = Thisform.cSavedSearchResultsFolder
		
		*SF 20221018 -> local storage
		*lcRoot = Home(7) + lcName
		lcRoot = Addbs(This.cCR_StoreLocal + m.lcName)
		*/SF 20221018 -> local storage
		
		*-- Create root folder of saved searches
		If Not Directory(m.lcRoot) Then
			Try
				Mkdir (m.lcRoot)
			Catch
			Endtry
			GF_Write_Readme_Text(3, m.lcRoot + 'README.md')
		Endif &&!DIRECTORY(m.lcRoot)
		
		lcRoot = Addbs(m.lcRoot)
		
		Thisform.SaveFormSettings(m.lcRoot, m.tcUni + Substr(This.cUISettingsFile, 4))
		Thisform.oSearchEngine.SaveOptions(m.lcRoot + m.tcUni + Trim(Substr(This.cSearchOptionsXMLFile, 4)))
		
		*** JRN 2024-02-24 :  only write CODE field to separate files if they are large enough
		* the idea being to minimize the activity without endangering the 2GB limit for FPT
		Scan For Not lMemSaved
			*!* ******** JRN Removed 2024-02-24 ********
			*!* Not needed, as ProcCode can be derived from Code instead
			*!* If Len(ProcCode) >= MEMOFIELDMINSIZE
			*!* 	Strtofile(ProcCode, m.lcRoot + Trim(cUni_File) + 'ProcCode.txt')
			*!* 	Replace Proccode with ''
			*!* Endif
		
			If Len(Code) >= MEMOFIELDMINSIZE
				Strtofile(Code, m.lcRoot + Trim(cUni_File) + 'Code.txt')
				Replace Code with ''
			Endif
		
			Replace			;
					lMemSaved  With	 .T.
		Endscan &&All
		Go Top
		
	ENDPROC

	PROCEDURE save_search_history		&& Save the GF_Search_History table
		Lparameters;
			tcUni,;
			tcDatetime,;
			tcSearch,;
			tcScope,;
			tcRecCount,;
			tlSaved,;
			tlReplace
		
		Local;
			lcDBF As String,;
			lnSelect As Number
		
		lnSelect = Select()
		
		lcDBF = "GF_Search_History"
		*"Parent" of storage, the record with the settings per search
		This.UseTable("GF_Search_History", m.lcDBF)
		
		*figure out if the record is already stored
		Select (m.lcDBF)
		Locate ;
			For cuni==m.tcUni
		
		If Found()
		*just set the respective flag
		    Replace;
		     lSaved   With lSaved Or m.tlSaved,;
		     lReplace With lReplace Or m.tlReplace
		
		Else  &&Found()
		*storage
			Insert Into (m.lcDBF);
				(cuni,Datetime,;
				 Search, Scope,;
				 Results,;
				 lSaved,lReplace);
				Values;
				(m.tcUni, m.tcDatetime,;
				 m.tcSearch, m.tcScope,;
				 m.tcRecCount,;
				 m.tlSaved, m.tlReplace)
		*local cursor
			If !Used("gf_SearchHistory") Then
				Select Space(11) As cuni, ;
				 Space(24)       As Datetime, ;
				 Space(40)       As Search, ;
				 Space(10)       As Results, ;
				 Space(150)      As Scope, ;
				 Space(255)      As SearchHistoryFolder, ;
				 .F.             As lSaved, ;
				 .F.             As lReplace, ;
				 .F.             As lRestored ;
				 From (Thisform.oSearchEngine.cSearchResultsAlias) ;
				 Where 0 = 1 ;
				 Into Cursor gf_SearchHistory Readwrite
		
			Endif &&!Used("gf_SearchHistory")
		
			Insert Into gf_SearchHistory;
				(cuni,Datetime,;
				 Search, Scope,;
				 Results,;
				 lSaved, lReplace);
				Values;
				(m.tcUni, m.tcDatetime,;
				 m.tcSearch, m.tcScope,;
				 m.tcRecCount,;
				 m.tlSaved, m.tlReplace)
		
		Endif &&Found()
		
		Use In (m.lcDBF)
		
		Select (m.lnSelect)
		
	ENDPROC

	PROCEDURE search
		Lparameters tlDoNotSearch, ttTime, tcUni
		
		Local lcFilter, lcFirstChar, lcLastChar, lcSearchExpression, lnResponse
		
		lcSearchExpression = Thisform.oSearchEngine.oSearchOptions.cSearchExpression
		lcFirstChar = Left(lcSearchExpression, 1)
		lcLastChar = Right(lcSearchExpression, 1)
		
		*====== Deal with any leading or trailing spaces in the search expression ======================
		If Empty(tlDoNotSearch) and (lcFirstChar = Chr(32) Or lcLastChar = Chr(32))
			lnResponse = Messagebox("Notice: The search expression contains leading or trailing spaces." + ;
				  Chr(13) + Chr(13) + ;
				  "Do you want to remove these spaces from the search expression?", 3 + 32, "GoFish notice:") && Yes, No, Cancel dialog box
			If lnResponse = 2 && Cancel
				Thisform.editSearch.SetFocus()
				Return
			Endif
		
			If lnResponse = 6 && Yes
				Thisform.oSearchEngine.oSearchOptions.cSearchExpression = Alltrim(lcSearchExpression)
			Endif
		Endif
		
		lcFilter = Thisform.cFilter
		
		Set Filter To &lcFilter In (Thisform.cSearchResultsAlias) && Need to remove any filter that the Treeview has applied
		
		lcBell = Set("Bell")
		Set Bell Off
		
		Thisform.DoSearch(tlDoNotSearch, m.ttTime, m.tcUni)
		
		Set Bell &lcBell
		
		If Thisform.lSearching
			Thisform.lSearching = .F.
		Endif
		
		Thisform.editSearch.SetFocus()
		
		If Thisform.oSearchEngine.oSearchOptions.lShowErrorMessages
			ThisForm.ShowSearchErrors()
		EndIf 
		
	ENDPROC

	PROCEDURE setcaption
		Lparameters toControl, tcCaption
		
		toControl.Caption = tcCaption
		
		toControl.Refresh()
	ENDPROC

	PROCEDURE seterror
	ENDPROC

	PROCEDURE setpath
		Lparameters tcDir
		
		MessageBox("Form.SetPath() shoudl no longer be needed.")
		Return
		
		
		
		Local lcPath, llReturn
		
		lcPath = Alltrim(Thisform.oSearchEngine.oSearchOptions.cPath)	&& Store it. Might be invalid, and if so, we'll restore it to save them
		
		llReturn = Thisform.oSearchEngine.SetPath(tcDir) && Will also rebuild list of Projects that are present in this path
		
		If !llReturn
			MessageBox("Invalid path. Please correct",32, "GoFish Error:")
			Thisform.oSearchEngine.oSearchOptions.cPath	= lcPath
		Endif
		
		Thisform.Refresh()
		
		Return llReturn
		
		     
	ENDPROC

	PROCEDURE setproject
	ENDPROC

	PROCEDURE setscope
		Lparameters tcScope
		
		tcScope = Alltrim(tcScope)
		tcScope = Rtrim(Lower(tcScope), "\")
		
		If (!Directory(tcScope, 1) and !(".pjx" $ Lower(tcScope))) or Empty(tcScope)
			MessageBox("Invalid scope setting", 0, "Error:")
			Return
		Endif
		
		Thisform.comboSearchScopeHistory.SaveSearchScope(tcScope)
		Thisform.comboSearchScopeHistory.Value = tcScope
		Thisform.comboSearchScopeHistory.Valid()
		
		Thisform.Refresh()
	ENDPROC

	PROCEDURE setsearchexpression
		Lparameters tcSearchExpression
		
		Thisform.oSearchEngine.oSearchOptions.cSearchExpression = tcSearchExpression
		
		Thisform.Refresh()
	ENDPROC

	PROCEDURE set_gridcolour		&& Set the colours for the grid, moved to load options
		Local lcDynamicBackColor As String
		Local loColumn As Object
		Local lcDefaultColor, lcDynamicForeColor, lcFileName, lcFormatGridPrg, lcPRG, lcPRGColor
		Local lcResultsCursor, lcSCX, lcSCXColor, lcVCX, lcVCXColor
		
		lcResultsCursor = Thisform.cSearchResultsAlias
		
		lcFormatGridPrg = 'GoFish_FormatGrid.PRG'
		
		* First choice: Thor
		If Type('_Screen.cThorDispatcher') = 'C'
			lcFileName = Execscript(_Screen.cThorDispatcher, 'Full Path=Thor_Proc_GoFish_FormatGrid.PRG')
			If (Not Isnull(m.lcFileName)) And File(m.lcFileName)
				lcFormatGridPrg = m.lcFileName
			Endif
		Endif
		
		If Not File(m.lcFormatGridPrg) && If not found in the VFP path
			lcFormatGridPrg = Addbs(_Screen._GoFish.cAppPath) + m.lcFormatGridPrg && Look for it in the GoFish folder.
		Endif
		
		If File (m.lcFormatGridPrg) && Call user file to assign colors, if present, otherwise use default
			Do (m.lcFormatGridPrg) With Thisform.oGrid, m.lcResultsCursor
		Else
		
			*SF 20221016 added colour options
			lcSCX = [<<m.lcResultsCursor>>.filetype = "SCX"]
			*	lcSCXColor = "RGB(0,0,128)"
			lcSCXColor = Padr(Thisform.nFileScxDynamicForeColour, 8)
		
			lcVCX = [<<m.lcResultsCursor>>.filetype = "VCX"]
			*	lcVCXColor = "RGB(0,128,0)"
			lcVCXColor = Padr(Thisform.nFileVcxDynamicForeColour, 8)
		
			lcPRG = [<<m.lcResultsCursor>>.filetype $ " PRG TXT H INI XML HTM HTML ASP ASPX"]
			*	lcPRGColor = "RGB(255,0,0)"
			lcPRGColor = Padr(Thisform.nFilePrgDynamicForeColour, 8)
		
			lcDefaultColor = Padr(Thisform.nFileDefaultDynamicForeColour, 8)
		
			lcDynamicForeColor = 'ICase(' +					;
				m.lcSCX + ', ' + m.lcSCXColor + ', ' +		;
				m.lcVCX + ', ' + m.lcVCXColor + ', ' +		;
				m.lcPRG + ',' + m.lcPRGColor + ',  ' +		;
				m.lcDefaultColor +							;
				' )'
		
			Thisform.oGrid.SetAll('DynamicForeColor', Textmerge(m.lcDynamicForeColor), 'COLUMN')
		
			*/ SF 20221016 added colour options
		
			*SF 20221029 fix column restore
			loColumn = Thisform.oGrid.FindColumn('TrimmedReplaceLine')
			*lcDynamicBackColor = "ICase(replaced, RGB(149,249,147), replacerisk > Thisform.nReplaceRisk, Rgb(210,210,210), Rgb(255,255,255))"
			If Vartype(m.loColumn) = 'O' Then
				lcDynamicBackColor = 'ICase(' +															;
					'replaced, ' + Padr(Thisform.nReplacedDynamicBackColour, 8) + ', ' +				;
					'replacerisk > Thisform.nReplaceRisk, ' + Padr(Thisform.nRiskExceededDynamicBackColour, 8) + ', ' + ;
					'Rgb(255,255,255))'
				loColumn.DynamicBackColor = m.lcDynamicBackColor
		
			Endif &&Vartype(m.loColumn) = "O"
			*SF 20221029 fix column restore
		Endif
		
	ENDPROC

	PROCEDURE set_searchresultsalias_filter		&& Setzte den Filter für THIScSearchResultsAlias
		Lparameters;
			tcFilter
		
		Local;
			lcNewFilter As String,;
			lcNormalFilter As String
		
		*--- Merge Main form filter and TreeView filter
		lcNormalFilter = This.GetFilter()
		Do Case
			Case Empty(m.tcFilter)
				lcNewFilter = m.lcNormalFilter
			Case Empty(m.lcNormalFilter)
				lcNewFilter = m.tcFilter
			Otherwise
				lcNewFilter = m.lcNormalFilter + " and " + m.tcFilter
		Endcase
		
		Set Filter To &lcNewFilter In (Thisform.cSearchResultsAlias)
		
	ENDPROC

	PROCEDURE showadvancedform
		
		If !Thisform.lSearchFormVisible
			Thisform.lSearchFormVisible = .t.
			Do Form "GoFish_Advanced" with Thisform
		Else
			ThisForm.ShowForm("GF_Advanced")
		Endif
		
	ENDPROC

	PROCEDURE showcodeforcurrentrow
		Lparameters tlForce
		
		*-- This method will only generate the html if the ROW has changed, not the colum. This prevents
		*-- the html from being regenerated if the user tabs to a new column in the grid, without changing rows.
		Local lcFile As String
		Local lcID As String
		Local lcUni As String
		Local lcUni_File As String
		Local lcAlias, lnSelect
		
		If Eof(Thisform.cSearchResultsAlias) Or Thisform.lSearching
			Thisform.Containerright.Container2.ContainerWebControl.ShowHTML('')
		
			Return
		Endif
		
		lcUni	   = Trim(Evaluate(Thisform.cSearchResultsAlias + '.cUni'))
		lcID	   = Padl(Evaluate(Thisform.cSearchResultsAlias + '.id'), 11, '0') + m.lcUni
		lcUni_File = Trim(Evaluate(Thisform.cSearchResultsAlias + '.cUni_File'))
		
		*If (m.lcId <> Thisform.nCurrentId And m.lnId > 0) Or m.tlForce
		If m.lcID # Thisform.cCurrentId Or m.tlForce
		
			lnSelect = Select()
			lcAlias	 = Thisform.cSearchResultsAlias
			Select (m.lcAlias)
		
			lcFile	= Addbs(Thisform.cCR_StoreLocal + Thisform.cSavedSearchResultsFolder) + m.lcUni_File
		
			If Empty(Code) And File(m.lcFile + 'Code.txt')
				Replace	Code With Filetostr(m.lcFile + 'Code.txt')
			Endif
		
			*!* ******** JRN Removed 2024-02-24 ********
			*!* Not needed, as ProcCode can be derived from Code
			*!* If Empty(&lcAlias..ProcCode) And File(m.lcFile + 'ProcCode.txt')
			*!* 	Replace	ProcCode With Filetostr(m.lcFile + 'ProcCode.txt') In (m.lcAlias)
			*!* Endif
		
			Do Case
				Case Empty(Field('ProcCode'))
		
				Case Not Empty(ProcCode)
		
				Case ProcStart > 0
					Replace ProcCode With Substr(Code, ProcStart, 1 + ProcEnd - ProcStart)
		
				Otherwise
					Replace ProcCode With Code
		
			Endcase
		
			Select(m.lnSelect)
			Thisform.LoadReplaceLine()
			Thisform.Refresh()
			Thisform.ShowHtmlCodeView()
		Endif
		
		Thisform.cCurrentId = m.lcID
		
	ENDPROC

	PROCEDURE showerrors
		Lparameters loCollection
		
		Local lcErrorText, lcTempFile, loEditorWin, loObject
		*!* ******************** Removed 11/09/2015 *****************
		*!* Do Form "GF_Collection_Explorer"
		
		lcErrorText = ""
		For Each m.loObject In m.loCollection FoxObject
			lcErrorText = m.lcErrorText + m.loObject + CR
		EndFor 
		
		If Empty(lcErrorText)
			Return
		EndIf 
		
		lcTempFile	  = Addbs(Sys(2023)) + "GF_Search_Errors" + Sys(2015) + ".txt"
		Strtofile(m.lcErrorText, m.lcTempFile)
		Modify File (m.lcTempFile) Nowait
		
		If GF_IsThorThere()
			loEditorWin = Execscript(_Screen.cThorDispatcher, "Class= editorwin from pemeditor")
			m.loEditorWin.ResizeWindow(1200, 600)
			m.loEditorWin.SetTitle(m.lcTempFile)
		Endif
		
	ENDPROC

	PROCEDURE showfilterform
		Lparameters lcFormName
		
		Local lcCurrentFilter, lcCursor, lcFilter
		
		lcCursor = Thisform.cSearchResultsAlias
		lcCurrentFilter = Filter(lcCursor)
		Thisform.cCurrentId = ""
		
		Set Filter To In (lcCursor) && Clear current filter so Filter form and process all records
		Goto Top In (lcCursor)
		
		Do Form (lcFormName) With Thisform To lcFilter
		
		If Isnull(lcFilter)
			Set Filter To &lcCurrentFilter In (lcCursor)
			Goto Top In (lcCursor)
			Return
		Else
			This.LoadFilterSettings()
			Thisform.cFilter = lcFilter
			Thisform.lApplyFilter = .T.
			Thisform.ApplyFilter()
		Endif
		
		If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
		
			Thisform.PopulateTreeFromHistory()
		
		Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
			Thisform.UpdateTreeView()
		
		Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
		
	ENDPROC

	PROCEDURE showform
		Lparameters tcFormName
		
		Local llReturn, lnI
		
		If Empty(tcFormName)
			Return
		Endif
		llReturn = .f.
		
		For lnI = 1 To _Screen.FormCount
		    If Upper(_Screen.Forms(lnI).Name) = Upper(tcFormName)
		
		        With _Screen.Forms (lnI)
		            If .WindowState = 1
		                .WindowState = 0
		            Endif
		            .Show()
		        EndWith
		        llReturn = .t.
		        Exit
		    Endif
		EndFor
		
		Return llReturn 
	ENDPROC

	PROCEDURE showgofishhelppage
		messagebox("No help available at this time.", 0, "GoFish")
		*** TODO: GF_Shell("URL for replace help")
		
	ENDPROC

	PROCEDURE showgridcolumn
		Lparameters tlShow, toColumn, tnPosition, tnWidth
		
		Local lnColumnCount
		
		lnColumnCount = toColumn.Parent.ColumnCount
		toColumn.Width = tnWidth
		
		If tlShow
			toColumn.Visible = .t.
			Do While toColumn.ColumnOrder <> tnPosition 
				toColumn.ColumnOrder = toColumn.ColumnOrder + Iif(toColumn.ColumnOrder < tnPosition, 1, -1)
			EndDo
		Else
			Do While toColumn.ColumnOrder < lnColumnCount
				toColumn.ColumnOrder = toColumn.ColumnOrder + 1
			EndDo
			toColumn.Visible = .f.
		Endif  
	ENDPROC

	PROCEDURE showhelpform
		Do Form "GoFish_About" With Thisform
	ENDPROC

	PROCEDURE showhtml
		Lparameters tcHtml
		
		Local loWebContainer
		
		loWebContainer = Thisform.containerRight.container2.ContainerWebControl
		
		loWebContainer.ShowHtml(tcHtml) 
	ENDPROC

	PROCEDURE showhtmlcodeview
		Local lcCode, lcCss, lcCssFile, lcCursor, lcExt, lcHTML, lcHtmlFile, lcJavaScript, lcJavaScriptFile
		Local lcMatchLine, lcReplaceLine, lcSearch, lcStatement, lnMatchStart, lnStatementStart
		Local loSearchEngine, loWebControl
		
		lcCursor	   = Thisform.cSearchResultsAlias
		loSearchEngine = Thisform.oSearchEngine
		loWebControl   = Thisform.Containerright.Container2.ContainerWebControl
		
		*-- These file types cannot be rendered ------------------
		lcExt = Alltrim(Upper(&lcCursor..FileType))
		If (' ' + m.lcExt + ' ') $ This.cDoNotRenderExtensions
			m.loWebControl.ShowHTML('Cannot render this file type.')
			Return
		Endif
		
		lcCode = Substr(&lcCursor..Code, &lcCursor..ProcStart + 1)
		
		lnMatchStart  = &lcCursor..MatchStart - &lcCursor..ProcStart
		lcMatchLine	  = &lcCursor..MatchLine
		lcReplaceLine = &lcCursor..ReplaceLine
		lcSearch	  = &lcCursor..Search
		
		*** JRN 2024-02-05 : Colors for 'Code View':  Match user's colors for normal code windows (Experimental)
		lcCss = This.GetCustomCss()
		If Empty(m.lcCss) Or Thisform.lIDEColorsInCodeView = .F.
			lcCssFile	 = Home(7) + 'GoFish_\GoFish.css'
			If Not File(m.lcCssFile)
				* The default file (path does not matter when part of the APP)
				lcCssFile	 = _Screen._GoFish.cAppPath + 'CSS\GoFish.css'
			Endif
			lcCss		 = Iif(File(m.lcCssFile), Filetostr(m.lcCssFile), '')
		Endif
		
		lcJavaScriptFile = _Screen._GoFish.cAppPath + 'HTML\GoFish.js'
		lcJavaScript	 = Iif(File(m.lcJavaScriptFile), Filetostr(m.lcJavaScriptFile), '')
		
		Do Case
				*** JRN 2024-02-17 : If too large, no special coloring for HTML at all
			Case Len(m.lcCode) > Thisform.nMaxSizeToRenderHtml
				lcHTML = '<pre>' + m.lcCode + '</pre>'
		
				*** JRN 2024-02-17 : In replace mode, show old style (match line)
			Case Thisform.lReplaceViewMode Or Thisform.lcodeviewsingleline
				lcHTML = m.loSearchEngine.GenerateHTMLCode(m.lcCode, m.lcMatchLine, m.lnMatchStart, m.lcCss, m.lcJavaScript, m.lcReplaceLine, &lcCursor..Replaced, Thisform.nTabsToSpaces, ;
					  Thisform.oSearchEngine.oSearchOptions.cSearchExpression,							;
					  Alltrim(Iif(This.lApplyFilter, This.oFilter.Statement_Filter, '')),				;
					  Alltrim(Iif(This.lApplyFilter, This.oFilter.ProcCode_Filter, '')))
		
				*** JRN 2024-02-17 : All other modes, highlight all matches in current statement
			Otherwise
				lnStatementStart = &lcCursor..StatementStart - 1
				lcStatement		 = &lcCursor..Statement
		
				If Occurs(Chr[13], m.lcStatement) < Occurs(Chr[10], m.lcStatement)
					lcStatement = Strtran(m.lcStatement, LF, CRLF, 1, 1)
				EndIf
				
				*** JRN 2024-03-02 : Apparently lcStatement needs a trailing CR
				lcStatement = m.lcStatement + CR
				
				lcHTML = m.loSearchEngine.GenerateHTMLCode(m.lcCode, m.lcStatement, m.lnStatementStart, m.lcCss, m.lcJavaScript, '', .F., Thisform.nTabsToSpaces, ;
					  Thisform.oSearchEngine.oSearchOptions.cSearchExpression,							;
					  Alltrim(Iif(This.lApplyFilter, This.oFilter.Statement_Filter, '')),				;
					  Alltrim(Iif(This.lApplyFilter, This.oFilter.ProcCode_Filter, '')))
		Endcase
		
		If This.lGoogleChromeFrame = .T.  && Slower due to file activity, but allows selecting of text from matched row in html view.
			*SF 20221018 -> local storage
			*	lcHtmlFile = Home(7) + 'gf_html_code.html'
			lcHtmlFile = This.cCR_StoreLocal + 'gf_html_code.html'
			*/SF 20221018 -> local storage
			Delete File (m.lcHtmlFile)
			Strtofile(m.lcHTML, m.lcHtmlFile)
			loWebControl.lGoogleChromeFrame = .T.
			m.loWebControl.ShowHtmlFile(m.lcHtmlFile)
		Else
			m.loWebControl.ShowHTML(m.lcHTML)
		Endif
		
		
		
		
	ENDPROC

	PROCEDURE showoptionsform
		*SF 20221017, get form settings, nothing from some odd stored search.
		Local;
			llCR_SortTreeAlpha As String,;
			lnRecno            As Number
		
		This.LockScreen    = .T.
		llCR_SortTreeAlpha = Thisform.lCR_SortTreeAlpha
		Thisform.LoadFormSettings(.T.)
		Thisform.lCR_SortTreeAlpha = m.llCR_SortTreeAlpha
		This.LockScreen            = .F.
		*/SF 20221017, get form settings, nothing from some odd stored search.
		
		This.lCR_RefreshTree = .F.
		
		This.AddProperty("lDeleteStorage", .F.)
		
		Do Form GoFish_Options With Thisform && Calls a Modal form...
		
		*This.LockScreen = .T.
		
		lnRecno = Recno(This.cSearchResultsAlias)
		
		IF This.lDeleteStorage THEN
			This.DeleteSearchResults(.F., .F., .F., .F., .F., .T.) 
		ENDIF &&This.lDeleteStorage 
		
		If This.nFirstLoad=2 Then
		*we have lCR_Allow active (i.e. we started this way.)
		*just store changes to lCR_Allow
			Thisform.SaveFormSettings(Home(7) + "GoFish_\", , .T.)
		
		Endif &&This.nFirstLoad=2
		
		Thisform.SaveFormSettings()
		Thisform.LoadFormSettings(.T., This.lDeleteStorage)
		
		this.FormatProcessColumn
		
		*!*	If !Thisform.oSearchEngine.oSearchOptions.lEnableReplaceMode And Thisform.lReplaceViewMode
		*!*		Thisform.lReplaceViewMode = .F. && Will trigger the _assign method
		*!*	Else
			Thisform.lReplaceViewMode = Thisform.lReplaceViewMode
		*!*	Endif
		
		*-- Unmark any marked records where the replacerisk is higher than the new setting
		Update (Thisform.cSearchResultsAlias) Set Process = .F.;
			Where replacerisk > Thisform.nReplaceRisk
		
		Select (This.cSearchResultsAlias)
		
		Try
				Goto (m.lnRecno)
			Catch
		Endtry
		
		Thisform.Refresh()
		
		This.LockScreen = .F.
		
	ENDPROC

	PROCEDURE showreplaceerrors
		Local loReplaceErrors
		loReplaceErrors = Thisform.oSearchEngine.oReplaceErrors
		If m.loReplaceErrors.Count > 0
			Thisform.ShowErrors(m.loReplaceErrors)
		Endif
		
	ENDPROC

	PROCEDURE showreplacepanel
		loReplacePanel = Thisform.containerRight.container1.containerReplaceText
		
		If loReplacePanel.visible
			Return
		Endif
		
		lnHeightChange = This.parent.containerReplaceText.Height * -1
		
		
	ENDPROC

	PROCEDURE showsearcherrors
		Local loSearchErrors
		loSearchErrors = Thisform.oSearchEngine.oSearchErrors
		If m.loSearchErrors.Count > 0
			Thisform.ShowErrors(m.loSearchErrors)
		Endif
		
	ENDPROC

	PROCEDURE sortcolumn
		Local laCurrentEvent[1], lcField, lcNewSortOrder, lcSortField, lcSortOrder, loCalledBy, loColumn
		Local loHeader
		
		AEvents(laCurrentEvent,0)
		loCalledBy = laCurrentEvent[1] && should be a Header object
		loHeader = Evl(loHeader, loCalledBy)
		
		lcField = Upper(GetWordNum(loHeader.Parent.ControlSource, 2, '.'))
		lcNewSortOrder= ""
		
		IF INLIST(UPPER(lcField), "CODE", "PROCCODE", "MATCHLINE", "STATEMENT")
			MessageBox("Cannot sort by this column.", 16, "Notice:")
			Return .f.
		Endif
		
		*-- Read current Sort field and Sort Order ------------------
		lcSortField = Thisform.cSortField
		lcSortOrder = Upper(Thisform.cSortOrder)
		
		If "TIMESTAMP" $ Upper(loHeader.Parent.ControlSource)
			lcNewSortOrder= "DESC"
		EndIf
		
		*-- If same column, reverse Asc/Desc, bump 2 to 3, and 1 to 2, so new column can go in 1
		If lcField = lcSortField or Empty(lcSortField) 
			lcNewSortOrder = Iif(("DESC" $ lcSortOrder) or Empty(lcSortOrder), "ASC", "DESC")
		Else
			Thisform.cSortFieldTertiary = Thisform.cSortFieldSecondary
			Thisform.cSortOrderTertiary = Thisform.cSortOrderSecondary
			Thisform.cSortFieldSecondary = Thisform.cSortField
			Thisform.cSortOrderSecondary = Thisform.cSortOrder
		EndIf
		
		Thisform.cSortField = lcField
		Thisform.cSortOrder = lcNewSortOrder
		
		Thisform.FillSearchResultsCursor()
		
		If thisform.lReplaceViewMode
			Thisform.DoReplace(.t.) && .t. means do a "Preview" Replace
		Endif
		
		Thisform.oGrid.Setfocus()
		
		Keyboard "{UPARROW}" && Required to get the grid to update and sync with newly built cursor.  
	ENDPROC

	PROCEDURE sortcolumnsecondary
		Local laCurrentEvent[1], lcField, lcNewSortOrder, lcSortField, lcSortOrder, loCalledBy, loHeader
		
		AEvents(laCurrentEvent,0)
		loCalledBy = laCurrentEvent[1] && should be a Header object
		loHeader = Evl(loHeader, loCalledBy)
		
		lcField = Upper(GetWordNum(loHeader.Parent.ControlSource, 2, '.'))
		lcNewSortOrder = ""
		
		IF INLIST(UPPER(lcField), "CODE", "PROCCODE", "MATCHLINE", "STATEMENT")
			MessageBox("Cannot sort by this column.", 16, "Notice:")
			Return .f.
		Endif
		
		*-- Read current Secondary Sort Field and Sort Order ------------------
		lcSortField = Thisform.cSortFieldSecondary
		lcSortOrder = Upper(Thisform.cSortOrderSecondary)
		
		If "TIMESTAMP" $ Upper(loHeader.Parent.ControlSource)
			lcNewSortOrder = "DESC"
		Endif
		
		*-- If same column, need to reverse Asc/Desc, otherwise, bump 2nd to 3rd
		If lcField = lcSortField 
			lcNewSortOrder = Iif(("DESC" $ lcSortOrder) or Empty(lcSortOrder), "ASC", "DESC")
		Else
			Thisform.cSortFieldTertiary = Thisform.cSortFieldSecondary
			Thisform.cSortOrderTertiary = Thisform.cSortOrderSecondary
		Endif
		
		Thisform.cSortFieldSecondary = lcField
		Thisform.cSortOrderSecondary = lcNewSortOrder
		
		Thisform.FillSearchResultsCursor()
		
		If thisform.lReplaceViewMode
			Thisform.DoReplace(.t.) && .t. means do a "Preview" Replace
		Endif
		
		Thisform.oGrid.Setfocus()
		
		Keyboard "{UPARROW}" && Required to get the grid to update and sync with newly built cursor. 
	ENDPROC

	PROCEDURE treeview_nodeclick		&& A Node on Treeview is clicked.
		Lparameters;
			toNode
		
		Local;
			lcFileType As String,;
			lcFilter As String,;
			lcNewFilter As String,;
			lnID     As Number,;
			lnSelect As Number,;
			loTree   As Object
		
		If Vartype(m.toNode.Tag)="O" And m.toNode.Tag.glNeedFill Then
		*not expanded, no data. We use the Expand method to gather data, but they will not expand
		
			Thisform.TreeView_NodeExpand(m.toNode)
		
		Else  &&Vartype(m.toNode.Tag)="O" And m.toNode.Tag.glNeedFill
			loTree = This.oTree
		
			lnSelect = Select()
			lcFilter = ""
		
			If Vartype(m.toNode.Tag)="O" Then
				lcFilter = m.toNode.Tag.gcFilter
			Endif &&Vartype(m.toNode.Tag)="O"
		
			Thisform.cTreeViewFilter = m.lcFilter
		
			This.Set_SearchResultsAlias_Filter(m.lcFilter)
		
			Goto Top In (Thisform.cSearchResultsAlias)
		
			loTree.SelectedItem	= m.toNode
		
			toNode.Selected = .T.
			toNode.ENSUREVISIBLE()
		
			Thisform.oGrid.SetFocus
			If Eof(Thisform.cSearchResultsAlias) Then
				Thisform.Containerright.Container2.containerWebControl.ShowHTML("Not in filter.")
				Thisform.cCurrentId =  ""
				thisform.Refresh
			Endif &&EOF(Thisform.cSearchResultsAlias)
			loTree.SetFocus()
		*Thisform.Refresh()
		
			Select(m.lnSelect)
		
		Endif &&Vartype(m.toNode.Tag)="O" And m.toNode.Tag.glNeedFill
		
	ENDPROC

	PROCEDURE treeview_nodedblclick		&& A Node of the Treeview is DblClicked.
		Lparameters;
			toNode
		
		Local loPBT As "GF_PEME_BaseTools"
		Local lcClass, lcFile, loNode
		
		lcFile = ""
		lcClass = ""
		
		loNode = m.toNode
		
		Do Case
			Case Vartype(m.loNode.Tag)#"O"
		*not found
			Case Inlist(m.loNode.Tag.gcLevel,"ROOT") And Thisform.lCR_HistoryTree
		*if we are in history mode and show more then one iten
		*a click on ROOT means show nothing
				loNode = m.loNode.Child
				If !Isnull(m.loNode) Then
					loNode = m.loNode.Next
					If !Isnull(m.loNode) Then
						lcFile  = ".F."
		
					Endif &&Isnull(m.loNode)
				Endif &&!Isnull(m.loNode)
		
			Case Inlist(m.loNode.Tag.gcLevel,"ROOT", "HISTORY", "LISTCLASS", "VCX", "SCX", "PRG", "VCX", "FRX", "MNX", "DBF", "PJX", "OTHER")
		*CASE INLIST(m.loNode.Tag.gcLevel,"ROOT", "HISTORY", "LISTCLASS", "VCX", "SCX", "PRG", "VCX", "FRX", "MNX", "DBF", "PJX", "OTHER")
		* One of the Main Root Nodes
		*!*	 	Case loNode.Index = 1 Or loNode.Parent.Index = 1 && One of the Main Root Nodes
		
		*!*		Case Not Eof(Thisform.cSearchResultsAlias)
		*!*			Thisform.oSearchEngine.EditFromCurrentRow(Thisform.cSearchResultsAlias,,Thisform.lMoveNewCodeToTopLeft)
		*!*			lcFile  = loNode.Tag.gcFilename
		
			Case Inlist(m.loNode.Tag.gcLevel, "FILE")
		*	Case "O" = Vartype(loNode.Tag)
				lcFile  = m.loNode.Tag.gcFilePath
		
			Case Inlist(m.loNode.Tag.gcLevel, "CLASS", "LISTED_CLASS")
		*	Case "O" = Vartype(loNode.Tag)
				lcFile  = m.loNode.Tag.gcFilePath
				lcClass = m.loNode.Tag.gcClass
		
		Endcase
		
		If Empty(m.lcFile) Or !File(m.lcFile)
			Return
		Endif
		
		loPBT = Createobject("GF_PEME_BaseTools")
		loPBT.EditSourceX(m.lcFile, m.lcClass, 0, 0, "")
		
	ENDPROC

	PROCEDURE treeview_nodeexpand		&& A Node of the Treeview is expanded
		Lparameters;
			toNode
		
		Local;
			lLReturn As Boolean
		
		lLReturn = .T.
		
		If Vartype(m.toNode.Tag) = "O" And m.toNode.Tag.glNeedFill Then
			Local;
				lcAlias        As String,;
				lcUni          As String,;
				lcSearch       As String,;
				lcScope        As String,;
				lcPath         As String,;
				lcRoot         As String,;
				lcSetEscape    As String,;
				lnSelect       As Number,;
				lcFilter       As String,;
				lcNewFilter    As Number,;
				llLockScreen   As Boolean,;
				loTree         As Object,;
				loNode         As Object
		
			loTree   = Thisform.containerLeft.oTreeView
		
			Thisform.oSearchEngine.oProgressBar = Thisform.ProgressBar
			Thisform.ProgressBar.Start(100, "Loading results for node...")
			Thisform.ProgressBar.nValue = 42
			Thisform.Refresh()
		
			llLockScreen = loTree.Visible = .F.
			If m.llLockScreen
				loTree.Visible = .F.
			Endif
			lcSetEscape = Set("Escape")
			Set Escape Off
		
			lnSelect = Select()
			lcAlias  = Thisform.cSearchResultsAlias
		
			loNode   = m.toNode
			lcRoot   = m.loNode.Child.Key
		
			loTree.Nodes.Remove(m.lcRoot)
		
			lcRoot =  m.loNode.Key
		
		
			lcUni    = m.loNode.Tag.gcUni
			lcSearch = m.loNode.Tag.gcSearch
			lcScope  = m.loNode.Tag.gcScope
			lcFilter = m.loNode.Tag.gcFilter
			lcPath   = m.loNode.Tag.gcFilePath
		
		*	lLReturn = Thisform.LoadSavedResults(m.lcPath)
		*****
		
			Thisform.cTreeViewFilter = m.lcFilter
		
			THIS.Set_SearchResultsAlias_Filter(m.lcFilter)
		
			Goto Top In (m.lcAlias)
		
			lLReturn = !Eof(m.lcAlias)
			If m.lLReturn Then
		*		Thisform.ApplyFilter()
		*		lLReturn = Thisform.FillSearchResultsCursor(.T.) && Pulls records from the search engine's results cursor.
		*		If m.lLReturn Then
				Thisform.PopulateNode(m.lcRoot, m.lcUni, m.lcSearch, m.lcScope, m.lcFilter)
		*
		*		Endif &&m.lLReturn
		
			Endif &&m.lLReturn
		
		*****
			loNode.Tag.glNeedFill = .F.
		
			Thisform.oGrid.SetFocus
			m.loTree.SetFocus()
		
			loTree.SelectedItem	= m.loNode
		
			loNode.Selected = .T.
			loNode.ENSUREVISIBLE()
		
			Select(m.lnSelect)
		
			If m.llLockScreen
				loTree.Visible = .T.
			Endif
			Set Escape &lcSetEscape
		
			Thisform.ProgressBar.Stop()
			Thisform.Containerright.Container2.Visible = .T.
			Thisform.Refresh()
		Endif &&VARTYPE(m.loNode.Tag) = "O' AND m.loNode.Tag.glNeedFill
		
		Return m.lLReturn
		
	ENDPROC

	PROCEDURE treeview_rightclick		&& A Node of the Treeview is RightClicked.
		If This.lCR_Allowed
			Local;
				lcChoice As String,;
				lcSort   As String,;
				lnBar    As Number,;
				llX1     As Boolean,;
				llX2     As Boolean,;
				llX3     As Boolean,;
				loNode   As Object,;
				loTree   As Object
		
			loTree = Thisform.containerLeft.oTreeView
			loNode = .Null.
			loNode = m.loTree.SelectedItem
		
			If Vartype(m.loNode)="O" Then
		
		*search HISTORY node
				Do While Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" And !Inlist(m.loNode.Tag.gcLevel, "HISTORY", "HELP")
					m.loNode = m.loNode.Parent
				Enddo &&Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" And !Inlist(m.loNode.Tag.gcLevel, "HISTORY", "HELP")
		
				If Isnull(m.loNode) Or !Vartype(m.loNode.Tag)="O" Then
					Return
				Endif &&Isnull(m.loNode) Or !Vartype(m.loNode.Tag)="O"
		
				llX1 = !Inlist(m.loNode.Tag.gcLevel,"ROOT")
				llX2 = m.llX1 Or loTree.Nodes.Count > 1
				llX3 = !This.lReplace_History
		
				lcSort   = Iif(Thisform.lCR_SortTreeAlpha," Recent"," Search Expression")
				lcChoice = ""
				lnBar    = 0
				GF_CreateContextMenu("NodeRightClick")
		
				IF m.llX3 THEN
				lnBar = m.lnBar + 1
				Define Bar (m.lnBar) Of NodeRightClick Prompt "Sort By " + m.lcSort
				On Selection Bar (m.lnBar) Of NodeRightClick m.lcChoice = "Sort"
				ENDIF &&m.llX3 
		
				If (m.llX1 Or m.llX2) AND m.llX3
					lnBar = m.lnBar + 1
					Define Bar (m.lnBar) Of NodeRightClick Prompt "\-"
				Endif &&(m.llX1 Or m.llX2) AND m.llX3
		
				If m.llX2
					lnBar = m.lnBar + 1
					Define Bar (m.lnBar) Of NodeRightClick Prompt "Clear All Results"
					On Selection Bar (m.lnBar) Of NodeRightClick m.lcChoice = "ClearAll"
				Endif &&m.llX2
		
				If m.llX1
					lnBar = m.lnBar + 1
					Define Bar (m.lnBar) Of NodeRightClick Prompt "Clear Result"
					On Selection Bar (m.lnBar) Of NodeRightClick m.lcChoice = "Clear"
				Endif &&m.llX1
		
				If (m.llX1 Or m.llX2) AND m.llX3
					lnBar = m.lnBar + 1
					Define Bar (m.lnBar) Of NodeRightClick Prompt "\-"
				Endif &&(m.llX1 Or m.llX2) AND m.llX3
		
				If m.llX2 AND m.llX3
					lnBar = m.lnBar + 1
					Define Bar (m.lnBar) Of NodeRightClick Prompt "Refresh All Results"
					On Selection Bar (m.lnBar) Of NodeRightClick m.lcChoice = "RefreshAll"
				Endif &&m.llX2 AND m.llX3
		
				If m.llX1 AND m.llX3
					lnBar = m.lnBar + 1
					Define Bar (m.lnBar) Of NodeRightClick Prompt "Refresh Result"
					On Selection Bar (m.lnBar) Of NodeRightClick m.lcChoice = "Refresh"
				Endif &&m.llX1 AND m.llX3
		
				Activate Popup NodeRightClick
				Release Popups NodeRightClick
		
				Do Case
					Case m.lcChoice = "Sort"
		*Resort Tree
						Thisform.lCR_SortTreeAlpha = !Thisform.lCR_SortTreeAlpha
						This.PopulateTreeFromHistory()
		
					Case m.lcChoice = "ClearAll"  AND m.llX3
		*delete all history (per scope) - search mode
						This.DeleteSearchResults(.Null., .F., .F., .F., .F., .F.)
						This.PopulateTreeFromHistory()
		
					Case m.lcChoice = "ClearAll"
		*delete all history (per scope) - view replace mode
						This.DeleteSearchResults(.Null., .F., .F., .T., .T., .F.)
						This.PopulateTreeFromHistory()
		
					Case m.lcChoice = "Clear" AND m.llX3
		*delete history for single (HISTORY) node - search mode
						If Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" Then
							This.DeleteSearchResults(m.loNode.Tag.gcUni, .F., .F., .F., .F., .F.)
		*delete node
							loTree.Nodes.Remove(m.loNode.Key)
							If loTree.Nodes.Count = 0 Then
		*if no node, set dummy root
								This.PopulateTreeFromHistory()
							Endif &&loTree.Nodes.Count = 0
						Endif &&Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O"
		
					Case m.lcChoice = "Clear"
		*delete history for single (HISTORY) node - view replace mode
						If Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" Then
							This.DeleteSearchResults(m.loNode.Tag.gcUni, .F., .F., .T., .F., .F.)
		*delete node
							loTree.Nodes.Remove(m.loNode.Key)
							If loTree.Nodes.Count = 0 Then
		*if no node, set dummy root
								This.PopulateTreeFromHistory()
							Endif &&loTree.Nodes.Count = 0
						Endif &&Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O"
		
					Case m.lcChoice = "RefreshAll"
		*refresh search all history
						This.RefreshResults(.Null.)
		
					Case m.lcChoice = "Refresh"
		*refresh search for node
						If Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O" Then
							This.RefreshResults(m.loNode)
						Endif &&Vartype(m.loNode)="O" And Vartype(m.loNode.Tag)="O"
		
				Endcase
		
			Endif &&Vartype(m.loNode)="O"
		Endif &&This.lCR_Allowed
		
	ENDPROC

	PROCEDURE updateformaftereplace
		Lparameters tnRecordId
		
		*Update Cur1 Set;
			lSaved = .T.;
			from (Thisform.oSearchEngine.cSearchResultsAlias) As Cur1;
			inner Join (Thisform.cSearchResultsAlias) As Cur2;
			on Cur2.lSaved;
			AND Cur2.cUni_File==Cur1.cUni_File
		
		*Thisform.FillSearchResultsCursor()
		
		Select(Thisform.cSearchResultsAlias)
		Goto Top
		
		Locate For Id = tnRecordId
		
		Try
				Thisform.oGrid.SetFocus()
			Catch
		Endtry
		
		Thisform.Refresh()
		
		Thisform.ShowCodeForCurrentRow(.T.)
		
		
	ENDPROC

	PROCEDURE updateformaftersearch
		Lparameters;
			tlUpdateForm
		
		Local;
			loSearchEngine,;
			lcUni,;
			lcFilter
		
		Thisform.lSearching = .F.
		
		loSearchEngine = Thisform.oSearchEngine
		
		*** JRN 2024-02-04 : Time out after 2 seconds. (Flash the message and exit)
		If loSearchEngine.lEscPress
			Messagebox('Processing stopped due to ESCAPE.', 16, 'Notice:', 2000)
		EndIf
		
		If loSearchEngine.lResultsLimitReached
			Messagebox("Processing stopped." + CRLF + CRLF + "Maximum results limit (" + Transform(Thisform.oSearchOptions.nMaxResults) + ") has been reached." + Chr(13) + Chr(13) +;
				"Adjust value in Options form if desired.", 64, "Notice:")
		Endif
		
		If loSearchEngine.nMatchLines > 0
			lcFilter = Thisform.ApplyFilter()
		
			Thisform.FillSearchResultsCursor(Thisform.lCR_HistoryTree, @lcUni) && Pulls records from the search engine"s results cursor.
			lcUni = [ cUni = "] + m.lcUni + ["]
			This.Set_SearchResultsAlias_Filter(m.lcUni)
			If m.tlUpdateForm
				Thisform.ShowCodeForCurrentRow()
			Endif &&m.tlUpdateForm
		Else
			Thisform.editSearch.SetFocus()
		Endif
		
		This.FormatProcessColumn()
		
		If m.tlUpdateForm
			Thisform.UpdateTreeView()
		Endif &&m.tlUpdateForm
		
		
	ENDPROC

	PROCEDURE updatesearchenginecursor
		*-- This method copies over certain fields from the local cursor to the GFSE cursor
		Local lcSearchEngineCursor, lcSearchResultsAlias, lnSelect
		
		lcSearchResultsAlias = Thisform.cSearchResultsAlias
		lcSearchEngineCursor = Thisform.oSearchEngine.cSearchResultsAlias
		
		lnSelect = Select()
		Select (lcSearchResultsAlias)
		
		MessageBox("start 1")
		Scan
			Update (lcSearchEngineCursor) ;
				Set  Process = &lcSearchResultsAlias..Process ;
				Where id = &lcSearchResultsAlias..id  
		Endscan 
		MessageBox("end 1")
		
		
		
		MessageBox("start 2")
		
		Scan
		lnId = id
		llProcess = process
		replace process with llProcess for id = lnId in (lcSearchEngineCursor) 
		Endscan 
		
		
		
		MessageBox("end 2")
		Select (lnSelect) 
	ENDPROC

	PROCEDURE updatesearchscopevariables
		With Thisform
			.cActiveProject = Thisform.oSearchEngine.GetActiveProject()
			.cCurrentDir = Thisform.oSearchEngine.GetCurrentDirectory()
			.oSearchEngine.AddProject(.cActiveProject)
		
			If Empty(.oSearchEngine.oSearchOptions.cPath)
				.oSearchEngine.oSearchOptions.cPath = .cCurrentDir
			Endif
		
		Endwith
		
		
		
	ENDPROC

	PROCEDURE updatetreeview
		Goto Top In (Thisform.cSearchResultsAlias)
		
		Thisform.Refresh()
		
		If !Eof(Thisform.cSearchResultsAlias)&& Thisform.oSearchEngine.nMatchLines > 0
			Thisform.PopulateTreeview( , , , , .T.)
			Thisform.oGrid.SetFocus()
		Else
			lcResults = Thisform.containerRight.container1.lblResults.Caption
		*SF 20221016 added colour options
		*	Thisform.PopulateTreeview(, lcResults, 128)
			Thisform.PopulateTreeview(, lcResults, , Thisform.nTreeUpdateColour)
		*/ SF 20221016 added colour options
			Thisform.ShowHtml("<h3>&nbsp;&nbsp;&nbsp;" + lcResults + "</h3>")
		Endif
		
		
	ENDPROC

	PROCEDURE validateinputs
		Local loGrid, loSearchEngine, loSearchOptions, loTimeStampToControl, lcPath
		
		loSearchOptions = Thisform.oSearchEngine.oSearchOptions
		lcScope = Thisform.GetCurrentScope()
		
		*-- Validate Directory (for Curr Dir or Browsed Dir)
		If Inlist(loSearchOptions.nSearchScope, 3, 4)
		
			lcPath = Addbs(lcScope)
			If !Directory(lcPath, 1)
				Messagebox('Invalid scope directory "' + lcPath + '". Please correct.', 0, "GoFish Error:")
				Return .F.
			Endif
		Endif
		
		*-- Validate Project file can be found (for Active Project and Browsed Project)
		If Inlist(loSearchOptions.nSearchScope, 1, 2)
			If !File(lcScope)
				Messagebox('Cannot find scope project file "' + lcScope + '". Please correct.', 0, "GoFish Error:")
				Return .F.
			Endif
		Endif
		
		*-- Must Specify a search expression, unless you are searching by TimeStamps
		If Empty(loSearchOptions.cSearchExpression) And !loSearchOptions.lTimeStamp
			Messagebox("Please specify a search string.", 16, "GoFish")
			Return .F.
		Endif
		
		*-- Make sure at least one date is supplied if timestamp box is checked.
		If loSearchOptions.lTimeStamp And Empty(loSearchOptions.dTimeStampFrom) And Empty(loSearchOptions.dTimeStampTo)
			Messagebox("At least one TimeStamp date must be entered, or else clear checkbox.", 16, "GoFish")
		Endif
		
		If !Thisform.lCR_HistoryTree Then
			If !Thisform.ClearSearchResultsCursor()
				Return .F.
			Endif
		Endif &&!Thisform.lCR_HistoryTree
		
		
		
	ENDPROC

	PROCEDURE validatereplaceexpression
		#DEFINE CR Chr(13)
		Local laHighRiskCount[1], laSelectedCount[1], lcExample, lcReplaceExpression, lnResponse
		
		lcReplaceExpression = Thisform.oSearchEngine.oSearchOptions.cReplaceExpression
		lcUDFCode = Thisform.oSearchEngine.cReplaceUDFCode
		lcExample = Strtran(lcReplaceExpression, " ", "{SPACE}") 
		
		
		If Thisform.nReplaceMode = 4  && UDF Replace mode
			If Empty(lcUDFCode)
				MessageBox("UDF Replace code is empty.",16, "WARNING:")
				Return .f.
			Else
				Return .t.
			Endif
		Endif
		
		If Len(lcReplaceExpression) = 0
			lnResponse = MessageBox("The Replace expression is an empty string." + CR + CR + ;
															"Are you sure you want to proceed with an empty Replace string?", 3, "WARNING:")
			If lnResponse <> 6
				Thisform.oSearchEngine.oSearchOptions.lAllowBlankReplace = .f.
				Return .f.
			EndIf
			
			Thisform.oSearchEngine.oSearchOptions.lAllowBlankReplace = .t.
		EndIf
		
		If Empty(lcReplaceExpression) and Len(lcReplaceExpression) > 0
			lnResponse = MessageBox("The Replace expression contains only spaces." + CR + CR + ;
															"Are you sure you want to proceed with this Replace string?" + CR + CR + ;
															lcExample, 3, "WARNING:")
			If lnResponse <> 6
				Thisform.oSearchEngine.oSearchOptions.lAllowBlankReplace = .f.
				Return .f.
			EndIf
			
			Thisform.oSearchEngine.oSearchOptions.lAllowBlankReplace = .t.
		EndIf
		
		If Left(lcReplaceExpression, 1) = " " and Right(lcReplaceExpression, 1) <> " "
			lnResponse = MessageBox("The Replace expression contains 1 or more leading spaces." + CR + CR + ;
															"Are you sure you want to proceed with this Replace string?"  + CR + CR + ;
															lcExample, 3, "WARNING:")
			If lnResponse <> 6
				Return .f.
			EndIf
		EndIf
		
		If Left(lcReplaceExpression, 1) <> " " and Right(lcReplaceExpression, 1) = " "
			lnResponse = MessageBox("The Replace expression contains 1 or more trailing spaces." + CR + CR + ;
															"Are you sure you want to proceed with this Replace string?"  + CR + CR + ;
															lcExample, 3, "WARNING:")
			If lnResponse <> 6
				Return .f.
			EndIf
		EndIf
		
		If Left(lcReplaceExpression, 1) = " " and Right(lcReplaceExpression, 1) = " " and !Empty(lcReplaceExpression) 
			lnResponse = MessageBox("The Replace expression contains leading and trailing SPACES." + CR + CR + ;
															"Are you sure you want to proceed with this Replace string?"  + CR + CR + ;
															lcExample, 3, "WARNING:")
			If lnResponse <> 6
				Return .f.
			EndIf
		EndIf
		
		*-- Notify user if they have selected any high-risk rows to replace
		Select Count(id) from (thisform.cSearchResultsAlias);
		 Where process and ReplaceRisk > 1;
		 Into Array laHighRiskCount
		
		If laHighRiskCount > 0 
		
			lnResponse = MessageBox("====================================================" + CR +;
															"             W  A  R  N  I  N  G	" + CR + ;
															"====================================================" + CR + CR +;
															"You have one or more high risk Match Types selected which could damage" + CR + ;
															"your files and prevent them from opening if your replace expression " + CR + ;
															"results in invalid code." + CR + CR + ;
															"Are you sure you want to proceed?", 3, "GoFish Replace")
			If lnResponse <> 6
				Return .f.
			EndIf
		EndIf 
		
	ENDPROC

	PROCEDURE viewreport
		Local laFields[1], lcAscDesc, lcCursor, lcField, lcFieldList, lcFilename, lcFilter, lcHeader, lcHtml
		Local lcOrderBy, lcResultsGridHtmlCursor, lcTable, lnX, loColumn, loShell
		
		lnSelect = Select()
		lcCursor = This.cSearchResultsAlias
		
		Dimension laFields[1, 2]
		lcFieldList = ""
		lnX = 1
		
		*-- Set Header captions from Field name -----------------
		For Each loColumn In Thisform.oGrid.Columns
			If loColumn.Visible
				If lnX > 1
					Dimension laFields[lnX, 2]
				Endif
				laFields[lnX, 1] = Transform(loColumn.ColumnOrder, "999")
				laFields[lnX, 2] = GetWordNum(m.loColumn.ControlSource, 2, '., )')
				lnX = lnX + 1
			Endif
		Endfor
		
		=Asort(laFields)
		
		For lnX = 1 To Alen(laFields) / 2
			If !Empty(lcFieldList)
				lcFieldList = lcFieldList + ","
			Endif
			lcFieldList = lcFieldList + laFields[lnX, 2]
		Endfor
		
		lcFilter = Filter(lcCursor)
		
		If !Empty(lcFilter)
			lcFilter = "Where " + lcFilter 
		Endif
		
		If !Empty(Thisform.cSortFields)
			lcField = Getwordnum(Thisform.cSortFields, 1, ",")
			lcAscDesc = Getwordnum(Thisform.cSortOrder, 1, ",")
			lcAscDesc = Iif("DESC" $ lcAscDesc, "DESCENDING", "")
		
			lcOrderBy = "Order By " + lcField + " " + lcAscDesc
		Else
			lcOrderBy = ""
		Endif
		
		lcResultsGridHtmlCursor = "ResultsGridHtml"
		Select &lcFieldList;
		 From &lcCursor;
		 &lcFilter;
		 &lcOrderBy;
		 Into Cursor &lcResultsGridHtmlCursor Readwrite
		
		If "matchtype" $ Lower(lcFieldList)
			Replace matchtype With Strtran(matchtype, "<", "") All
			Replace matchtype With Strtran(matchtype, ">", "") All
		Endif
		
		Goto Top
		
		*SF 20221016 added colour options
		*!*	Text To lcHeader Textmerge Noshow
		*!*		<Html>
		*!*		<Head>
		
		*!*		<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
		
		*!*		<script>$(document).ready(function(){
		*!*		   $("tr:even").css("background-color", "#F4F4A8");
		*!*		   $("tr:odd").css("background-color", "#EFF1D1");});
		*!*		</script>
		
		*!*		</Head>
		
		*!*		<Body>
		*!*			Scope&nbsp;: &nbsp;&nbsp; <<Thisform.GetCurrentScope()>> &nbsp;&nbsp;&nbsp;&nbsp; <<Thisform.cSearchResultsMessage>> &nbsp;&nbsp;&nbsp;&nbsp; <<Ttoc(DateTime())>> <br />
		*!*			Search: &nbsp;&nbsp; <<Thisform.oSearchEngine.oSearchOptions.cSearchExpression>> <br />
		*!*			<<Thisform.cResultsMessage>> <br />
		*!*			<hr />
		
		*!*	Endtext
		Text To lcHeader Textmerge Noshow
			<Html>
			<Head>
		
			<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.4/jquery.min.js"></script>
		
			<script>$(document).ready(function(){
			   $("tr:even").css("background-color", "#<<RIGHT(TRANSFORM(Thisform.nCSS_tr_even_Colour,'@0'),6)>>");
			   $("tr:odd").css("background-color", "#<<RIGHT(TRANSFORM(Thisform.nCSS_tr_odd_Colour,'@0'),6)>>");
			</script>
		
			</Head>
		
			<Body>
				Scope&nbsp;: &nbsp;&nbsp; <<Thisform.GetCurrentScope()>> &nbsp;&nbsp;&nbsp;&nbsp; <<Thisform.cSearchResultsMessage>> &nbsp;&nbsp;&nbsp;&nbsp; <<Ttoc(DateTime())>> <br />
				Search: &nbsp;&nbsp; <<Thisform.oSearchEngine.oSearchOptions.cSearchExpression>> <br />
				<<Thisform.cResultsMessage>> <br />
				<hr />
		
		Endtext
		*/ SF 20221016 added colour options
		
		lcTable = Thisform.oWebControl.CursorToHtml(lcResultsGridHtmlCursor, "Results")
		
		lcHtml = lcHeader + lcTable + "</body></Html>"
		
		lcFilename = Addbs(Sys(2023)) + "GF_ResultsGrid.html"
		
		Strtofile(lcHtml, lcFilename)
		
		loShell = Newobject("_ShellExecute", Home(1) + "Ffc\" + "_environ.vcx")
		loShell.ShellExecute(lcFilename)
		loShell.Release()
		
		Select (lnSelect)
		
	ENDPROC

	PROCEDURE ButtonContainer.chkLimitToProjectFolder.Refresh
		This.Enabled = !Thisform.lSearching &&and !Thisform.lReplaceViewMode
		
		This.Visible = (".PJX" $ Upper(Thisform.comboSearchScopeHistory.Text))
		
	ENDPROC

	PROCEDURE ButtonContainer.chkSubdirectories.Refresh
		This.Enabled = !Thisform.lSearching && and !Thisform.lReplaceViewMode
		
		This.Visible = !(".PJX" $ Upper(Thisform.comboSearchScopeHistory.text))
		
	ENDPROC

	PROCEDURE ButtonContainer.cmdAdvanced.Click
		Thisform.ShowAdvancedForm()
		Thisform.Refresh()
		
		
		
		
	ENDPROC

	PROCEDURE ButtonContainer.cmdAdvanced.Refresh
		This.Enabled = !Thisform.lSearching && and !Thisform.lReplaceViewMode
		
	ENDPROC

	PROCEDURE ButtonContainer.cmdAdvanced.RightClick
		Local lcChoice, lnBar
		lcChoice = ""
		lnBar	 = 0
		GF_CreateContextMenu("AdvancedContextMenu")
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\<Plain Search"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Plain Search"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.nSearchMode = 1
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\<Wildcards (* and ?)"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Wildcards (* and ?)"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.nSearchMode = 2
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\<RegEx Search"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "RegEx Search"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.nSearchMode = 3
		
		lnBar = m.lnBar + 1
		
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\-"
		
		If (".PJX" $ Upper(Thisform.comboSearchScopeHistory.Text))
			lnBar = m.lnBar + 1
			Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\<Limit search to project home directory and sub-folders"
			On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "\<Limit search to project home directory and sub-folders"
			Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.lLimitToProjectFolder
		Else
			lnBar = m.lnBar + 1
			Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\<Include Subdirectories"
			On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Match \<Case"
			Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.lIncludeSubdirectories
		Endif
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "Match \<Whole Word"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Match \<Whole Word"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.lMatchWholeWord
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "Match \<Case"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Match \<Case"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.lMatchCase
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "Search \<Comments"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Search \<Comments"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.lSearchInComments
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\-"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\<Ignore field RESERVED3 in SCXs / VCXs"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Ignore Properties field"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.lIgnorePropertiesField
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AdvancedContextMenu Prompt "\<Ignore values in MemberData"
		On Selection Bar (m.lnBar) Of AdvancedContextMenu m.lcChoice = "Ignore values in MemberData"
		Set Mark Of Bar (m.lnBar) Of AdvancedContextMenu To Thisform.oSearchOptions.lIgnoreMemberData
		
		* --------------------------------------------------------------------------------
		Activate Popup AdvancedContextMenu
		Release Popups AdvancedContextMenu
		* --------------------------------------------------------------------------------
		
		Do Case
			Case m.lcChoice = "Plain Search"
				Thisform.oSearchOptions.nSearchMode = 1
			Case m.lcChoice = "Wildcards (* and ?)"
				Thisform.oSearchOptions.nSearchMode = 2
			Case m.lcChoice = "RegEx Search"
				Thisform.oSearchOptions.nSearchMode = 3
			Case m.lcChoice = "\<Limit search to project home directory and sub-folders"
				Thisform.oSearchOptions.lLimitToProjectFolder = Not Thisform.oSearchOptions.lLimitToProjectFolder
			Case m.lcChoice = "\<Include Subdirectories"
				Thisform.oSearchOptions.lIncludeSubdirectories = Not Thisform.oSearchOptions.lIncludeSubdirectories
			Case m.lcChoice = "Match \<Case"
				Thisform.oSearchOptions.lMatchCase = Not Thisform.oSearchOptions.lMatchCase
			Case m.lcChoice = "Match \<Whole Word"
				Thisform.oSearchOptions.lMatchWholeWord = Not Thisform.oSearchOptions.lMatchWholeWord
			Case m.lcChoice = "Search \<Comments"
				Thisform.oSearchOptions.lSearchInComments = Not Thisform.oSearchOptions.lSearchInComments
			Case m.lcChoice = "Ignore Properties field"
				Thisform.oSearchOptions.lIgnorePropertiesField = Not Thisform.oSearchOptions.lIgnorePropertiesField
			Case m.lcChoice = "Ignore values in MemberData"
				Thisform.oSearchOptions.lIgnoreMemberData = Not Thisform.oSearchOptions.lIgnoreMemberData
		
		Endcase
		
		Thisform.Refresh()
		
		
		
	ENDPROC

	PROCEDURE ButtonContainer.cmdHelp.Click
		ThisForm.ShowHelpForm()
	ENDPROC

	PROCEDURE ButtonContainer.cmdHelp.Refresh
		This.Enabled = !Thisform.lSearching
	ENDPROC

	PROCEDURE ButtonContainer.cmdHistory.Click
		Thisform.RestoreSearchFromHistory()
	ENDPROC

	PROCEDURE ButtonContainer.cmdHistory.Refresh
		This.Enabled = !Thisform.lSearching
	ENDPROC

	PROCEDURE ButtonContainer.cmdHistory.RightClick
		Local lcChoice, lnBar, lnSelect, lnRecordId
		
		lnSelect = Select()
		
		SELECT (Thisform.cSearchResultsAlias)
		lnRecordId = Id
		
		lcChoice = ""
		lnBar	 = 0
		GF_CreateContextMenu("AccessContextMenu")
		
		If !Thisform.lSaveSearchResults Then
			lnBar = m.lnBar + 1
			Define Bar (m.lnBar) Of AccessContextMenu Prompt "\<Save last search"
			On Selection Bar (m.lnBar) Of AccessContextMenu m.lcChoice = "Save last search"
		Endif &&!Thisform.lSaveSearchResults
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AccessContextMenu Prompt "\<Restore last saved search"
		On Selection Bar (m.lnBar) Of AccessContextMenu m.lcChoice = "Restore last search"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AccessContextMenu Prompt "\<Browse saved search history"
		On Selection Bar (m.lnBar) Of AccessContextMenu m.lcChoice = "Restore from history"
		
		lnBar = m.lnBar + 1
		
		Define Bar (m.lnBar) Of AccessContextMenu Prompt "\-"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AccessContextMenu Prompt "Save \<All search results"
		On Selection Bar (m.lnBar) Of AccessContextMenu m.lcChoice = "Save all search results"
		Set Mark Of Bar (m.lnBar) Of AccessContextMenu To Thisform.lSaveSearchResults
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of AccessContextMenu Prompt "Restore \<Previous results on startup"
		On Selection Bar (m.lnBar) Of AccessContextMenu m.lcChoice = "Restore previous results on startup"
		Set Mark Of Bar (m.lnBar) Of AccessContextMenu To Thisform.lRestorePreviousSearchResultsOnStartup
		
		
		Activate Popup AccessContextMenu
		Release Popups AccessContextMenu
		
		Do Case
			Case m.lcChoice = "Save last search"
				If Thisform.SaveSearchResults()
					Messagebox("Saved")
				Endif &&Thisform.SaveSearchResults()
			Case m.lcChoice = "Restore last search"
		*		Thisform.RestoreLastSearch()
				Thisform.RestorePreviousSearch()
			Case m.lcChoice = "Restore from history"
				Thisform.RestoreSearchFromHistory()
		
			Case m.lcChoice = "Save all search results"
				Thisform.lSaveSearchResults = Not Thisform.lSaveSearchResults
			Case m.lcChoice = "Restore previous results on startup"
				Thisform.lRestorePreviousSearchResultsOnStartup = Not Thisform.lRestorePreviousSearchResultsOnStartup
		Endcase
		
		
		SELECT(Thisform.cSearchResultsAlias)
		Locate For Id = lnRecordId
		
		Select(m.lnSelect)
	ENDPROC

	PROCEDURE ButtonContainer.cmdOptions.Click
		ThisForm.ShowOptionsForm()
		
	ENDPROC

	PROCEDURE ButtonContainer.cmdOptions.Refresh
		This.Enabled = !Thisform.lSearching
	ENDPROC

	PROCEDURE ButtonContainer.cmdRegexpHelp.Click
		Local lcChoice, lcValue, lnBar, lnSelStart, loEdit
		
		lcChoice = ""
		lnBar	 = 0
		GF_CreateContextMenu("RegExpHelpMenu")
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt ". Any single character"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "."
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "* Zero or more"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "*"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "+ One or more"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "+"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "\-"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "^ Beginning of line"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "^"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "$ End of line"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "$"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "[] Any one character in the set"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "[]"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "[^] Any one character not in the set"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "[^]"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "\-"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "| OR"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "|"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "\\ Escape Special Character"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "\"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "\\s White space (blank or tab)"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "\s"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "\\s* Zero or more blanks or tabs"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "\s"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "\\b Word boundary"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "\b"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "\-"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "VFP Help for RegExp"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "VFP Help"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of RegExpHelpMenu Prompt "RegEx Cheat Sheet"
		On Selection Bar (m.lnBar) Of RegExpHelpMenu m.lcChoice = "RegEx Cheat Sheet"
		
		* --------------------------------------------------------------------------------
		Activate Popup RegExpHelpMenu
		Release Popups RegExpHelpMenu
		* --------------------------------------------------------------------------------
		
		Do Case
			Case m.lcChoice = "VFP Help"
				Help Id 1231103
			Case m.lcChoice = "RegEx Cheat Sheet"
				GF_Shell("http://tinyurl.com/qxv3e96")
			Case Not Empty(m.lcChoice)
				loEdit	   = Thisform.editSearch
				lcValue	   = m.loEdit.Value
				lnSelStart = m.loEdit.SelStart
		
				loEdit.Value = Left(m.lcValue, m.lnSelStart) + m.lcChoice + Substr(m.lcValue, lnSelStart + 1)
		Endcase
		
		Thisform.Refresh()
		
		
	ENDPROC

	PROCEDURE ButtonContainer.cmdRegexpHelp.Refresh
		This.Visible = Thisform.oSearchOptions.nSearchMode = 3
	ENDPROC

	PROCEDURE ButtonContainer.cmdSave.Click
		Local;
			lnRecordId As Number,;
			lnSelect As Number
		
		lnSelect = Select()
		
		Select (Thisform.cSearchResultsAlias)
		lnRecordId = Id
		
		If Thisform.SaveSearchResults()
			Messagebox("Saved")
		Endif &&Thisform.SaveSearchResults()
		
		
		Select(Thisform.cSearchResultsAlias)
		Locate For Id = m.lnRecordId
		
		Select(m.lnSelect)
	ENDPROC

	PROCEDURE ButtonContainer.cmdSave.Refresh
		This.Enabled = !Thisform.lSearching
	ENDPROC

	PROCEDURE ButtonContainer.cmdSearch.Click
		ThisForm.Search()
		
	ENDPROC

	PROCEDURE ButtonContainer.cmdSearch.Refresh
		This.Enabled = !Thisform.lSearching &&and !Thisform.lReplaceViewMode
	ENDPROC

	PROCEDURE ButtonContainer.cmdSearch.RightClick
		Do Form "GF_Collection_Explorer" with This
		
	ENDPROC

	PROCEDURE ButtonContainer.comboViewPosition.Init
		This.AddItem("Plain search")
		This.AddItem("Wildcards (* and ?)")
		This.AddItem("Regular Expression")
		
	ENDPROC

	PROCEDURE ButtonContainer.comboViewPosition.Refresh
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE ButtonContainer.comboViewPosition.Valid
		DoDefault()
		This.Parent.cmdRegexpHelp.Refresh()
		
	ENDPROC

	PROCEDURE ButtonContainer.Container1.chkApplyFilter.Valid
		This.Parent.Refresh()
	ENDPROC

	PROCEDURE ButtonContainer.Container1.Refresh
		If thisform.oSearchEngine.oSearchOptions.lMatchWholeWord and !Thisform.lSearching
			This.BorderWidth = 2
		Else
			This.BorderWidth = 0
		EndIf 
		
	ENDPROC

	PROCEDURE ButtonContainer.Container2.chkApplyFilter.Valid
		This.Parent.Refresh()
	ENDPROC

	PROCEDURE ButtonContainer.Container2.Refresh
		If Thisform.oSearchEngine.oSearchOptions.lMatchCase and !Thisform.lSearching
			This.BorderWidth = 2
		Else
			This.BorderWidth = 0
		EndIf 
		
	ENDPROC

	PROCEDURE ButtonContainer.Container3.chkApplyFilter.Valid
		This.Parent.Refresh()
	ENDPROC

	PROCEDURE ButtonContainer.Container3.Refresh
		If !Thisform.oSearchEngine.oSearchOptions.lSearchInComments and !Thisform.lSearching
			This.BorderWidth = 2
		Else
			This.BorderWidth = 0
		EndIf 
		
	ENDPROC

	PROCEDURE ButtonContainer.lblCodeView.Refresh
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE ButtonContainer.lblSearchTime.Refresh
		Local lcFiles, lcMatchLines, lnSeconds
		
		lnSeconds = Thisform.oSearchEngine.nSearchTime
		lcMatchLines = Transform(Thisform.oSearchEngine.nMatchLines)
		lcFiles = Transform(Thisform.oSearchEngine.nFileCount)
		
		If Thisform.lInit and !thisform.lSearching
			Text To Thisform.cSearchResultsMessage Noshow Textmerge
		<<lcMatchLines>> lines
		<<lcFiles>> file(s)
		in <<Alltrim(Transform(lnSeconds, "99999.9"))>> seconds
			EndText 
		Else
			 Thisform.cSearchResultsMessage = ""
		Endif
		
		This.Caption = Thisform.cSearchResultsMessage 
		
		
	ENDPROC

	PROCEDURE ButtonContainer.Refresh
		*This.Visible = !Thisform.lSearching && and !Thisform.lReplaceViewMode
		
		This.Visible = !Thisform.lSearching;
		 AND (!Thisform.lReplaceViewMode OR (Thisform.lReplaceViewMode AND !Thisform.nReplaceMode=5))
	ENDPROC

	PROCEDURE comboSearchExpressionHistory.Refresh
		DoDefault()
		
		This.FontSize = Thisform.nSearchBoxFontSize
	ENDPROC

	PROCEDURE comboSearchExpressionHistoryDropDownArrow.GotFocus
		Local loCombo
		
		*-- Store current value of editbox. I the user presses ESCAPE in the actual combobox,
		*-- the oringal value can be recovered from here.
		This.Tag = This.Parent.editSearch.Value
		
		loCombo = This.Parent.comboSearchExpressionHistory
		
		With loCombo
			.ListIndex = 1
			.Visible = .T.
			.SetFocus()
		Endwith
		
		This.ZOrder(1)
		
		*-- Do this to force the combobox to drop down...
		Mouse Click At This.Top + Int(This.height / 2), This.Left + Int(This.width/2) PIXELS Window (Thisform.Name)
		
		*Keyboard "{ALT+DNARROW}" && To expand the actual dropdown listbox that holds all the values
	ENDPROC

	PROCEDURE comboSearchExpressionHistoryDropDownArrow.Init
		this.Top = this.Parent.editSearch.top
	ENDPROC

	PROCEDURE comboSearchExpressionHistoryDropDownArrow.Refresh
		This.Enabled = !Thisform.lSearching;
		 AND (!Thisform.lReplaceViewMode OR (Thisform.lReplaceViewMode AND !Thisform.nReplaceMode=5))
		
		
	ENDPROC

	PROCEDURE comboSearchScope.Init
		With This
			.AddItem("Active Project")
			.AddItem("Browse Project")
			.AddItem("Current Dir")
			.AddItem("Browse Dir")
			.AddItem("All Open Projects")
		EndWith && This
		
	ENDPROC

	PROCEDURE comboSearchScope.Refresh
		This.Enabled = !Thisform.lSearching && and !Thisform.lReplaceViewMode
		
		DoDefault()
		
		
	ENDPROC

	PROCEDURE comboSearchScope.Valid
		Local lcNewScope
		
		lcNewScope = Thisform.oSearchOptions.cRecentScope
		
		Do Case
			Case This.Value = 1
				If _vfp.Projects.Count # 0
					lcNewScope = _vfp.ActiveProject.Name
				Else
					lcNewScope = ''
				Endif
		
			Case This.Value = 2
				This.Parent.comboSearchScopeHistory.SetFocus()
				Return
		
			Case This.Value = 3
				lcNewScope = Alltrim(Lower(Thisform.oSearchEngine.GetCurrentDirectory()), '\')
		
			Case This.Value = 4
				This.Parent.comboSearchScopeHistory.SetFocus()
				Return
		
			Case This.Value = 5
				If _vfp.Projects.Count # 0
					lcNewScope = _vfp.ActiveProject.Name
				Else
					lcNewScope = ''
				Endif
		Endcase
		
		Thisform.oSearchOptions.cRecentScope = Lower(m.lcNewScope)
		
		This.Parent.comboSearchScopeHistory.Refresh()
		
	ENDPROC

	PROCEDURE comboSearchScopeHistory.InteractiveChange
		If Thisform.lCR_Allowed
			*!* ******** JRN Removed 2024-02-22 ********
			*!* This.SetFocus()
			If Thisform.lCR_SearchComboPerScope
				Thisform.comboSearchExpressionHistory.LoadRows
				Thisform.editSearch.Value = ""
			Endif &&Thisform.lCR_StorePerScope
		
			If Thisform.lCR_Allow And Thisform.lCR_HistoryPerScope
				If Thisform.lCR_HistoryTree Then
					Thisform.PopulateTreeFromHistory()
		
				Else  &&Thisform.lCR_HistoryTree
					Thisform.RestorePreviousSearch()
		
				Endif &&Thisform.lCR_HistoryTree
			Endif &&Thisform.lCR_Allow AND Thisform.lCR_HistoryPerScope
		Endif &&Thisform.lCR_Allowed
		
	ENDPROC

	PROCEDURE comboSearchScopeHistory.ProgrammaticChange
		Local;
			lItemExists As Integer,;
			lcValue  As String,;
			lnLoop   As Integer
		
		lItemExists = .F. && assume the value isn't in the list.
		lcValue     = Alltrim(This.Value)
		lcValue     = Rtrim(Lower(m.lcValue), '\')
		
		If This.Value = This.Tag And !Empty(This.Tag)
			Return .T.
		Endif
		
		For lnLoop = 1 To This.ListCount
			If Lower(This.List(m.lnLoop)) = m.lcValue
				lItemExists = .T.
				Exit
			Endif
		Endfor
		
		If !m.lItemExists
			This.AddItem(m.lcValue)
		Endif
		
		This.Value = Alltrim(This.Value)
		This.Valid()
		This.InteractiveChange()
		
	ENDPROC

	PROCEDURE comboSearchScopeHistory.Refresh
		This.Enabled = .T.
		This.Visible = .T.
		
		Do Case
			Case Thisform.lSearching
				This.Enabled = .F.
		
			Case Thisform.oSearchOptions.nSearchScope = 1
				This.Enabled = .F.
		
			Case Thisform.oSearchOptions.nSearchScope = 3
				This.Enabled = .F.
		
			Case Thisform.oSearchOptions.nSearchScope = 5
				This.Visible = .F.
		
		Endcase
		
		DoDefault()
		
		This.FontSize = Thisform.nSearchBoxFontSize
	ENDPROC

	PROCEDURE containerLeft.cntVersion.cmdVFPX.Click
		GF_Shell('http://vfpx.org')
	ENDPROC

	PROCEDURE containerLeft.cntVersion.Gf_versionlabel1.Refresh
		Local lcAPPName, lcVersion
		
		lcAPPName = Juststem(_Screen._GoFish.cAppName)
		lcVersion = _Screen._GoFish.cVersion
		
		This.Caption = 'GoFish ' + m.lcVersion
		This.Caption = This.Caption + ' ... ' + Dtoc(_Screen._GoFish.dbuilddate)
		
		
	ENDPROC

	PROCEDURE containerLeft.cntVersion.Gf_versionlabel2.Click
		GF_Shell('https://github.com/VFPX/GoFish/issues')
		
		
	ENDPROC

	PROCEDURE containerLeft.cntVersion.Gf_versionlabel2.Refresh
		*
	ENDPROC

	PROCEDURE containerLeft.cntVersion.Gf_versionlabel3.Click
		If Atc('Beta', _Screen._GoFish.cVersion) # 0
			GF_Shell('https://github.com/VFPX/GoFish/blob/master/docs/ChangeLogBeta.md')
		Else
			GF_Shell('https://github.com/VFPX/GoFish/blob/master/docs/ChangeLog.md')
		EndIf
		
	ENDPROC

	PROCEDURE containerLeft.cntVersion.Gf_versionlabel3.Refresh
		*
		
	ENDPROC

	PROCEDURE containerLeft.cntVersion.Refresh
		*	This.Visible = !Thisform.lSearching && and !Thisform.lReplaceViewMode
	ENDPROC

	PROCEDURE containerLeft.oTreeView.Click
		*** ActiveX Control Event ***
		
	ENDPROC

	PROCEDURE containerLeft.oTreeView.DblClick
		If Vartype(This.SelectedItem)="O" Then
			Thisform.TreeView_NodeDBLClick (This.SelectedItem)
		Endif &&Vartype(This.SelectedItem)="O"
		
	ENDPROC

	PROCEDURE containerLeft.oTreeView.Expand
		*** ActiveX Control Event ***
		Lparameters toNode
		
		Thisform.TreeView_NodeExpand(m.toNode)
		
	ENDPROC

	PROCEDURE containerLeft.oTreeView.Init
		Thisform.oTree = This
		THIS.AddProperty("glRightClick", .F.)
		
	ENDPROC

	PROCEDURE containerLeft.oTreeView.MouseDown
		*** ActiveX Control Event ***
		Lparameters Button, Shift, x, Y
		
		This.glRightClick = (Button == 2)
		
		
	ENDPROC

	PROCEDURE containerLeft.oTreeView.NodeClick
		Lparameters toNode
		
		If This.glRightClick Then
			This.glRightClick = .F.
		
		*	THISFORM.cEvent = "RIGHTCLICKMENU"
			Thisform.tmrEvent.Enabled = .T.
		
		Else  &&This.glRightClick
			Thisform.TreeView_NodeClick(m.toNode)
		
		Endif &&This.glRightClickEndif
		
	ENDPROC

	PROCEDURE containerLeft.oTreeView.Refresh
		*** ActiveX Control Method ***
		
	ENDPROC

	PROCEDURE containerRight.Container1.chkReplaceMode.Click
		If !thisform.oSearchEngine.oSearchOptions.lEnableReplaceMode AND thisform.lReplaceViewMode
			MessageBox("You must enable Replace Mode in the Options form before it can be used.", 32, "Notice")
		Endif
		
		DoDefault()
		
		If thisform.lReplaceViewMode
			ThisForm.FocusOnReplacePageframe()
		EndIf
		
	ENDPROC

	PROCEDURE containerRight.Container1.chkReplaceMode.Refresh
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container1.cmdClassBrowser.Click
		Local lcClass, lcFile
		
		lcFile	= Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
		lcClass	= Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".class"))
		
		Do Case
			Case Empty(m.lcFile)
				Return
			Case Empty(m.lcClass)
				Do (_Browser) With m.lcFile
			Otherwise
				Do (_Browser) With m.lcFile, m.lcClass
		Endcase
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.cmdClassBrowser.Refresh
		Local lcFile
		
		lcFile = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
		
		This.visible = !Empty(lcFile) and Upper(JustExt(lcFile)) = "VCX"
		
	ENDPROC

	PROCEDURE containerRight.Container1.cmdEdit.Click
		Thisform.EditFile()
	ENDPROC

	PROCEDURE containerRight.Container1.cmdEdit.Refresh
		Local lcFile
		
		This.Enabled = Reccount(Thisform.cSearchResultsAlias) > 0
		
		lcFile = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
		This.visible = !Empty(lcFile)
		 
	ENDPROC

	PROCEDURE containerRight.Container1.cmdEdit.RightClick
		Local lcAlias, lcCode, lcMethod, lcTempFile, loEditorWin
		
		lcAlias	= (Thisform.cSearchResultsAlias)
		lcCode	= &lcAlias..ProcCode
		If Empty(m.lcCode)
			Return
		Endif
		
		lcMethod   = Trim(Evl(&lcAlias..MethodName, "Method"))
		lcTempFile = Addbs(Sys(2023)) + m.lcMethod + Sys(2015) + ".prg"
		Strtofile(m.lcCode, m.lcTempFile)
		Modify command (m.lcTempFile) Nowait
		
		If GF_IsThorThere()
			loEditorWin = Execscript(_Screen.cThorDispatcher, "Class= editorwin from pemeditor")
			m.loEditorWin.SetTitle(m.lcTempFile)
			ThisForm.oSearchEngine.ThorMoveWindow()
		Endif
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.cmdGoToObject.Click
		Thisform.editObjectfromCurrentRow()
	ENDPROC

	PROCEDURE containerRight.Container1.cmdGoToObject.Refresh
		Local lcFile, lcMatchType, lcName
		
		If GF_IsThorThere()
			lcFile		= Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
			lcName		= Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".name"))
			lcMatchType	= Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".MatchType"))
		
			This.Visible = Not Empty(m.lcName)							;
				And Not Empty(m.lcFile)									;
				And Inlist(Upper(Justext(m.lcFile)), "SCX", "VCX")		;
				And 0 = Atc(m.lcMatchType, MatchType_Name + MATCHTYPE_PROPERTY_NAME + MATCHTYPE_PROPERTY_VALUE + MATCHTYPE_PROPERTY_DEF)
		Else
			This.Visible = .F.
		Endif
	ENDPROC

	PROCEDURE containerRight.Container1.cmdMenu.Click
		Thisform.EditMenufromCurrentRow()
	ENDPROC

	PROCEDURE containerRight.Container1.cmdMenu.Refresh
		Local lcFile, lcName
		
		If GF_IsThorThere()
			lcFile		 = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
			This.Visible = Not Empty(m.lcFile) And Inlist(Upper(Justext(m.lcFile)), "MNX", "MPR")
		Else
			This.Visible = .F.
		Endif
	ENDPROC

	PROCEDURE containerRight.Container1.cmdOpenExplorer.Click
		Local lcPath, lcFile
		
		lcFile = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
		
		If Empty(lcFile)
			Return
		Endif
		
		GF_OpenExplorerWindow(lcFile)
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.cmdOpenExplorer.Refresh
		Local lcFile
		
		lcFile = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
		
		This.visible = !Empty(lcFile)
		
	ENDPROC

	PROCEDURE containerRight.Container1.cmdReport.Click
		Local lcChoice, lnBar
		lcChoice = ""
		lnBar	 = 0
		GF_CreateContextMenu("ExportContextMenu")
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of ExportContextMenu Prompt "To DBF or XLSX"
		On Selection Bar (m.lnBar) Of ExportContextMenu m.lcChoice = "To DBF or XLSX"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of ExportContextMenu Prompt "To Cursor"
		On Selection Bar (m.lnBar) Of ExportContextMenu m.lcChoice = "To Cursor"
		
		lnBar = m.lnBar + 1
		Define Bar (m.lnBar) Of ExportContextMenu Prompt "View in Browser"
		On Selection Bar (m.lnBar) Of ExportContextMenu m.lcChoice = "View in Browser"
		
		Activate Popup ExportContextMenu
		Release Popups ExportContextMenu
		
		Do Case
			Case m.lcChoice = "To DBF or XLSX"
				Thisform.ExportToExcel(.T.)
			Case m.lcChoice = "To Cursor"
				Thisform.ExportToExcel(.F.)
			Case m.lcChoice = "View in Browser"
				Thisform.ViewReport()
		Endcase
		
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.cmdReport.Refresh
		This.Visible = !Thisform.lSearching and !Eof(Thisform.cSearchResultsAlias) && and !Thisform.lReplaceViewMode
	ENDPROC

	PROCEDURE containerRight.Container1.cmdSearchErrors.Click
		ThisForm.ShowSearchErrors()
		
		*-- For now, Object Inspector slow VFP way down, so can't use it until that gets fixed.
		*!*	Local loInspector
		
		*!*	loInspector = ExecScript(_Screen.cThorDispatcher, "Class= inspector from inspector")
		
		*!*	If Vartype(loInspector) = "O" 
		*!*		loInspector.oRoot = Thisform.oSearchEngine.oSearchErrors
		*!*		loInspector.Caption = "GoFish Search Errors:"
		*!*		loInspector.Show()
		*!*	Endif
		
		
		 
	ENDPROC

	PROCEDURE containerRight.Container1.cmdSearchErrors.Refresh
		This.Visible = (Thisform.oSearchEngine.oSearchErrors.Count > 0) and !thisform.lSearching
	ENDPROC

	PROCEDURE containerRight.Container1.Command1.Click
		ThisForm.ShowGoFishHelpPage()
	ENDPROC

	PROCEDURE containerRight.Container1.Command1.Refresh
		This.Visible = .F. && !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container1.chkApplyFilter.Click
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container1.chkApplyFilter.Valid
		Thisform.ApplyFilter()
		If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
			Thisform.PopulateTreeFromHistory()
		
		Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
			Thisform.UpdateTreeView()
		Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
		
		This.Parent.Refresh()
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container1.cmdFilter.Click
		ThisForm.ShowFilterForm("GoFish_FilterPF")
		This.Parent.Parent.gridFiles.Refresh()
		This.Parent.Parent.gridFiles.SetFocus()
		
		External form GoFish_Filter
	ENDPROC

	PROCEDURE containerRight.Container1.Container1.cmdFilter.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		Local lcFilter
		
		lcFilter = Evl(Filter(Thisform.cSearchResultsAlias), "")
		lcFilter = Strtran(lcFilter, ".And.", Chr[13] + "   And ", 1, -1, 1)
		
		This.ToolTipText = lcFilter
	ENDPROC

	PROCEDURE containerRight.Container1.Container1.cmdFilter.Refresh
		Local lcFilter
		This.FontBold = Not Empty(Thisform.cFilter)&& and Thisform.lApplyFilter
		
		This.Enabled = Reccount(Thisform.cSearchResultsAlias) > 0 And Not Thisform.lSearching &&and !Thisform.lReplaceViewMode
		
		This.Parent.chkApplyFilter.Enabled = This.Enabled And Not Empty(Thisform.cFilter)
		
		lcFilter = Evl(Thisform.cFilter, "")
		lcFilter = Strtran(m.lcFilter, ".And.", Chr[13] + "   And ", 1, -1, 1)
		
		This.ToolTipText = Iif(Thisform.lApplyFilter, "", "*** Not currently active ***" + Chr[13]) + m.lcFilter
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container1.cmdFilter.RightClick
		Local lcFilter
		
		lcFilter = Evl(Filter(Thisform.cSearchResultsAlias), "")
		lcFilter = Strtran(lcFilter, ".And.", Chr[13] + "   And ", 1, -1, 1)
		
		lcFilter = Iif(Thisform.lApplyFilter, "", "*** Not currently active ***" + Chr[13]) + m.lcFilter
		MessageBox(lcFilter, 0, "GoFish Filter") 
	ENDPROC

	PROCEDURE containerRight.Container1.Container1.Refresh
		If Thisform.lApplyFilter and Reccount(Thisform.cSearchResultsAlias) > 0 and !Thisform.lSearching
			This.BorderWidth = 2
		*	this.BorderColor = Rgb(255,0,0)
			this.BorderColor = Thisform.nContainerFrameColour
		Else
			This.BorderWidth = 1
			this.BorderColor = Rgb(0,0,0)
		EndIf 
		
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container2.Check1.Refresh
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container2.Check1.Valid
		Local lcFilter
		
		If This.Value
			Thisform.lCodeOnly = .F.
		EndIf 
		
		lcFilter = Thisform.ApplyFilter()
		
		If Empty(Thisform.cTreeViewFilter)
			Thisform.UpdateTreeView()
		Else
			lcFilter = Thisform.CombineFilters(m.lcFilter, Thisform.cTreeViewFilter)
			Set Filter To &lcFilter In (Thisform.cSearchResultsAlias)
		Endif
		
		Thisform.Refresh()
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container2.chkCodeOnly.Refresh
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container2.chkCodeOnly.Valid
		Local lcFilter
		
		If This.Value
			Thisform.lCommentsOnly = .F.
		EndIf 
		
		lcFilter = Thisform.ApplyFilter()
		
		If Empty(Thisform.cTreeViewFilter)
			Thisform.UpdateTreeView()
		Else
			lcFilter = Thisform.CombineFilters(m.lcFilter, Thisform.cTreeViewFilter)
			Set Filter To &lcFilter In (Thisform.cSearchResultsAlias)
		Endif
		
		Thisform.Refresh()
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.Container2.Refresh
		Do Case
			Case Thisform.lSearching
				This.BorderWidth = 0
			Case Thisform.lCodeOnly Or Thisform.lCommentsOnly
				This.BorderWidth = 2
				This.BorderColor = Rgb(255, 0, 0)
			Otherwise 
				This.BorderWidth = 1
				This.BorderColor = Rgb(0, 0, 0)
		Endcase
		
		DoDefault()
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.cmdReplaceErrors.Click
		ThisForm.ShowReplaceErrors()
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.cmdReplaceErrors.Refresh
		This.Visible = (Thisform.oSearchEngine.oReplaceErrors.Count > 0) and !thisform.lSearching
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.optiongroupReplaceMode.Option4.Valid
		ThisForm.FocusOnReplacePageframe()
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.optiongroupReplaceMode.Refresh
		
		This.Option2.Enabled = (Thisform.nReplaceRisk > 0) And ;
			Thisform.oSearchEngine.oSearchOptions.lEnableReplaceMode ;
			And Thisform.lReplaceViewMode
		This.Option3.Enabled = This.Option2.Enabled
		This.Option4.Enabled = This.Option2.Enabled
		
		*!*	If Thisform.oSearchEngine.oSearchOptions.lEnableReplaceMode = .F.
		*!*		Thisform.lReplaceViewMode = .F.
		*!*	Endif
		
		
		
		*.<<@F>>.
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.chkPreview.Click
		If this.Value
			Thisform.DoReplace(.t.) && .t. means do a "Preview" Replace
		Endif
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.chkPreview.Valid
		Thisform.ApplyFilter()
		If Thisform.lCR_Allow And Thisform.lCR_HistoryTree Then
			Thisform.PopulateTreeFromHistory()
		
		Else  &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
			Thisform.UpdateTreeView()
		Endif &&Thisform.lCR_Allow And Thisform.lCR_HistoryTree
		
		This.Parent.Refresh()
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdCheckAll.Click
		ThisForm.CheckAll()
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdCheckAll.Refresh
		This.Visible = Thisform.lReplaceViewMode and Thisform.nReplaceMode <> 3
		
		This.Enabled = (Reccount(Thisform.cSearchResultsAlias) > 0)
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdClearAll.Click
		ThisForm.ClearAll()
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdClearAll.Refresh
		This.Visible = Thisform.lReplaceViewMode and Thisform.nReplaceMode <> 3
		
		This.Enabled = (Reccount(Thisform.cSearchResultsAlias) > 0)
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdReplace.Click
		ThisForm.Replace()
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.cmdReplace.Refresh
		Local;
			lcCursor    As String,;
			llReplaced  As Boolean,;
			lnRiskLevel As Number
		
		lcCursor    = Thisform.cSearchResultsAlias
		lnRiskLevel = &lcCursor..ReplaceRisk
		llReplaced  = &lcCursor..Replaced
		
		This.Enabled = !Eof(m.lcCursor) And (m.lnRiskLevel <= Thisform.nReplaceRisk) And !m.llReplaced
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.editReplaceExpression.GotFocus
		This.SelStart = 0
		This.SelLength = Len(This.Value)
		this.Tag = this.value
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page1.editReplaceExpression.LostFocus
		If this.Value <> this.Tag
			Thisform.DoReplace(.t.) && .t. means do a "Preview" Replace
		Endif
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page2.cmdSaveLine.Click
		Thisform.ReplaceLine()
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page2.cmdSaveLine.Refresh
		Local;
			lcCursor    As String,;
			llReplaced  As Boolean,;
			lnRiskLevel As Number
		
		lcCursor    = Thisform.cSearchResultsAlias
		lnRiskLevel = &lcCursor..ReplaceRisk
		llReplaced  = &lcCursor..Replaced
		
		This.Enabled = Reccount(Thisform.cSearchResultsAlias) > 0 And (m.lnRiskLevel <= Thisform.nReplaceRisk) And !m.llReplaced
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page2.editReplaceLine.Refresh
		Local;
			lcCursor    As String,;
			llReplaced  As Boolean,;
			lnRiskLevel As Number
		
		lcCursor    = Thisform.cSearchResultsAlias
		lnRiskLevel = &lcCursor..ReplaceRisk
		llReplaced  = &lcCursor..Replaced
		
		This.Enabled = !Eof(m.lcCursor) And (m.lnRiskLevel <= Thisform.nReplaceRisk) And !m.llReplaced
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page2.editReplaceLine.Valid
		Local lcCursor, llReplaced, lnRiskLevel
		
		*!*	Replace ReplaceLine with This.Value in (Thisform.cSearchResultsAlias)
		*!*	Replace TrimmedReplaceLine with Thisform.oSearchEngine.TrimWhiteSpace(This.value)	in (Thisform.cSearchResultsAlias)
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdBrowse.Click
		lcFile = GetFile("PRG", "", "Select", 0, "Choose UDF File:")
		
		If Empty(lcFile)
			Thisform.oSearchEngine.cReplaceUDFCode = ""
			Thisform.cReplaceUDFFilename = ""
		Else
			Thisform.oSearchEngine.cReplaceUDFCode = FileToStr(lcFile)
			Thisform.cReplaceUDFFilename = lcFile
		Endif
		
		Thisform.DoReplace(.t.)
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdCheckAll.Click
		ThisForm.CheckAll()
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdCheckAll.Refresh
		This.Visible = Thisform.lReplaceViewMode and Thisform.nReplaceMode <> 3
		
		This.Enabled = (Reccount(Thisform.cSearchResultsAlias) > 0)
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdClearAll.Click
		ThisForm.ClearAll()
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdClearAll.Refresh
		This.Visible = Thisform.lReplaceViewMode and Thisform.nReplaceMode <> 3
		
		This.Enabled = (Reccount(Thisform.cSearchResultsAlias) > 0)
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdEdit.Click
		Local lcFile
		
		lcFile = Thisform.cReplaceUDFFilename
		Modify Command (lcFile)  
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdEdit.Refresh
		This.Enabled = !Empty(Thisform.cReplaceUDFFilename)
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdReplace.Click
		ThisForm.Replace()
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.cmdReplace.Refresh
		This.Enabled = !Empty(Thisform.cReplaceUDFFilename) and ;
						!Empty(Thisform.oSearchEngine.cReplaceUDFCode) and ;
						Reccount(Thisform.cSearchResultsAlias) > 0
		
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Page3.Text1.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = This.Value
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Pageframe.Refresh
		This.ActivePage = Min(Max(Thisform.nReplaceMode-1,1),3)
		
	ENDPROC

	PROCEDURE containerRight.Container1.containerReplaceText.Refresh
		This.Visible = Thisform.lReplaceViewMode
		
		*!*	llEnableControls = (Reccount(Thisform.cSearchResultsAlias) > 0)
		
		*!*	This.SetAll("Enabled", llEnableControls)
		
		*!*	This.cmdHelp.Enabled = .t.
		*!*	This.cmdReplaceHistory.Enabled = .t.
		
		*!*	lnColor = Rgb(128,128,128)
		
		*!*	Do Case
		*!*		Case Thisform.nReplaceRisk = 1 
		*!*			lnColor = Rgb(0,176,80)&& Green
		
		*!*		Case Thisform.nReplaceRisk = 2
		*!*			lnColor = Rgb(255,255,128) && Yellow
		
		*!*		Case Thisform.nReplaceRisk = 3
		*!*			lnColor = Rgb(255,192,0)&& Orange
		*!*	Endcase
		
		*!*	This.BackColor = lnColor
		
	ENDPROC

	PROCEDURE containerRight.Container1.GridFiles.AfterRowColChange
		Lparameters nColIndex
		
		
		thisform.tmrGrid.reset()
		thisform.tmrGrid.Enabled = .t.
		 
	ENDPROC

	PROCEDURE containerRight.Container1.GridFiles.Init
		Thisform.oGrid = This
		
	ENDPROC

	PROCEDURE containerRight.Container1.GridFiles.Refresh
		This.Enabled = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container1.lblResults.Refresh
		
		Local laFileCount[1], laRecordCount[1], lcCursor, lcFilter, lcMessage, llFiltered, lnRecords
		Local lnSeconds, loSearchEngine
		
		loSearchEngine = Thisform.oSearchEngine
		
		lcCursor = Thisform.cSearchResultsAlias
		lcFilter = Filter(lcCursor)
		lnSeconds = thisform.oSearchEngine.nSearchTime
		lcMessage = ""
		
		If Empty(lcFilter)
			lcFilter = "1=1"
		EndIf
		
		lnRecords = Reccount(lcCursor)
		
		Select Count(*) from (Select filename distinct from &lcCursor where &lcFilter order by 1) temp into array laFileCount
		Select Count(*) from (Select matchline from &lcCursor where &lcFilter) temp into array laRecordCount
		
		llFiltered = !Empty(Filter(lcCursor))
		
		Do Case
			*-- If we have a filter, but it results in no results being displayed...
			Case !Thisform.lInit
				lcMessage = ""
				
			Case Thisform.oSearchEngine.nMatchLines = 0 and Thisform.oSearchEngine.lEscPress
				lcMessage = "No Results"
		
			Case Thisform.lSearching
				lcMessage = "Searching..."
		
			Case Thisform.oSearchEngine.nMatchLines > 0 and !Empty(Thisform.cFilter) and Eof(Thisform.cSearchResultsAlias) 
				lcMessage = "No matches on specified filter."
				
			Case Thisform.oSearchEngine.nMatchLines = 0
				lcMessage = "No matches found."
		
			Otherwise 
				lcMessage = Iif(llFiltered, "Filtered to ", "") + ; 
										Alltrim(Str(laRecordCount)) + ;
										Iif(Empty(thisform.oSearchEngine.oSearchOptions.cSearchExpression), " matches ", " match lines") + ;
										" in " + Alltrim(Str(laFileCount)) + " File(s)"
		Endcase
		
		Thisform.cResultsMessage = lcMessage
		
		This.Caption = lcMessage
		
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.ButtonContainer.lblFilePath.Refresh
		#Define Spacing Space(4)
		
		Local lcBaseClass, lcClass, lcFilePath, lcMatchType, lcMethod, lcMethodName, lcObjectName
		Local lcRelativePath, lcTimeStamp, lnMaxWidth, ltTimeStamp
		
		lcFilePath	   = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".filepath"))
		
		ltTimeStamp	= Evaluate(Thisform.cSearchResultsAlias + ".timestamp")
		lcTimeStamp	= Iif(Not Empty(m.ltTimeStamp), Ttoc(m.ltTimeStamp), "")
		
		lcClass = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".Class"))
		If Not Empty(m.lcClass)
			lcBaseClass = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".BaseClass"))
			If Not Empty(m.lcBaseClass)
				lcClass = m.lcClass + " (" + m.lcBaseClass + ")"
			Endif
		
		Endif
		
		lcObjectName = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".Name"))
		lcMethodName = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".MethodName"))
		lcMatchType	 = Alltrim(Evaluate(Thisform.cSearchResultsAlias + ".MatchType"))
		
		Do Case
			Case Empty(m.lcObjectName) And Empty(m.lcMethodName)
				lcMethod = ""
			Case Empty(m.lcObjectName)
				lcMethod =  m.lcMethodName + "()"
			Case Empty(m.lcMethodName)
				lcMethod =  m.lcObjectName
			Otherwise
				lcMethod =  m.lcObjectName + "." + m.lcMethodName + "()"
		Endcase
		
		This.ToolTipText =  "File: " + m.lcFilePath																;
			+ Iif(Empty(m.lcClass), "", CR + "Class: " + m.lcClass)										;
			+ Iif(Empty(m.lcObjectName), "", CR + "Object: " + m.lcObjectName)							;
			+ Iif(Empty(m.lcMethodName), "", CR + Iif(0 # Atc("<Property", m.lcMatchType), "Property: ", "Method: ") + m.lcMethodName) ;
			+ CR + m.lcTimeStamp
		
		lnMaxWidth	   = This.Parent.Width - This.Left - 10
		lcRelativePath = Sys(2014, m.lcFilePath, Curdir())
		
		This.Caption =  Left(m.lcFilePath + Iif(Empty(m.lcClass), "", Spacing + m.lcClass) + Iif(Empty(m.lcMethod), "", Spacing + m.lcMethod) + Spacing + m.lcTimeStamp, 255)
		If This.Width <= m.lnMaxWidth
			Return
		Endif
		
		lcFilePath	 = Lower(m.lcFilePath)
		This.Caption =  Left(m.lcFilePath + Iif(Empty(m.lcClass), "", Spacing + m.lcClass) + Iif(Empty(m.lcMethod), "", Spacing + m.lcMethod) + Spacing + m.lcTimeStamp, 255)
		If This.Width <= m.lnMaxWidth
			Return
		Endif
		
		* consider relative path
		If Len(m.lcRelativePath) < Len(m.lcFilePath) And Not "..\..\..\" $ m.lcRelativePath And Not ":" $ m.lcRelativePath
			lcFilePath	 = Lower(m.lcRelativePath)
			This.Caption =  Left(m.lcFilePath + Iif(Empty(m.lcClass), "", Spacing + m.lcClass) + Iif(Empty(m.lcMethod), "", Spacing + m.lcMethod) + Spacing + m.lcTimeStamp, 255)
			If This.Width <= m.lnMaxWidth
				Return
			Endif
		Endif
		
		This.Caption =  Left(m.lcFilePath + Iif(Empty(m.lcClass), "", Spacing + m.lcClass) + Iif(Empty(m.lcMethod), "", Spacing + m.lcMethod), 255)
		If This.Width <= m.lnMaxWidth
			Return
		Endif
		
		This.Caption =  Left(m.lcFilePath + Iif(Empty(m.lcClass), "", Spacing + m.lcClass), 255)
		If This.Width <= m.lnMaxWidth
			Return
		Endif
		
		This.Caption =  Left(m.lcFilePath, 255)
		If This.Width <= m.lnMaxWidth
			Return
		Endif
		
		This.Caption =  "See tooltip"
		
		
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.cmdCompressCodeview.Click
		Local lnRestorePos, loSplitter
		
		With This.Parent.Parent.Parent
			loSplitter			= .Splitter1
			.Splitter1.Visible	= .T.
			.Container1.Visible	= .T.
		Endwith
		
		Do Case
			Case Thisform.lMaximizeCodeView 
				m.loSplitter.MoveSplitterToPosition(Thisform.Height - 30)
			Case This.Parent.Height > 55
				Thisform.nSplitterPosRatio = m.loSplitter.Top / Thisform.Height
				m.loSplitter.MoveSplitterToPosition(Thisform.Height - 30)
			Otherwise
				lnRestorePos = Int(Evl(Thisform.nSplitterPosRatio, .50) * Thisform.Height)
				m.loSplitter.MoveSplitterToPosition(m.lnRestorePos)
		EndCase
		
		Thisform.lMaximizeCodeView = .F.
		
		This.Parent.Refresh()
		
		Thisform.editSearch.SetFocus()
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.cmdCompressCodeview.Refresh
		This.Visible = .T.
		Do Case
			Case Thisform.nCodeWindowPosition = 1 And This.Parent.Height > 55
				This.Picture	 = "images\Minimizecodeview.gif"
				This.ToolTipText = "Collapse code view"
				This.Visible	 = Not Thisform.lSearching
			Case Thisform.nCodeWindowPosition = 1
				This.Picture	 = "images\Restorecodeview.gif"
				This.ToolTipText = "Expand code view"
				This.Visible	 = Not Thisform.lSearching
			Otherwise
				This.Visible = .F.
		Endcase
		
		
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.cmdMaximizeCodeView.Click
		Local lnRestorePos, loSplitter
		
		Do Case
			Case Thisform.nCodeWindowPosition = 1 and Thisform.lMaximizeCodeView
				Thisform.lMaximizeCodeView = .F.
				With This.Parent.Parent.Parent
					loSplitter			= .Splitter1
					.Splitter1.Visible	= .T.
					.Container1.Visible	= .T.
				Endwith
				lnRestorePos = Int(Evl(Thisform.nSplitterPosRatio, .50) * Thisform.Height)
				m.loSplitter.MoveSplitterToPosition(m.lnRestorePos)
		
				Thisform.oBrowser.SetFocus()
				Thisform.editSearch.SetFocus()
		
			Case Thisform.nCodeWindowPosition = 1 and !Thisform.lMaximizeCodeView and This.Parent.Height > 55
				With This.Parent.Parent.Parent
					loSplitter			= .Splitter1
				Endwith
				Thisform.nSplitterPosRatio = m.loSplitter.Top / Thisform.Height
				Thisform.lMaximizeCodeView = Not Thisform.lMaximizeCodeView
		
			Otherwise
				Thisform.lMaximizeCodeView = Not Thisform.lMaximizeCodeView
		Endcase
		
		
		This.Parent.Refresh()
		
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.cmdMaximizeCodeView.Refresh
		*!* ******************** Removed 11/20/2015 *****************
		*!* Do Case
		*!* 	Case Thisform.lMaximizeCodeView = .F.
		*!* 		This.Picture	 = "images\zoom-in-2-16.bmp"
		*!* 		This.ToolTipText = "Maximize code view (Ctrl+F11)"
		*!* 	Case Thisform.nCodeWindowPosition = 1
		*!* 		This.Picture	 = "images\zoom-out-2-16.bmp"
		*!* 		This.ToolTipText = "Restore to non-collapsed view (Ctrl+F11)"
		*!* 	Otherwise
		*!* 		This.Picture	 = "images\zoom-out-2-16.bmp"
		*!* 		This.ToolTipText = "Restore Down code view (Ctrl+F11)"
		*!* Endcase
		
		
		Do Case
			Case Thisform.nCodeWindowPosition = 1 and Thisform.lMaximizeCodeView
				This.Picture	 = "images\restorecodeview.gif"
				This.ToolTipText = "Restore to non-collapsed view (Ctrl+F11)"
			Case Thisform.nCodeWindowPosition = 1 and !Thisform.lMaximizeCodeView
				This.Picture	 = "images\maximizecodeview.gif"
				This.ToolTipText = "Maximize code view (Ctrl+F11)"
			Case Thisform.lMaximizeCodeView
				This.Picture	 = "images\Restore.bmp"
				This.ToolTipText = "Restore Down code view (Ctrl+F11)"
			Case !Thisform.lMaximizeCodeView
				This.Picture	 = "images\maximize.bmp"
				This.ToolTipText = "Maximize code view (Ctrl+F11)"
		Endcase
		
		This.Visible = Not Thisform.lSearching
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.cmdZoomIn.Refresh
		This.Enabled = Reccount(Thisform.cSearchResultsAlias) > 0
		This.Visible = (This.Parent.Height > 55) And Not Thisform.lSearching
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.cmdZoomOut.Refresh
		This.Enabled = Reccount(Thisform.cSearchResultsAlias) > 0
		This.Visible = (This.Parent.Height > 55) And Not Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.comboViewPosition.Init
		This.AddItem("Below")
		This.AddItem("Right")
		This.AddItem("Left")
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.comboViewPosition.Refresh
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.Init
		Thisform.oWebControl = This
		
		DoDefault()
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.lblCodeView.Refresh
		This.Visible = !Thisform.lSearching
		
	ENDPROC

	PROCEDURE containerRight.Container2.containerWebControl.Resize
		ThisForm.ResizeCodePage()
		
	ENDPROC

	PROCEDURE containerRight.Splitter1.movesplittertoposition
		lparameters tnPosition
		
		DoDefault(tnPosition)
		
		If This.Parent.container2.Height < 55	
			Thisform.ShowHtmlCodeView()
		Endif
		
		Thisform.Refresh() 
	ENDPROC

	PROCEDURE editSearch.GotFocus
		This.Tag = Upper(This.Value)
		
		This.SelStart = 0
		This.SelLength = Len(This.Value)
	ENDPROC

	PROCEDURE editSearch.InteractiveChange
		Local lcFillerChar, lcIllegalCharacters, lcValue
		
		lcValue = This.value
		lcFillerChar = Chr(8)
		
		For x = 1 to 31
			If !lcIllegalCharacters 
				lcIllegalCharacters = Chr(x) $ lcValue
			Endif
			
			lcValue = Strtran(lcValue, Chr(x), lcFillerChar) 
		EndFor
		
		If lcIllegalCharacters
			MessageBox([The search expression contains invalid characters, which will be replaced with "] + lcFillerChar + ["] + ;
						Chr(13) + Chr(13) +;
						"You must correct the search expression before searching will work correctly.", 16, "GoFish notice:")
		Endif
		
		This.value = lcValue
		this.Parent.comboSearchExpressionHistory.Value = lcValue
		  
	ENDPROC

	PROCEDURE editSearch.KeyPress
		LPARAMETERS nKeyCode, nShiftAltCtrl
		
		lcControlSource = This.ControlSource
		
		Store this.value to &lcControlSource
		
		If nKeyCode = 13
			Thisform.Search()
		EndIf
		
		If nKeyCode = 160 && "{ALT+DNARROW}"
			Thisform.comboSearchExpressionHistoryDropDownArrow.SetFocus()
		Endif
		
	ENDPROC

	PROCEDURE editSearch.LostFocus
		Return
		
		
		*!*	If Upper(This.Value) <> This.Tag
		*!*		Thisform.nCurrentId = 0
		*!*		Thisform.oTree.Nodes.Clear()
		*!*		Thisform.ClearSearchResultsCursor()
		*!*		lcFilter = Thisform.cFilter
		*!*		Set Filter To &lcFilter in (thisform.cSearchResultsAlias) && Need to remove any filter that the Treeview has applied	
		*!*		Thisform.ShowHtml("&nbsp")	
		*!*		Thisform.Refresh()
		*!*	EndIf
		
		
	ENDPROC

	PROCEDURE editSearch.MouseEnter
		LPARAMETERS nButton, nShift, nXCoord, nYCoord
		
		This.ToolTipText = This.value
	ENDPROC

	PROCEDURE editSearch.Refresh
		This.Enabled = Not Thisform.lSearching && and !Thisform.lReplaceViewMode
		
		This.FontSize = Thisform.nSearchBoxFontSize
	ENDPROC

	PROCEDURE imgFolder_Pick.Click
		Local;
			lcFolder As String
		
		lcFolder = This.Parent.comboSearchScopeHistory.Value
		If Lower(Justext(m.lcFolder)) == "pjx" Then
			lcFolder = Justpath(m.lcFolder)
		Endif &&LOWER(JUSTEXT(m.lcFolder)) == "pjx"
		
		lcFolder = Getdir(m.lcFolder)
		
		If !Empty(m.lcFolder) Then
			This.Parent.comboSearchScopeHistory.Value = m.lcFolder
		Endif &&!Empty(m.lcFolder)
		
	ENDPROC

	PROCEDURE imgProj_Pick.Click
		Local;
			lcOldFolder As String,;
			lcFolder    As String
		
		lcOldFolder = Fullpath("", "")
		
		lcFolder = This.Parent.comboSearchScopeHistory.Value
		If Lower(Justext(m.lcFolder)) == "pjx" Then
			lcFolder = Justpath(m.lcFolder)
		Endif &&LOWER(JUSTEXT(m.lcFolder)) == "pjx"
		Cd (m.lcFolder)
		
		lcFolder = Getfile("PJX", "Project")
		
		If !Empty(m.lcFolder) AND FILE(m.lcFolder) Then
			This.Parent.comboSearchScopeHistory.Value = m.lcFolder
		Endif &&!Empty(m.lcFolder) AND FILE(m.lcFolder)
		
		
		Cd (m.lcOldFolder)
		
	ENDPROC

	PROCEDURE lblReplaceHistory.Refresh
		This.Enabled = !Thisform.lSearching
	ENDPROC

	PROCEDURE lblScope.Refresh
		This.Enabled = !Thisform.lSearching
	ENDPROC

	PROCEDURE lblSearch.Refresh
		This.Enabled = !Thisform.lSearching;
		 AND (!Thisform.lReplaceViewMode OR (Thisform.lReplaceViewMode AND !Thisform.nReplaceMode=5))
	ENDPROC

	PROCEDURE ProgressBar.Init
		This.Visible = .f.
		
	ENDPROC

	PROCEDURE ProgressBar.start
		Lparameters tnMaxValue, lcCaption
		
		This.Left = Thisform.splitter2.Left + 20 + Thisform.containerRight.Container1.Left
		This.Top = Thisform.oGrid.Top + 85
		This.Label1.Caption = Evl(lcCaption, "Searching...")
		
		DoDefault(tnMaxValue)
	ENDPROC

	PROCEDURE timerShowAdvancedForm.Timer
		If thisform.lInit
			This.Interval = 0
			Thisform.ShowAdvancedForm()
		Endif
		
		
		
	ENDPROC

	PROCEDURE tmrEvent.Timer
		This.Enabled = .F.
		This.Reset()
		
		Thisform.TreeView_RightClick()
		
		
	ENDPROC

	PROCEDURE tmrGrid.Timer
		This.Enabled = .F.
		
		ThisForm.ShowCodeForCurrentRow()
		
		
	ENDPROC

ENDDEFINE
